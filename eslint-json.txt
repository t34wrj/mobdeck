
> mobdeck-mobile-app@1.0.0 lint
> eslint . --ext .js,.jsx,.ts,.tsx --format=json

[{"filePath":"/home/t34wrj/Projects/mobdeck/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/App.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[642,645],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[642,645],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":19,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":19,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[673,724],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[769,772],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[769,772],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":23,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":23,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[804,857],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":24,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":24,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[862,900],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":25,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":25,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[905,965],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":26,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":26,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[970,1030],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":27,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":27,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1035,1081],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1161,1164],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1161,1164],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":32,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":32,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1190,1222],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":34,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":34,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1263,1306],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":35,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":35,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1311,1350],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":36,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":36,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1355,1402],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { Provider } from 'react-redux';\nimport { View, StyleSheet, ActivityIndicator, Platform, Dimensions, StatusBar } from 'react-native';\nimport { store } from './store';\nimport AppNavigator from './navigation/AppNavigator';\nimport { useAppInitialization } from './hooks/useAppInitialization';\nimport { Text } from './components/ui/Text';\nimport { theme } from './components/ui/theme';\n\n// Debug functions for testing through React Native debugger\nif (__DEV__) {\n  const debugInfo = {\n    platform: Platform.OS,\n    version: Platform.Version,\n    dimensions: Dimensions.get('window'),\n    isHermes: !!(global as any).HermesInternal,\n  };\n  \n  console.log('React Native Debug Info:', debugInfo);\n  \n  // Global debug functions\n  (global as any).testReactNative = () => {\n    console.log('Testing React Native functionality...');\n    console.log('Platform:', Platform.OS);\n    console.log('Window dimensions:', Dimensions.get('window'));\n    console.log('Screen dimensions:', Dimensions.get('screen'));\n    console.log('Store state:', store.getState());\n    return 'React Native test completed - check console';\n  };\n  \n  (global as any).testRedux = () => {\n    console.log('Testing Redux...');\n    const state = store.getState();\n    console.log('Current Redux state:', state);\n    console.log('Auth state:', state.auth);\n    console.log('Articles state:', state.articles);\n    return state;\n  };\n}\n\nconst AppContent: React.FC = () => {\n  const { isInitialized, isInitializing, error } = useAppInitialization();\n\n  if (isInitializing) {\n    return (\n      <View style={styles.container}>\n        <ActivityIndicator size=\"large\" color={theme.colors.primary[500]} />\n        <Text variant=\"body1\" style={styles.loadingText}>\n          Initializing app...\n        </Text>\n      </View>\n    );\n  }\n\n  if (error) {\n    return (\n      <View style={styles.container}>\n        <Text variant=\"h5\" style={styles.errorText}>\n          Initialization Error\n        </Text>\n        <Text variant=\"body1\" style={styles.errorMessage}>\n          {error}\n        </Text>\n      </View>\n    );\n  }\n\n  if (!isInitialized) {\n    return null;\n  }\n\n  return <AppNavigator />;\n};\n\nconst App: React.FC = () => {\n  return (\n    <Provider store={store}>\n      <StatusBar \n        backgroundColor={theme.colors.success[700]} \n        barStyle=\"light-content\"\n        translucent={false}\n        animated={false}\n        hidden={false}\n      />\n      <AppContent />\n    </Provider>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: theme.colors.neutral[50],\n    padding: theme.spacing[4],\n  },\n  loadingText: {\n    marginTop: theme.spacing[4],\n    color: theme.colors.neutral[600],\n  },\n  errorText: {\n    color: theme.colors.error[600],\n    marginBottom: theme.spacing[2],\n  },\n  errorMessage: {\n    color: theme.colors.error[500],\n    textAlign: 'center',\n  },\n});\n\nexport default App;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/components/ArticleCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/components/ArticleContent.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":133,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3554,3557],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3554,3557],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":133,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3571,3574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3571,3574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { backgroundColor: 'rgba(0, 0, 0, 0.9)' }","line":274,"column":19,"nodeType":"ObjectExpression","endLine":277,"endColumn":4},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { backgroundColor: 'rgba(0, 0, 0, 0.5)' }","line":301,"column":16,"nodeType":"ObjectExpression","endLine":311,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport {\n  View,\n  StyleSheet,\n  Image,\n  Dimensions,\n  TouchableOpacity,\n  Modal,\n  ScrollView as RNScrollView,\n} from 'react-native';\nimport { Text } from './ui/Text';\nimport { theme } from './ui/theme';\n\nexport interface ArticleContentProps {\n  content: string;\n  summary?: string;\n  imageUrl?: string;\n  fontSize?: 'small' | 'medium' | 'large';\n  fontFamily?: string;\n}\n\nconst { width: screenWidth } = Dimensions.get('window');\n\nconst FontSizes = {\n  small: {\n    body: theme.typography.fontSize.sm,\n    lineHeight: theme.typography.lineHeight.sm,\n  },\n  medium: {\n    body: theme.typography.fontSize.base,\n    lineHeight: theme.typography.lineHeight.base,\n  },\n  large: {\n    body: theme.typography.fontSize.lg,\n    lineHeight: theme.typography.lineHeight.lg,\n  },\n};\n\nexport const ArticleContent: React.FC<ArticleContentProps> = ({\n  content,\n  summary,\n  imageUrl,\n  fontSize = 'medium',\n  fontFamily = theme.typography.fontFamily.regular,\n}) => {\n  const [imageModalVisible, setImageModalVisible] = useState(false);\n  const [imageError, setImageError] = useState(false);\n\n  const contentStyles = {\n    fontSize: FontSizes[fontSize].body,\n    lineHeight: FontSizes[fontSize].lineHeight,\n    fontFamily,\n  };\n\n  // Simple HTML content parser for basic formatting\n  const parseContent = (htmlContent: string): React.ReactNode[] => {\n    // Remove HTML tags and convert basic formatting\n    // This is a simplified parser - in production, consider using a proper HTML parser\n    const processedContent = htmlContent\n      .replace(/<br\\s*\\/?>/gi, '\\n')\n      .replace(/<\\/p>/gi, '\\n\\n')\n      .replace(/<p[^>]*>/gi, '')\n      .replace(/<h[1-6][^>]*>(.*?)<\\/h[1-6]>/gi, '\\n\\n$1\\n\\n')\n      .replace(/<strong[^>]*>(.*?)<\\/strong>/gi, '$1')\n      .replace(/<b[^>]*>(.*?)<\\/b>/gi, '$1')\n      .replace(/<em[^>]*>(.*?)<\\/em>/gi, '$1')\n      .replace(/<i[^>]*>(.*?)<\\/i>/gi, '$1')\n      .replace(/<[^>]*>/g, '') // Remove remaining HTML tags\n      .replace(/&amp;/g, '&')\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&quot;/g, '\"')\n      .replace(/&#39;/g, \"'\")\n      .replace(/&nbsp;/g, ' ')\n      .trim();\n\n    // Split into paragraphs and render\n    const paragraphs = processedContent.split(/\\n\\s*\\n/).filter(p => p.trim());\n\n    return paragraphs.map((paragraph, index) => {\n      // Check if it's likely a heading (short line followed by content)\n      const isHeading =\n        paragraph.length < 100 &&\n        index < paragraphs.length - 1 &&\n        !paragraph.endsWith('.') &&\n        !paragraph.endsWith('!') &&\n        !paragraph.endsWith('?');\n\n      if (isHeading) {\n        return (\n          <Text\n            key={index}\n            variant='h6'\n            style={[\n              styles.heading,\n              {\n                fontSize: FontSizes[fontSize].body * 1.2,\n                lineHeight: FontSizes[fontSize].lineHeight * 1.2,\n                fontFamily,\n              },\n            ]}\n          >\n            {paragraph}\n          </Text>\n        );\n      }\n\n      return (\n        <Text\n          key={index}\n          variant='body1'\n          style={[styles.paragraph, contentStyles]}\n        >\n          {paragraph}\n        </Text>\n      );\n    });\n  };\n\n  // Handle image load error\n  const handleImageError = () => {\n    setImageError(true);\n  };\n\n  // Handle image press\n  const handleImagePress = () => {\n    if (!imageError && imageUrl) {\n      setImageModalVisible(true);\n    }\n  };\n\n  // Render image with fallback\n  const renderImage = (style: any, resizeMode: any = 'cover') => {\n    if (!imageUrl || imageError) {\n      return null;\n    }\n\n    return (\n      <Image\n        source={{ uri: imageUrl }}\n        style={style}\n        resizeMode={resizeMode}\n        onError={handleImageError}\n      />\n    );\n  };\n\n  return (\n    <View style={styles.container}>\n      {/* Article Image */}\n      {imageUrl && !imageError && (\n        <TouchableOpacity\n          style={styles.imageContainer}\n          onPress={handleImagePress}\n          activeOpacity={0.8}\n        >\n          {renderImage(styles.image)}\n        </TouchableOpacity>\n      )}\n\n      {/* Summary */}\n      {summary && (\n        <View style={styles.summaryContainer}>\n          <Text variant='h6' style={styles.summaryTitle}>\n            Summary\n          </Text>\n          <Text variant='body1' style={[styles.summary, contentStyles]}>\n            {summary}\n          </Text>\n        </View>\n      )}\n\n      {/* Content */}\n      <View style={styles.contentContainer}>\n        {content ? (\n          parseContent(content)\n        ) : (\n          <Text variant='body1' style={[styles.noContent, contentStyles]}>\n            No content available for this article.{'\\n\\n'}Pull down to refresh and load content.\n          </Text>\n        )}\n      </View>\n\n      {/* Image Modal */}\n      <Modal\n        visible={imageModalVisible}\n        transparent={true}\n        animationType='fade'\n        onRequestClose={() => setImageModalVisible(false)}\n      >\n        <View style={styles.modalContainer}>\n          <TouchableOpacity\n            style={styles.modalBackground}\n            onPress={() => setImageModalVisible(false)}\n            activeOpacity={1}\n          >\n            <View style={styles.modalContent}>\n              <RNScrollView\n                contentContainerStyle={styles.modalScrollContent}\n                maximumZoomScale={3}\n                minimumZoomScale={1}\n                showsHorizontalScrollIndicator={false}\n                showsVerticalScrollIndicator={false}\n              >\n                {renderImage(styles.modalImage, 'contain')}\n              </RNScrollView>\n\n              <TouchableOpacity\n                style={styles.closeButton}\n                onPress={() => setImageModalVisible(false)}\n              >\n                <Text style={styles.closeButtonText}>✕</Text>\n              </TouchableOpacity>\n            </View>\n          </TouchableOpacity>\n        </View>\n      </Modal>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  imageContainer: {\n    backgroundColor: theme.colors.neutral[100],\n    marginBottom: theme.spacing[4],\n  },\n  image: {\n    width: '100%',\n    height: 200,\n    borderRadius: theme.borderRadius.base,\n  },\n  summaryContainer: {\n    padding: theme.spacing[4],\n    backgroundColor: theme.colors.info[50],\n    borderLeftWidth: 4,\n    borderLeftColor: theme.colors.info[500],\n    marginBottom: theme.spacing[4],\n    marginHorizontal: theme.spacing[4],\n    borderRadius: theme.borderRadius.base,\n  },\n  summaryTitle: {\n    marginBottom: theme.spacing[2],\n    color: theme.colors.info[700],\n    fontWeight: theme.typography.fontWeight.semibold,\n  },\n  summary: {\n    color: theme.colors.info[800],\n  },\n  contentContainer: {\n    paddingHorizontal: theme.spacing[4],\n    paddingBottom: theme.spacing[4],\n  },\n  paragraph: {\n    marginBottom: theme.spacing[4],\n    color: theme.colors.neutral[800],\n    textAlign: 'left',\n  },\n  heading: {\n    marginBottom: theme.spacing[3],\n    marginTop: theme.spacing[2],\n    color: theme.colors.neutral[900],\n    fontWeight: theme.typography.fontWeight.semibold,\n  },\n  noContent: {\n    textAlign: 'center',\n    color: theme.colors.neutral[500],\n    fontStyle: 'italic',\n    marginTop: theme.spacing[6],\n  },\n  // Modal styles\n  modalContainer: {\n    flex: 1,\n    backgroundColor: 'rgba(0, 0, 0, 0.9)',\n  },\n  modalBackground: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  modalContent: {\n    flex: 1,\n    width: '100%',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  modalScrollContent: {\n    flexGrow: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    padding: theme.spacing[4],\n  },\n  modalImage: {\n    width: screenWidth - theme.spacing[8],\n    height: undefined,\n    aspectRatio: 1,\n    maxHeight: '80%',\n  },\n  closeButton: {\n    position: 'absolute',\n    top: 50,\n    right: theme.spacing[4],\n    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n    borderRadius: theme.borderRadius.full,\n    width: 40,\n    height: 40,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  closeButtonText: {\n    color: theme.colors.neutral[50],\n    fontSize: 20,\n    fontWeight: theme.typography.fontWeight.bold,\n  },\n});\n\nexport default ArticleContent;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/components/BackgroundSyncSettings.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1192,1195],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1192,1195],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'loadSyncHistory'. Either include it or remove the dependency array.","line":53,"column":6,"nodeType":"ArrayExpression","endLine":53,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [loadSyncHistory]","fix":{"range":[1362,1364],"text":"[loadSyncHistory]"}}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":61,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":61,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[1554,1607],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { borderBottomColor: '#e0e0e0' }","line":257,"column":15,"nodeType":"ObjectExpression","endLine":264,"endColumn":4},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { color: '#333' }","line":265,"column":17,"nodeType":"ObjectExpression","endLine":268,"endColumn":4},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { color: '#666' }","line":269,"column":17,"nodeType":"ObjectExpression","endLine":272,"endColumn":4},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { backgroundColor: '#f5f5f5' }","line":276,"column":19,"nodeType":"ObjectExpression","endLine":282,"endColumn":4},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { color: '#333' }","line":286,"column":23,"nodeType":"ObjectExpression","endLine":289,"endColumn":4},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { color: '#FFFFFF' }","line":290,"column":23,"nodeType":"ObjectExpression","endLine":292,"endColumn":4},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { borderTopColor: '#e0e0e0' }","line":293,"column":18,"nodeType":"ObjectExpression","endLine":298,"endColumn":4},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { color: '#666' }","line":309,"column":16,"nodeType":"ObjectExpression","endLine":312,"endColumn":4},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { color: '#333' }","line":313,"column":16,"nodeType":"ObjectExpression","endLine":317,"endColumn":4},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { color: '#FFFFFF' }","line":329,"column":25,"nodeType":"ObjectExpression","endLine":333,"endColumn":4},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { borderTopColor: '#e0e0e0' }","line":334,"column":19,"nodeType":"ObjectExpression","endLine":339,"endColumn":4},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { borderBottomColor: '#f0f0f0' }","line":350,"column":17,"nodeType":"ObjectExpression","endLine":354,"endColumn":4},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { color: '#666' }","line":355,"column":16,"nodeType":"ObjectExpression","endLine":358,"endColumn":4},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { color: '#999' }","line":370,"column":19,"nodeType":"ObjectExpression","endLine":374,"endColumn":4},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { color: '#999' }","line":375,"column":14,"nodeType":"ObjectExpression","endLine":381,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * BackgroundSyncSettings - Settings Component for Background Sync\n *\n * Provides UI controls for configuring background sync preferences\n */\n\nimport React, { useState, useEffect } from 'react';\nimport {\n  View,\n  Text,\n  Switch,\n  TouchableOpacity,\n  Alert,\n  StyleSheet,\n} from 'react-native';\nimport { useBackgroundSync, SYNC_INTERVALS } from '../hooks/useBackgroundSync';\nimport { colors } from '../components/ui/theme';\n\ninterface SyncIntervalOption {\n  label: string;\n  value: number;\n}\n\nconst SYNC_INTERVAL_OPTIONS: SyncIntervalOption[] = [\n  { label: 'Manual Only', value: SYNC_INTERVALS.MANUAL },\n  { label: '15 Minutes', value: SYNC_INTERVALS.FIFTEEN_MINUTES },\n  { label: '30 Minutes', value: SYNC_INTERVALS.THIRTY_MINUTES },\n  { label: '1 Hour', value: SYNC_INTERVALS.ONE_HOUR },\n  { label: '2 Hours', value: SYNC_INTERVALS.TWO_HOURS },\n];\n\nexport default function BackgroundSyncSettings() {\n  const {\n    isEnabled,\n    syncInterval,\n    isWifiOnly,\n    isSyncing,\n    lastSyncTime,\n    nextSyncTime,\n    setEnabled,\n    setSyncInterval,\n    setWifiOnly,\n    triggerManualSync,\n    getSyncHistory,\n  } = useBackgroundSync();\n\n  const [syncHistory, setSyncHistory] = useState<any[]>([]);\n  const [isLoadingHistory, setIsLoadingHistory] = useState(false);\n\n  // Load sync history on component mount\n  useEffect(() => {\n    loadSyncHistory();\n  }, []);\n\n  const loadSyncHistory = async () => {\n    setIsLoadingHistory(true);\n    try {\n      const history = await getSyncHistory();\n      setSyncHistory(history);\n    } catch (error) {\n      console.error('Failed to load sync history:', error);\n    } finally {\n      setIsLoadingHistory(false);\n    }\n  };\n\n  const handleToggleEnabled = async (enabled: boolean) => {\n    try {\n      await setEnabled(enabled);\n    } catch (error) {\n      Alert.alert('Error', 'Failed to update background sync setting');\n    }\n  };\n\n  const handleSyncIntervalChange = async (interval: number) => {\n    try {\n      await setSyncInterval(interval);\n    } catch (error) {\n      Alert.alert('Error', 'Failed to update sync interval');\n    }\n  };\n\n  const handleToggleWifiOnly = async (wifiOnly: boolean) => {\n    try {\n      await setWifiOnly(wifiOnly);\n    } catch (error) {\n      Alert.alert('Error', 'Failed to update WiFi-only setting');\n    }\n  };\n\n  const handleManualSync = async () => {\n    try {\n      await triggerManualSync();\n      Alert.alert('Success', 'Manual sync started');\n      // Reload history after sync\n      setTimeout(loadSyncHistory, 2000);\n    } catch (error) {\n      Alert.alert('Error', 'Failed to start manual sync');\n    }\n  };\n\n  const formatTime = (timeString: string | null) => {\n    if (!timeString) return 'Never';\n    return new Date(timeString).toLocaleString();\n  };\n\n  const getCurrentIntervalLabel = () => {\n    const option = SYNC_INTERVAL_OPTIONS.find(\n      opt => opt.value === syncInterval\n    );\n    return option?.label || 'Unknown';\n  };\n\n  return (\n    <View style={styles.container}>\n      <Text style={styles.title}>Background Sync Settings</Text>\n\n      {/* Enable/Disable Background Sync */}\n      <View style={styles.settingRow}>\n        <Text style={styles.settingLabel}>Enable Background Sync</Text>\n        <Switch\n          value={isEnabled}\n          onValueChange={handleToggleEnabled}\n          disabled={isSyncing}\n        />\n      </View>\n\n      {/* Sync Interval */}\n      <View style={styles.settingRow}>\n        <Text style={styles.settingLabel}>Sync Interval</Text>\n        <Text style={styles.settingValue}>{getCurrentIntervalLabel()}</Text>\n      </View>\n\n      {/* Sync Interval Options */}\n      {isEnabled && (\n        <View style={styles.intervalOptions}>\n          {SYNC_INTERVAL_OPTIONS.map(option => (\n            <TouchableOpacity\n              key={option.value}\n              style={[\n                styles.intervalOption,\n                syncInterval === option.value && styles.selectedOption,\n              ]}\n              onPress={() => handleSyncIntervalChange(option.value)}\n              disabled={isSyncing}\n            >\n              <Text\n                style={[\n                  styles.intervalOptionText,\n                  syncInterval === option.value && styles.selectedOptionText,\n                ]}\n              >\n                {option.label}\n              </Text>\n            </TouchableOpacity>\n          ))}\n        </View>\n      )}\n\n      {/* WiFi Only */}\n      <View style={styles.settingRow}>\n        <Text style={styles.settingLabel}>WiFi Only</Text>\n        <Switch\n          value={isWifiOnly}\n          onValueChange={handleToggleWifiOnly}\n          disabled={!isEnabled || isSyncing}\n        />\n      </View>\n\n      {/* Sync Status */}\n      <View style={styles.statusSection}>\n        <Text style={styles.sectionTitle}>Sync Status</Text>\n\n        <View style={styles.statusRow}>\n          <Text style={styles.statusLabel}>Currently Syncing:</Text>\n          <Text style={styles.statusValue}>{isSyncing ? 'Yes' : 'No'}</Text>\n        </View>\n\n        <View style={styles.statusRow}>\n          <Text style={styles.statusLabel}>Last Sync:</Text>\n          <Text style={styles.statusValue}>{formatTime(lastSyncTime)}</Text>\n        </View>\n\n        <View style={styles.statusRow}>\n          <Text style={styles.statusLabel}>Next Sync:</Text>\n          <Text style={styles.statusValue}>\n            {syncInterval === SYNC_INTERVALS.MANUAL\n              ? 'Manual Only'\n              : formatTime(nextSyncTime)}\n          </Text>\n        </View>\n      </View>\n\n      {/* Manual Sync Button */}\n      <TouchableOpacity\n        style={[styles.manualSyncButton, isSyncing && styles.disabledButton]}\n        onPress={handleManualSync}\n        disabled={isSyncing}\n      >\n        <Text style={styles.manualSyncButtonText}>\n          {isSyncing ? 'Syncing...' : 'Sync Now'}\n        </Text>\n      </TouchableOpacity>\n\n      {/* Sync History */}\n      <View style={styles.historySection}>\n        <View style={styles.historyHeader}>\n          <Text style={styles.sectionTitle}>Recent Sync History</Text>\n          <TouchableOpacity\n            onPress={loadSyncHistory}\n            disabled={isLoadingHistory}\n          >\n            <Text style={styles.refreshButton}>\n              {isLoadingHistory ? 'Loading...' : 'Refresh'}\n            </Text>\n          </TouchableOpacity>\n        </View>\n\n        {syncHistory.slice(0, 5).map((entry, index) => (\n          <View key={index} style={styles.historyEntry}>\n            <Text style={styles.historyTime}>\n              {formatTime(entry.timestamp)}\n            </Text>\n            <Text\n              style={[\n                styles.historyStatus,\n                entry.success ? styles.successStatus : styles.errorStatus,\n              ]}\n            >\n              {entry.success ? '✓ Success' : '✗ Failed'}\n            </Text>\n            <Text style={styles.historyDetails}>\n              {entry.success\n                ? `${entry.itemsSynced} items in ${entry.duration}ms`\n                : entry.error || 'Unknown error'}\n            </Text>\n          </View>\n        ))}\n\n        {syncHistory.length === 0 && !isLoadingHistory && (\n          <Text style={styles.noHistory}>No sync history available</Text>\n        )}\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    padding: 16,\n  },\n  title: {\n    fontSize: 20,\n    fontWeight: 'bold',\n    marginBottom: 20,\n  },\n  settingRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    paddingVertical: 12,\n    borderBottomWidth: 1,\n    borderBottomColor: '#e0e0e0',\n  },\n  settingLabel: {\n    fontSize: 16,\n    color: '#333',\n  },\n  settingValue: {\n    fontSize: 16,\n    color: '#666',\n  },\n  intervalOptions: {\n    marginVertical: 10,\n  },\n  intervalOption: {\n    paddingVertical: 8,\n    paddingHorizontal: 12,\n    marginVertical: 2,\n    borderRadius: 6,\n    backgroundColor: '#f5f5f5',\n  },\n  selectedOption: {\n    backgroundColor: colors.primary[500],\n  },\n  intervalOptionText: {\n    fontSize: 14,\n    color: '#333',\n  },\n  selectedOptionText: {\n    color: '#FFFFFF',\n  },\n  statusSection: {\n    marginTop: 20,\n    paddingTop: 20,\n    borderTopWidth: 1,\n    borderTopColor: '#e0e0e0',\n  },\n  sectionTitle: {\n    fontSize: 18,\n    fontWeight: '600',\n    marginBottom: 12,\n  },\n  statusRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    paddingVertical: 6,\n  },\n  statusLabel: {\n    fontSize: 14,\n    color: '#666',\n  },\n  statusValue: {\n    fontSize: 14,\n    color: '#333',\n    fontWeight: '500',\n  },\n  manualSyncButton: {\n    backgroundColor: colors.primary[500],\n    paddingVertical: 12,\n    paddingHorizontal: 24,\n    borderRadius: 8,\n    alignItems: 'center',\n    marginTop: 20,\n  },\n  disabledButton: {\n    backgroundColor: colors.neutral[400],\n  },\n  manualSyncButtonText: {\n    color: '#FFFFFF',\n    fontSize: 16,\n    fontWeight: '600',\n  },\n  historySection: {\n    marginTop: 20,\n    paddingTop: 20,\n    borderTopWidth: 1,\n    borderTopColor: '#e0e0e0',\n  },\n  historyHeader: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: 12,\n  },\n  refreshButton: {\n    color: colors.primary[500],\n    fontSize: 14,\n  },\n  historyEntry: {\n    paddingVertical: 8,\n    borderBottomWidth: 1,\n    borderBottomColor: '#f0f0f0',\n  },\n  historyTime: {\n    fontSize: 12,\n    color: '#666',\n  },\n  historyStatus: {\n    fontSize: 14,\n    fontWeight: '500',\n    marginTop: 2,\n  },\n  successStatus: {\n    color: colors.success[700],\n  },\n  errorStatus: {\n    color: colors.error[500],\n  },\n  historyDetails: {\n    fontSize: 12,\n    color: '#999',\n    marginTop: 2,\n  },\n  noHistory: {\n    fontSize: 14,\n    color: '#999',\n    textAlign: 'center',\n    fontStyle: 'italic',\n    paddingVertical: 20,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/components/ConnectivityIndicator.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'View' is defined but never used.","line":2,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":42},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'animatedValue'. Either include it or remove the dependency array.","line":38,"column":6,"nodeType":"ArrayExpression","endLine":38,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [animatedValue]","fix":{"range":[1356,1358],"text":"[animatedValue]"}}]},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: '#FFFFFF' }","line":91,"column":34,"nodeType":"ObjectExpression","endLine":91,"endColumn":54},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { color: '#FFFFFF' }","line":91,"column":34,"nodeType":"ObjectExpression","endLine":91,"endColumn":54}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\nimport { Text, StyleSheet, Animated, View } from 'react-native';\nimport { useAppTheme } from '../hooks/useAppTheme';\nimport { connectivityManager, ConnectivityStatus } from '../utils/connectivityManager';\nimport Icon from 'react-native-vector-icons/MaterialCommunityIcons';\n\nexport const ConnectivityIndicator: React.FC = () => {\n  const theme = useAppTheme();\n  const [status, setStatus] = useState<ConnectivityStatus>(connectivityManager.getStatus());\n  const [visible, setVisible] = useState(false);\n  const animatedValue = new Animated.Value(0);\n  \n  useEffect(() => {\n    const handleStatusChange = (newStatus: ConnectivityStatus) => {\n      setStatus(newStatus);\n      \n      // Show indicator when offline or server unreachable\n      const shouldShow = newStatus !== ConnectivityStatus.ONLINE;\n      setVisible(shouldShow);\n      \n      // Animate in/out\n      Animated.timing(animatedValue, {\n        toValue: shouldShow ? 1 : 0,\n        duration: 300,\n        useNativeDriver: true,\n      }).start();\n    };\n    \n    // Set initial state\n    handleStatusChange(connectivityManager.getStatus());\n    \n    // Listen for changes\n    connectivityManager.on('statusChanged', handleStatusChange);\n    \n    return () => {\n      connectivityManager.off('statusChanged', handleStatusChange);\n    };\n  }, []);\n  \n  if (!visible && animatedValue._value === 0) {\n    return null;\n  }\n  \n  const getStatusConfig = () => {\n    switch (status) {\n      case ConnectivityStatus.OFFLINE:\n        return {\n          icon: 'wifi-off',\n          text: 'No Internet Connection',\n          backgroundColor: theme.colors.error,\n        };\n      case ConnectivityStatus.SERVER_UNREACHABLE:\n        return {\n          icon: 'server-network-off',\n          text: 'Server Unreachable',\n          backgroundColor: theme.colors.warning || theme.colors.error,\n        };\n      case ConnectivityStatus.CHECKING:\n        return {\n          icon: 'sync',\n          text: 'Checking Connection...',\n          backgroundColor: theme.colors.primary,\n        };\n      default:\n        return null;\n    }\n  };\n  \n  const config = getStatusConfig();\n  if (!config) return null;\n  \n  return (\n    <Animated.View\n      style={[\n        styles.container,\n        {\n          backgroundColor: config.backgroundColor,\n          opacity: animatedValue,\n          transform: [\n            {\n              translateY: animatedValue.interpolate({\n                inputRange: [0, 1],\n                outputRange: [-50, 0],\n              }),\n            },\n          ],\n        },\n      ]}\n    >\n      <Icon name={config.icon} size={20} color=\"#FFFFFF\" style={styles.icon} />\n      <Text style={[styles.text, { color: '#FFFFFF' }]}>{config.text}</Text>\n    </Animated.View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingVertical: 8,\n    paddingHorizontal: 16,\n    zIndex: 1000,\n  },\n  icon: {\n    marginRight: 8,\n  },\n  text: {\n    fontSize: 14,\n    fontWeight: '500',\n  },\n});","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/components/LabelManagementModal.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":71,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":71,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[1952,1999],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":131,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":131,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[3573,3621],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":175,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":175,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[4822,4871],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { borderColor: 'transparent' }","line":479,"column":16,"nodeType":"ObjectExpression","endLine":486,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback } from 'react';\nimport {\n  Modal,\n  View,\n  StyleSheet,\n  ScrollView,\n  TextInput,\n  TouchableOpacity,\n  Alert,\n  ActivityIndicator,\n} from 'react-native';\nimport { Text } from './ui/Text';\nimport { Button } from './ui/Button';\nimport { theme } from './ui/theme';\nimport { labelsApiService } from '../services/LabelsApiService';\nimport { Label } from '../types/labels';\n\nexport interface LabelManagementModalProps {\n  visible: boolean;\n  onClose: () => void;\n  articleId: string;\n  articleTitle: string;\n  currentLabels?: string[];\n  onLabelsChanged?: (labelIds: string[]) => void;\n}\n\nexport const LabelManagementModal: React.FC<LabelManagementModalProps> = ({\n  visible,\n  onClose,\n  articleId,\n  articleTitle,\n  currentLabels = [],\n  onLabelsChanged,\n}) => {\n  const [availableLabels, setAvailableLabels] = useState<Label[]>([]);\n  const [selectedLabelIds, setSelectedLabelIds] =\n    useState<string[]>(currentLabels);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [createMode, setCreateMode] = useState(false);\n  const [newLabelName, setNewLabelName] = useState('');\n  const [newLabelColor, setNewLabelColor] = useState('#2196F3');\n  const [saving, setSaving] = useState(false);\n\n  // Predefined colors for new labels\n  const LABEL_COLORS = [\n    '#2196F3', // Blue\n    '#4CAF50', // Green\n    '#FF9800', // Orange\n    '#9C27B0', // Purple\n    '#F44336', // Red\n    '#607D8B', // Blue Grey\n    '#795548', // Brown\n    '#009688', // Teal\n  ];\n\n  // Load available labels\n  const loadLabels = useCallback(async () => {\n    if (!visible) return;\n\n    try {\n      setLoading(true);\n      const response = await labelsApiService.fetchLabels({\n        limit: 100,\n        searchQuery: searchQuery || undefined,\n        sortBy: 'name',\n        sortOrder: 'asc',\n      });\n      setAvailableLabels(response.items);\n    } catch (error) {\n      console.error('Failed to load labels:', error);\n      Alert.alert('Error', 'Failed to load labels. Please try again.', [\n        { text: 'OK' },\n      ]);\n    } finally {\n      setLoading(false);\n    }\n  }, [visible, searchQuery]);\n\n  // Load labels when modal opens or search changes\n  useEffect(() => {\n    loadLabels();\n  }, [loadLabels]);\n\n  // Reset form when modal closes\n  useEffect(() => {\n    if (!visible) {\n      setSearchQuery('');\n      setCreateMode(false);\n      setNewLabelName('');\n      setNewLabelColor('#2196F3');\n      setSelectedLabelIds(currentLabels);\n    }\n  }, [visible, currentLabels]);\n\n  // Handle label selection toggle\n  const handleLabelToggle = useCallback((labelId: string) => {\n    setSelectedLabelIds(prev => {\n      if (prev.includes(labelId)) {\n        return prev.filter(id => id !== labelId);\n      } else {\n        return [...prev, labelId];\n      }\n    });\n  }, []);\n\n  // Handle creating a new label\n  const handleCreateLabel = useCallback(async () => {\n    if (!newLabelName.trim()) {\n      Alert.alert('Error', 'Label name is required.');\n      return;\n    }\n\n    try {\n      setLoading(true);\n      const newLabel = await labelsApiService.createLabel({\n        name: newLabelName.trim(),\n        color: newLabelColor,\n      });\n\n      // Add to available labels and select it\n      setAvailableLabels(prev => [newLabel, ...prev]);\n      setSelectedLabelIds(prev => [...prev, newLabel.id]);\n\n      // Reset form\n      setNewLabelName('');\n      setCreateMode(false);\n\n      Alert.alert('Success', `Label \"${newLabel.name}\" created successfully!`);\n    } catch (error) {\n      console.error('Failed to create label:', error);\n      Alert.alert('Error', 'Failed to create label. Please try again.', [\n        { text: 'OK' },\n      ]);\n    } finally {\n      setLoading(false);\n    }\n  }, [newLabelName, newLabelColor]);\n\n  // Handle saving changes\n  const handleSave = useCallback(async () => {\n    try {\n      setSaving(true);\n\n      // Determine which labels to add and remove\n      const labelsToAdd = selectedLabelIds.filter(\n        id => !currentLabels.includes(id)\n      );\n      const labelsToRemove = currentLabels.filter(\n        id => !selectedLabelIds.includes(id)\n      );\n\n      // Execute label assignments/removals\n      const promises: Promise<void>[] = [];\n\n      labelsToAdd.forEach(labelId => {\n        promises.push(labelsApiService.assignToArticle({ labelId, articleId }));\n      });\n\n      labelsToRemove.forEach(labelId => {\n        promises.push(\n          labelsApiService.removeFromArticle({ labelId, articleId })\n        );\n      });\n\n      await Promise.all(promises);\n\n      // Notify parent of changes\n      onLabelsChanged?.(selectedLabelIds);\n\n      Alert.alert('Success', 'Article labels updated successfully!', [\n        { text: 'OK', onPress: onClose },\n      ]);\n    } catch (error) {\n      console.error('Failed to update labels:', error);\n      Alert.alert('Error', 'Failed to update labels. Please try again.', [\n        { text: 'OK' },\n      ]);\n    } finally {\n      setSaving(false);\n    }\n  }, [selectedLabelIds, currentLabels, articleId, onLabelsChanged, onClose]);\n\n  // Render label item\n  const renderLabelItem = useCallback(\n    (label: Label) => {\n      const isSelected = selectedLabelIds.includes(label.id);\n\n      return (\n        <TouchableOpacity\n          key={label.id}\n          style={[styles.labelItem, isSelected && styles.selectedLabelItem]}\n          onPress={() => handleLabelToggle(label.id)}\n          activeOpacity={0.7}\n        >\n          <View\n            style={[\n              styles.labelColorIndicator,\n              { backgroundColor: label.color || theme.colors.neutral[400] },\n            ]}\n          />\n          <View style={styles.labelContent}>\n            <Text\n              variant='body2'\n              style={[styles.labelName, isSelected && styles.selectedLabelName]}\n            >\n              {label.name}\n            </Text>\n            <Text variant='caption' style={styles.labelCount}>\n              {label.articleCount} articles\n            </Text>\n          </View>\n          <View style={[styles.checkbox, isSelected && styles.checkedCheckbox]}>\n            {isSelected && <Text style={styles.checkmark}>✓</Text>}\n          </View>\n        </TouchableOpacity>\n      );\n    },\n    [selectedLabelIds, handleLabelToggle]\n  );\n\n  // Render color selector\n  const renderColorSelector = () => (\n    <View style={styles.colorSelectorContainer}>\n      <Text variant='body2' style={styles.colorSelectorLabel}>\n        Color:\n      </Text>\n      <ScrollView\n        horizontal\n        showsHorizontalScrollIndicator={false}\n        style={styles.colorSelector}\n      >\n        {LABEL_COLORS.map(color => (\n          <TouchableOpacity\n            key={color}\n            style={[\n              styles.colorOption,\n              { backgroundColor: color },\n              newLabelColor === color && styles.selectedColorOption,\n            ]}\n            onPress={() => setNewLabelColor(color)}\n          />\n        ))}\n      </ScrollView>\n    </View>\n  );\n\n  return (\n    <Modal\n      visible={visible}\n      animationType='slide'\n      presentationStyle='pageSheet'\n      onRequestClose={onClose}\n    >\n      <View style={styles.container}>\n        {/* Header */}\n        <View style={styles.header}>\n          <TouchableOpacity onPress={onClose} style={styles.closeButton}>\n            <Text variant='body1' style={styles.closeButtonText}>\n              Cancel\n            </Text>\n          </TouchableOpacity>\n          <Text variant='h6' style={styles.headerTitle}>\n            Manage Labels\n          </Text>\n          <Button\n            variant='ghost'\n            size='sm'\n            onPress={handleSave}\n            loading={saving}\n            disabled={loading}\n          >\n            <Text>Save</Text>\n          </Button>\n        </View>\n\n        {/* Article Info */}\n        <View style={styles.articleInfo}>\n          <Text variant='caption' style={styles.articleLabel}>\n            Article:\n          </Text>\n          <Text\n            variant='body2'\n            numberOfLines={2}\n            ellipsizeMode='tail'\n            style={styles.articleTitle}\n          >\n            {articleTitle}\n          </Text>\n        </View>\n\n        {/* Search Bar */}\n        <View style={styles.searchContainer}>\n          <TextInput\n            style={styles.searchInput}\n            placeholder='Search labels...'\n            value={searchQuery}\n            onChangeText={setSearchQuery}\n            placeholderTextColor={theme.colors.neutral[500]}\n          />\n        </View>\n\n        {/* Create New Label Section */}\n        {createMode ? (\n          <View style={styles.createLabelSection}>\n            <Text variant='h6' style={styles.createLabelTitle}>\n              Create New Label\n            </Text>\n            <TextInput\n              style={styles.newLabelInput}\n              placeholder='Label name'\n              value={newLabelName}\n              onChangeText={setNewLabelName}\n              placeholderTextColor={theme.colors.neutral[500]}\n              maxLength={50}\n            />\n            {renderColorSelector()}\n            <View style={styles.createLabelActions}>\n              <Button\n                variant='outline'\n                size='sm'\n                onPress={() => setCreateMode(false)}\n                style={styles.createLabelButton}\n              >\n                <Text>Cancel</Text>\n              </Button>\n              <Button\n                variant='primary'\n                size='sm'\n                onPress={handleCreateLabel}\n                loading={loading}\n                style={styles.createLabelButton}\n              >\n                <Text>Create</Text>\n              </Button>\n            </View>\n          </View>\n        ) : (\n          <View style={styles.createButtonContainer}>\n            <Button\n              variant='outline'\n              size='sm'\n              onPress={() => setCreateMode(true)}\n              style={styles.createNewButton}\n            >\n              <Text>+ Create New Label</Text>\n            </Button>\n          </View>\n        )}\n\n        {/* Labels List */}\n        <ScrollView\n          style={styles.labelsList}\n          showsVerticalScrollIndicator={false}\n        >\n          {loading ? (\n            <View style={styles.loadingContainer}>\n              <ActivityIndicator\n                size='large'\n                color={theme.colors.primary[500]}\n              />\n              <Text variant='body1' style={styles.loadingText}>\n                Loading labels...\n              </Text>\n            </View>\n          ) : availableLabels.length === 0 ? (\n            <View style={styles.emptyContainer}>\n              <Text variant='body1' style={styles.emptyText}>\n                {searchQuery ? 'No labels found' : 'No labels available'}\n              </Text>\n              <Text variant='caption' style={styles.emptySubtext}>\n                {searchQuery\n                  ? `No labels match \"${searchQuery}\"`\n                  : 'Create your first label to get started'}\n              </Text>\n            </View>\n          ) : (\n            availableLabels.map(renderLabelItem)\n          )}\n        </ScrollView>\n\n        {/* Selected Labels Summary */}\n        {selectedLabelIds.length > 0 && (\n          <View style={styles.summaryContainer}>\n            <Text variant='caption' style={styles.summaryText}>\n              {selectedLabelIds.length} label\n              {selectedLabelIds.length !== 1 ? 's' : ''} selected\n            </Text>\n          </View>\n        )}\n      </View>\n    </Modal>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: theme.colors.neutral[50],\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    paddingHorizontal: theme.spacing[4],\n    paddingVertical: theme.spacing[3],\n    backgroundColor: theme.colors.neutral[100],\n    borderBottomWidth: 1,\n    borderBottomColor: theme.colors.neutral[200],\n  },\n  closeButton: {\n    padding: theme.spacing[1],\n  },\n  closeButtonText: {\n    color: theme.colors.primary[600],\n  },\n  headerTitle: {\n    flex: 1,\n    textAlign: 'center',\n    color: theme.colors.neutral[900],\n  },\n  articleInfo: {\n    padding: theme.spacing[4],\n    backgroundColor: theme.colors.info[50],\n    borderBottomWidth: 1,\n    borderBottomColor: theme.colors.neutral[200],\n  },\n  articleLabel: {\n    color: theme.colors.neutral[600],\n    marginBottom: theme.spacing[1],\n  },\n  articleTitle: {\n    color: theme.colors.neutral[800],\n  },\n  searchContainer: {\n    paddingHorizontal: theme.spacing[4],\n    paddingVertical: theme.spacing[3],\n    backgroundColor: theme.colors.neutral[100],\n  },\n  searchInput: {\n    backgroundColor: theme.colors.neutral[50],\n    borderRadius: theme.borderRadius.base,\n    paddingHorizontal: theme.spacing[3],\n    paddingVertical: theme.spacing[3],\n    fontSize: theme.typography.fontSize.base,\n    borderWidth: 1,\n    borderColor: theme.colors.neutral[300],\n  },\n  createLabelSection: {\n    padding: theme.spacing[4],\n    backgroundColor: theme.colors.primary[50],\n    borderBottomWidth: 1,\n    borderBottomColor: theme.colors.neutral[200],\n  },\n  createLabelTitle: {\n    marginBottom: theme.spacing[3],\n    color: theme.colors.primary[700],\n  },\n  newLabelInput: {\n    backgroundColor: theme.colors.neutral[50],\n    borderRadius: theme.borderRadius.base,\n    paddingHorizontal: theme.spacing[3],\n    paddingVertical: theme.spacing[3],\n    fontSize: theme.typography.fontSize.base,\n    borderWidth: 1,\n    borderColor: theme.colors.neutral[300],\n    marginBottom: theme.spacing[3],\n  },\n  colorSelectorContainer: {\n    marginBottom: theme.spacing[3],\n  },\n  colorSelectorLabel: {\n    marginBottom: theme.spacing[2],\n    color: theme.colors.neutral[700],\n  },\n  colorSelector: {\n    flexDirection: 'row',\n  },\n  colorOption: {\n    width: 32,\n    height: 32,\n    borderRadius: theme.borderRadius.full,\n    marginRight: theme.spacing[2],\n    borderWidth: 2,\n    borderColor: 'transparent',\n  },\n  selectedColorOption: {\n    borderColor: theme.colors.neutral[900],\n  },\n  createLabelActions: {\n    flexDirection: 'row',\n    justifyContent: 'flex-end',\n    gap: theme.spacing[2],\n  },\n  createLabelButton: {\n    minWidth: 80,\n  },\n  createButtonContainer: {\n    paddingHorizontal: theme.spacing[4],\n    paddingVertical: theme.spacing[2],\n  },\n  createNewButton: {\n    alignSelf: 'flex-start',\n  },\n  labelsList: {\n    flex: 1,\n    paddingHorizontal: theme.spacing[4],\n  },\n  labelItem: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingVertical: theme.spacing[3],\n    paddingHorizontal: theme.spacing[3],\n    marginVertical: theme.spacing[1],\n    backgroundColor: theme.colors.neutral[50],\n    borderRadius: theme.borderRadius.base,\n    borderWidth: 1,\n    borderColor: theme.colors.neutral[200],\n  },\n  selectedLabelItem: {\n    backgroundColor: theme.colors.primary[50],\n    borderColor: theme.colors.primary[300],\n  },\n  labelColorIndicator: {\n    width: 12,\n    height: 12,\n    borderRadius: theme.borderRadius.full,\n    marginRight: theme.spacing[3],\n  },\n  labelContent: {\n    flex: 1,\n  },\n  labelName: {\n    color: theme.colors.neutral[800],\n    marginBottom: theme.spacing[1],\n  },\n  selectedLabelName: {\n    color: theme.colors.primary[700],\n    fontWeight: theme.typography.fontWeight.medium,\n  },\n  labelCount: {\n    color: theme.colors.neutral[500],\n  },\n  checkbox: {\n    width: 20,\n    height: 20,\n    borderRadius: theme.borderRadius.sm,\n    borderWidth: 2,\n    borderColor: theme.colors.neutral[400],\n    alignItems: 'center',\n    justifyContent: 'center',\n    backgroundColor: theme.colors.neutral[50],\n  },\n  checkedCheckbox: {\n    backgroundColor: theme.colors.primary[500],\n    borderColor: theme.colors.primary[500],\n  },\n  checkmark: {\n    color: theme.colors.neutral[50],\n    fontSize: 12,\n    fontWeight: theme.typography.fontWeight.bold,\n  },\n  loadingContainer: {\n    alignItems: 'center',\n    paddingVertical: theme.spacing[6],\n  },\n  loadingText: {\n    marginTop: theme.spacing[2],\n    color: theme.colors.neutral[600],\n  },\n  emptyContainer: {\n    alignItems: 'center',\n    paddingVertical: theme.spacing[6],\n  },\n  emptyText: {\n    color: theme.colors.neutral[600],\n    marginBottom: theme.spacing[1],\n  },\n  emptySubtext: {\n    color: theme.colors.neutral[500],\n    textAlign: 'center',\n  },\n  summaryContainer: {\n    padding: theme.spacing[3],\n    backgroundColor: theme.colors.primary[50],\n    borderTopWidth: 1,\n    borderTopColor: theme.colors.neutral[200],\n    alignItems: 'center',\n  },\n  summaryText: {\n    color: theme.colors.primary[700],\n    fontWeight: theme.typography.fontWeight.medium,\n  },\n});\n\nexport default LabelManagementModal;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/components/MobdeckLogo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/components/SearchBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/components/SyncSettings.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":30,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":30,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[957,1047],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":42,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":42,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1303,1357],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":45,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":45,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1450,1505],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":48,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":48,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1554,1618],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":58,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":58,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1837,1895],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":60,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":60,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[1922,1979],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":72,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":72,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[2328,2387],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":81,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":81,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[2608,2668],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":95,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":95,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[3034,3094],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":119,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":119,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3862,3938],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback } from 'react';\nimport { View, StyleSheet, Alert, ActivityIndicator } from 'react-native';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { Text } from './ui/Text';\nimport { Button } from './ui/Button';\nimport { theme } from './ui/theme';\nimport { RootState, AppDispatch } from '../store';\nimport {\n  pauseSync,\n  clearSyncError,\n  resetSyncStatus,\n  cancelSync,\n} from '../store/slices/syncSlice';\nimport { \n  startSyncOperation,\n  pauseSyncOperation,\n  resumeSyncOperation,\n  cancelSyncOperation,\n} from '../store/thunks/syncThunks';\nimport { SyncStatus } from '../types/sync';\n\nexport const SyncSettings: React.FC = () => {\n  const dispatch = useDispatch<AppDispatch>();\n  const { status, error, isOnline, networkType, progress, lastSyncTime } =\n    useSelector((state: RootState) => state.sync);\n\n  const [manualSyncLoading, setManualSyncLoading] = useState(false);\n\n  // Debug log the sync state\n  console.log('[SyncSettings] Full sync state:', { status, error, isOnline, lastSyncTime });\n\n  const handleManualSync = useCallback(async () => {\n    if (!isOnline) {\n      Alert.alert(\n        'No Connection',\n        'Cannot sync while offline. Please check your internet connection and try again.'\n      );\n      return;\n    }\n\n    try {\n      console.log('[SyncSettings] Starting manual sync...');\n      setManualSyncLoading(true);\n      // Reset sync status before starting new sync\n      console.log('[SyncSettings] Resetting sync status...');\n      dispatch(resetSyncStatus());\n      \n      console.log('[SyncSettings] Dispatching startSyncOperation...');\n      await dispatch(\n        startSyncOperation({\n          syncOptions: {\n            fullTextSync: true,\n            downloadImages: true,\n          },\n          forceFull: false,\n        })\n      ).unwrap();\n      console.log('[SyncSettings] Sync completed successfully');\n    } catch (err) {\n      console.error('[SyncSettings] Manual sync failed:', err);\n      Alert.alert('Sync Error', err?.message || 'Failed to start sync. Please try again.');\n    } finally {\n      setManualSyncLoading(false);\n    }\n  }, [dispatch, isOnline]);\n\n  const handlePauseSync = useCallback(async () => {\n    try {\n      await dispatch(pauseSyncOperation()).unwrap();\n      dispatch(pauseSync());\n    } catch (err) {\n      console.error('[SyncSettings] Failed to pause sync:', err);\n      Alert.alert('Error', 'Failed to pause sync');\n    }\n  }, [dispatch]);\n\n  const handleResumeSync = useCallback(async () => {\n    try {\n      await dispatch(resumeSyncOperation()).unwrap();\n    } catch (err) {\n      console.error('[SyncSettings] Failed to resume sync:', err);\n      Alert.alert('Error', err?.message || 'Failed to resume sync');\n    }\n  }, [dispatch]);\n\n  const handleClearError = useCallback(() => {\n    dispatch(clearSyncError());\n  }, [dispatch]);\n\n  const handleCancelSync = useCallback(async () => {\n    try {\n      await dispatch(cancelSyncOperation()).unwrap();\n      dispatch(cancelSync());\n    } catch (err) {\n      console.error('[SyncSettings] Failed to cancel sync:', err);\n      Alert.alert('Error', 'Failed to cancel sync');\n    }\n  }, [dispatch]);\n\n  const formatLastSyncTime = () => {\n    if (!lastSyncTime) return 'Never';\n\n    const now = new Date();\n    const syncTime = new Date(lastSyncTime);\n    const diffMs = now.getTime() - syncTime.getTime();\n    const diffMins = Math.floor(diffMs / (1000 * 60));\n    const diffHours = Math.floor(diffMins / 60);\n    const diffDays = Math.floor(diffHours / 24);\n\n    if (diffMins < 1) return 'Just now';\n    if (diffMins < 60)\n      return `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;\n    if (diffHours < 24)\n      return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;\n    return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;\n  };\n\n  const getSyncStatusText = () => {\n    console.log('[SyncSettings] Current sync status:', status, 'Error:', error);\n    switch (status) {\n      case SyncStatus.IDLE:\n        return 'Ready to sync';\n      case SyncStatus.SYNCING:\n        return `Syncing... ${progress.processedItems}/${progress.totalItems}`;\n      case SyncStatus.PAUSED:\n        return 'Sync paused';\n      case SyncStatus.SUCCESS:\n        return 'Last sync completed successfully';\n      case SyncStatus.ERROR:\n        return 'Sync failed';\n      default:\n        return 'Unknown status';\n    }\n  };\n\n  const getSyncStatusColor = () => {\n    switch (status) {\n      case SyncStatus.IDLE:\n        return theme.colors.neutral[600];\n      case SyncStatus.SYNCING:\n        return theme.colors.primary[600];\n      case SyncStatus.PAUSED:\n        return theme.colors.warning[600];\n      case SyncStatus.SUCCESS:\n        return theme.colors.success[600];\n      case SyncStatus.ERROR:\n        return theme.colors.error[600];\n      default:\n        return theme.colors.neutral[600];\n    }\n  };\n\n  const getNetworkStatusText = () => {\n    if (!isOnline) return 'Offline';\n    if (networkType === 'wifi') return 'WiFi';\n    if (networkType === 'cellular') return 'Cellular';\n    return 'Connected';\n  };\n\n  const getNetworkStatusColor = () => {\n    if (!isOnline) return theme.colors.error[600];\n    if (networkType === 'wifi') return theme.colors.success[600];\n    if (networkType === 'cellular') return theme.colors.warning[600];\n    return theme.colors.success[600];\n  };\n\n  const renderSyncProgress = () => {\n    if (status !== SyncStatus.SYNCING) return null;\n\n    const progressPercentage =\n      progress.totalItems > 0\n        ? Math.round((progress.processedItems / progress.totalItems) * 100)\n        : 0;\n\n    return (\n      <View style={styles.progressContainer}>\n        <View style={styles.progressHeader}>\n          <Text variant='body2' style={styles.progressText}>\n            {progress.phase.replace('_', ' ').toLowerCase()}\n          </Text>\n          <Text variant='body2' style={styles.progressText}>\n            {progressPercentage}%\n          </Text>\n        </View>\n        <View style={styles.progressBar}>\n          <View\n            style={[styles.progressFill, { width: `${progressPercentage}%` }]}\n          />\n        </View>\n        {progress.currentItem && (\n          <Text variant='caption' style={styles.currentItem} numberOfLines={1}>\n            Processing: {progress.currentItem}\n          </Text>\n        )}\n        {!!progress.estimatedTimeRemaining && (\n          <Text variant='caption' style={styles.timeRemaining}>\n            ~{Math.round(progress.estimatedTimeRemaining / 1000)}s remaining\n          </Text>\n        )}\n      </View>\n    );\n  };\n\n\n  const renderSyncControls = () => {\n    const isSyncing = status === SyncStatus.SYNCING;\n    const isPaused = status === SyncStatus.PAUSED;\n\n    return (\n      <View style={styles.controlsContainer}>\n        {!isSyncing && !isPaused && (\n          <Button\n            variant='primary'\n            onPress={handleManualSync}\n            loading={manualSyncLoading}\n            disabled={!isOnline}\n            fullWidth\n          >\n            {isOnline ? 'Sync Now' : 'No Connection'}\n          </Button>\n        )}\n\n\n        {isSyncing && (\n          <Button variant='secondary' onPress={handlePauseSync} fullWidth>\n            <Text>Pause Sync</Text>\n          </Button>\n        )}\n\n        {isPaused && (\n          <View style={styles.pausedControls}>\n            <Button\n              variant='primary'\n              onPress={handleResumeSync}\n              style={styles.resumeButton}\n            >\n              <Text>Resume</Text>\n            </Button>\n            <Button\n              variant='outline'\n              onPress={handleCancelSync}\n              style={styles.cancelButton}\n            >\n              <Text>Cancel</Text>\n            </Button>\n          </View>\n        )}\n      </View>\n    );\n  };\n\n  const renderError = () => {\n    if (!error) return null;\n\n    return (\n      <View style={styles.errorContainer}>\n        <Text variant='body2' style={styles.errorText}>\n          {error}\n        </Text>\n        <Button\n          variant='outline'\n          size='sm'\n          onPress={handleClearError}\n          style={styles.clearErrorButton}\n        >\n          <Text>Dismiss</Text>\n        </Button>\n      </View>\n    );\n  };\n\n  return (\n    <View style={styles.container}>\n      {/* Sync Status */}\n      <View style={styles.statusContainer}>\n        <View style={styles.statusRow}>\n          <View style={styles.statusInfo}>\n            <Text variant='body1' style={styles.statusLabel}>\n              Sync Status\n            </Text>\n            <View style={styles.statusIndicator}>\n              {status === SyncStatus.SYNCING && (\n                <ActivityIndicator\n                  size='small'\n                  color={theme.colors.primary[500]}\n                  style={styles.statusSpinner}\n                />\n              )}\n              <Text\n                variant='body2'\n                style={[styles.statusText, { color: getSyncStatusColor() }]}\n              >\n                {getSyncStatusText()}\n              </Text>\n            </View>\n          </View>\n        </View>\n\n        <View style={styles.statusRow}>\n          <View style={styles.statusInfo}>\n            <Text variant='body1' style={styles.statusLabel}>\n              Network\n            </Text>\n            <Text\n              variant='body2'\n              style={[styles.statusText, { color: getNetworkStatusColor() }]}\n            >\n              {getNetworkStatusText()}\n            </Text>\n          </View>\n        </View>\n\n        <View style={styles.statusRow}>\n          <View style={styles.statusInfo}>\n            <Text variant='body1' style={styles.statusLabel}>\n              Last Sync\n            </Text>\n            <Text variant='body2' style={styles.statusText}>\n              {formatLastSyncTime()}\n            </Text>\n          </View>\n        </View>\n      </View>\n\n      {/* Sync Progress */}\n      {renderSyncProgress()}\n\n      {/* Error Display */}\n      {renderError()}\n\n      {/* Sync Controls */}\n      {renderSyncControls()}\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    backgroundColor: theme.colors.neutral[50],\n    borderRadius: theme.borderRadius.md,\n    padding: theme.spacing[4],\n    marginHorizontal: theme.spacing[4],\n    marginVertical: theme.spacing[3],\n    ...theme.shadows.sm,\n  },\n  statusContainer: {\n    marginBottom: theme.spacing[4],\n  },\n  statusRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: theme.spacing[2],\n  },\n  statusInfo: {\n    flex: 1,\n  },\n  statusLabel: {\n    color: theme.colors.neutral[700],\n    marginBottom: theme.spacing[1],\n  },\n  statusIndicator: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  statusSpinner: {\n    marginRight: theme.spacing[2],\n  },\n  statusText: {\n    fontWeight: theme.typography.fontWeight.medium,\n  },\n  progressContainer: {\n    marginBottom: theme.spacing[4],\n    padding: theme.spacing[3],\n    backgroundColor: theme.colors.primary[50],\n    borderRadius: theme.borderRadius.base,\n    borderWidth: 1,\n    borderColor: theme.colors.primary[200],\n  },\n  progressHeader: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: theme.spacing[2],\n  },\n  progressText: {\n    color: theme.colors.primary[700],\n    fontWeight: theme.typography.fontWeight.medium,\n    textTransform: 'capitalize',\n  },\n  progressBar: {\n    height: 6,\n    backgroundColor: theme.colors.primary[200],\n    borderRadius: theme.borderRadius.full,\n    overflow: 'hidden',\n    marginBottom: theme.spacing[2],\n  },\n  progressFill: {\n    height: '100%',\n    backgroundColor: theme.colors.primary[500],\n    borderRadius: theme.borderRadius.full,\n  },\n  currentItem: {\n    color: theme.colors.primary[600],\n    marginBottom: theme.spacing[1],\n  },\n  timeRemaining: {\n    color: theme.colors.primary[600],\n    textAlign: 'right',\n  },\n  controlsContainer: {\n    marginTop: theme.spacing[2],\n  },\n  pausedControls: {\n    flexDirection: 'row',\n    gap: theme.spacing[3],\n  },\n  resumeButton: {\n    flex: 1,\n  },\n  cancelButton: {\n    flex: 1,\n  },\n  errorContainer: {\n    backgroundColor: theme.colors.error[50],\n    borderWidth: 1,\n    borderColor: theme.colors.error[200],\n    borderRadius: theme.borderRadius.base,\n    padding: theme.spacing[3],\n    marginBottom: theme.spacing[4],\n  },\n  errorText: {\n    color: theme.colors.error[700],\n    marginBottom: theme.spacing[2],\n  },\n  clearErrorButton: {\n    alignSelf: 'flex-start',\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/components/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/components/ui/Button.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":171,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4171,4174],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4171,4174],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport {\n  TouchableOpacity,\n  TouchableOpacityProps,\n  ViewStyle,\n  TextStyle,\n  ActivityIndicator,\n  View,\n} from 'react-native';\nimport { Text } from './Text';\nimport { theme } from './theme';\n\nexport interface ButtonProps extends Omit<TouchableOpacityProps, 'style'> {\n  variant?: 'primary' | 'secondary' | 'outline' | 'ghost' | 'destructive';\n  size?: 'sm' | 'md' | 'lg';\n  loading?: boolean;\n  disabled?: boolean;\n  leftIcon?: React.ReactNode;\n  rightIcon?: React.ReactNode;\n  style?: ViewStyle | ViewStyle[];\n  textStyle?: TextStyle | TextStyle[];\n  children: React.ReactNode;\n  fullWidth?: boolean;\n}\n\nconst getButtonStyles = (\n  variant: NonNullable<ButtonProps['variant']>,\n  size: NonNullable<ButtonProps['size']>,\n  disabled: boolean,\n  fullWidth: boolean\n): { container: ViewStyle; text: TextStyle } => {\n  const baseContainer: ViewStyle = {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    borderRadius: theme.borderRadius.base,\n    ...(fullWidth && { alignSelf: 'stretch' }),\n  };\n\n  const baseText: TextStyle = {\n    fontWeight: theme.typography.fontWeight.medium,\n  };\n\n  // Size styles\n  const sizeStyles = {\n    sm: {\n      container: {\n        paddingHorizontal: theme.spacing[3],\n        paddingVertical: theme.spacing[2],\n        minHeight: 32,\n      },\n      text: {\n        fontSize: theme.typography.fontSize.sm,\n        lineHeight: theme.typography.lineHeight.sm,\n      },\n    },\n    md: {\n      container: {\n        paddingHorizontal: theme.spacing[4],\n        paddingVertical: theme.spacing[3],\n        minHeight: 40,\n      },\n      text: {\n        fontSize: theme.typography.fontSize.base,\n        lineHeight: theme.typography.lineHeight.base,\n      },\n    },\n    lg: {\n      container: {\n        paddingHorizontal: theme.spacing[6],\n        paddingVertical: theme.spacing[4],\n        minHeight: 48,\n      },\n      text: {\n        fontSize: theme.typography.fontSize.lg,\n        lineHeight: theme.typography.lineHeight.lg,\n      },\n    },\n  };\n\n  // Variant styles\n  const variantStyles = {\n    primary: {\n      container: {\n        backgroundColor: disabled\n          ? theme.colors.neutral[300]\n          : theme.colors.primary[500],\n        ...theme.shadows.sm,\n      },\n      text: {\n        color: disabled ? theme.colors.neutral[500] : theme.colors.neutral[50],\n      },\n    },\n    secondary: {\n      container: {\n        backgroundColor: disabled\n          ? theme.colors.neutral[200]\n          : theme.colors.secondary[500],\n        ...theme.shadows.sm,\n      },\n      text: {\n        color: disabled ? theme.colors.neutral[500] : theme.colors.neutral[50],\n      },\n    },\n    outline: {\n      container: {\n        backgroundColor: 'transparent',\n        borderWidth: 1,\n        borderColor: disabled\n          ? theme.colors.neutral[300]\n          : theme.colors.primary[500],\n      },\n      text: {\n        color: disabled ? theme.colors.neutral[400] : theme.colors.primary[500],\n      },\n    },\n    ghost: {\n      container: {\n        backgroundColor: 'transparent',\n      },\n      text: {\n        color: disabled ? theme.colors.neutral[400] : theme.colors.primary[500],\n      },\n    },\n    destructive: {\n      container: {\n        backgroundColor: disabled\n          ? theme.colors.neutral[300]\n          : theme.colors.error[500],\n        ...theme.shadows.sm,\n      },\n      text: {\n        color: disabled ? theme.colors.neutral[500] : theme.colors.neutral[50],\n      },\n    },\n  };\n\n  return {\n    container: {\n      ...baseContainer,\n      ...sizeStyles[size].container,\n      ...variantStyles[variant].container,\n    },\n    text: {\n      ...baseText,\n      ...sizeStyles[size].text,\n      ...variantStyles[variant].text,\n    },\n  };\n};\n\nexport const Button: React.FC<ButtonProps> = ({\n  variant = 'primary',\n  size = 'md',\n  loading = false,\n  disabled = false,\n  leftIcon,\n  rightIcon,\n  style,\n  textStyle,\n  children,\n  fullWidth = false,\n  accessibilityLabel,\n  accessibilityHint,\n  onPress,\n  ...props\n}) => {\n  const isDisabled = disabled || loading;\n  const styles = getButtonStyles(variant, size, isDisabled, fullWidth);\n\n  const handlePress = (event: any) => {\n    if (!isDisabled && onPress) {\n      onPress(event);\n    }\n  };\n\n  const getLoadingColor = (): string => {\n    if (variant === 'outline' || variant === 'ghost') {\n      return theme.colors.primary[500];\n    }\n    return theme.colors.neutral[50];\n  };\n\n  const iconSpacing = size === 'sm' ? theme.spacing[1] : theme.spacing[2];\n\n  return (\n    <TouchableOpacity\n      style={[styles.container, style]}\n      onPress={handlePress}\n      disabled={isDisabled}\n      accessibilityRole='button'\n      accessibilityLabel={accessibilityLabel}\n      accessibilityHint={accessibilityHint}\n      accessibilityState={{\n        disabled: isDisabled,\n        busy: loading,\n      }}\n      activeOpacity={0.7}\n      {...props}\n    >\n      {loading ? (\n        <ActivityIndicator\n          size={size === 'sm' ? 'small' : 'small'}\n          color={getLoadingColor()}\n        />\n      ) : (\n        <>\n          {leftIcon && (\n            <View style={{ marginRight: iconSpacing }}>{leftIcon}</View>\n          )}\n\n          <Text\n            style={[styles.text, textStyle]}\n            numberOfLines={1}\n            ellipsizeMode='tail'\n          >\n            {children}\n          </Text>\n\n          {rightIcon && (\n            <View style={{ marginLeft: iconSpacing }}>{rightIcon}</View>\n          )}\n        </>\n      )}\n    </TouchableOpacity>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/components/ui/Text.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":101,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3161,3164],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3161,3164],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3567,3570],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3567,3570],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":113,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3608,3611],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3608,3611],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport {\n  Text as RNText,\n  TextProps as RNTextProps,\n  TextStyle,\n} from 'react-native';\nimport { theme } from './theme';\n\nexport interface TextProps extends Omit<RNTextProps, 'style'> {\n  variant?:\n    | 'h1'\n    | 'h2'\n    | 'h3'\n    | 'h4'\n    | 'h5'\n    | 'h6'\n    | 'body1'\n    | 'body2'\n    | 'caption'\n    | 'overline';\n  color?: keyof typeof theme.colors | string;\n  size?: keyof typeof theme.typography.fontSize;\n  weight?: keyof typeof theme.typography.fontWeight;\n  align?: 'left' | 'center' | 'right' | 'justify';\n  style?: TextStyle | TextStyle[];\n  numberOfLines?: number;\n  ellipsizeMode?: 'head' | 'middle' | 'tail' | 'clip';\n}\n\nconst variantStyles: Record<NonNullable<TextProps['variant']>, TextStyle> = {\n  h1: {\n    fontSize: theme.typography.fontSize['4xl'],\n    lineHeight: theme.typography.lineHeight['4xl'],\n    fontWeight: theme.typography.fontWeight.bold,\n    color: theme.colors.neutral[900],\n  },\n  h2: {\n    fontSize: theme.typography.fontSize['3xl'],\n    lineHeight: theme.typography.lineHeight['3xl'],\n    fontWeight: theme.typography.fontWeight.bold,\n    color: theme.colors.neutral[900],\n  },\n  h3: {\n    fontSize: theme.typography.fontSize['2xl'],\n    lineHeight: theme.typography.lineHeight['2xl'],\n    fontWeight: theme.typography.fontWeight.semibold,\n    color: theme.colors.neutral[900],\n  },\n  h4: {\n    fontSize: theme.typography.fontSize.xl,\n    lineHeight: theme.typography.lineHeight.xl,\n    fontWeight: theme.typography.fontWeight.semibold,\n    color: theme.colors.neutral[900],\n  },\n  h5: {\n    fontSize: theme.typography.fontSize.lg,\n    lineHeight: theme.typography.lineHeight.lg,\n    fontWeight: theme.typography.fontWeight.medium,\n    color: theme.colors.neutral[900],\n  },\n  h6: {\n    fontSize: theme.typography.fontSize.base,\n    lineHeight: theme.typography.lineHeight.base,\n    fontWeight: theme.typography.fontWeight.medium,\n    color: theme.colors.neutral[900],\n  },\n  body1: {\n    fontSize: theme.typography.fontSize.base,\n    lineHeight: theme.typography.lineHeight.base,\n    fontWeight: theme.typography.fontWeight.normal,\n    color: theme.colors.neutral[800],\n  },\n  body2: {\n    fontSize: theme.typography.fontSize.sm,\n    lineHeight: theme.typography.lineHeight.sm,\n    fontWeight: theme.typography.fontWeight.normal,\n    color: theme.colors.neutral[700],\n  },\n  caption: {\n    fontSize: theme.typography.fontSize.xs,\n    lineHeight: theme.typography.lineHeight.xs,\n    fontWeight: theme.typography.fontWeight.normal,\n    color: theme.colors.neutral[600],\n  },\n  overline: {\n    fontSize: theme.typography.fontSize.xs,\n    lineHeight: theme.typography.lineHeight.xs,\n    fontWeight: theme.typography.fontWeight.medium,\n    color: theme.colors.neutral[600],\n    textTransform: 'uppercase',\n    letterSpacing: 0.5,\n  },\n};\n\nconst getColorValue = (color: string): string => {\n  // Check if it's a theme color path (e.g., 'primary.500')\n  if (color.includes('.')) {\n    const [colorName, shade] = color.split('.');\n    const colorGroup = theme.colors[colorName as keyof typeof theme.colors];\n    if (colorGroup && typeof colorGroup === 'object') {\n      return (colorGroup as any)[shade] || color;\n    }\n  }\n\n  // Check if it's a direct theme color reference\n  if (theme.colors[color as keyof typeof theme.colors]) {\n    const colorValue = theme.colors[color as keyof typeof theme.colors];\n    if (typeof colorValue === 'string') {\n      return colorValue;\n    }\n    // If it's a color object, return the default (500) shade\n    if (typeof colorValue === 'object' && (colorValue as any)[500]) {\n      return (colorValue as any)[500];\n    }\n  }\n\n  // Return as-is (could be a hex color, etc.)\n  return color;\n};\n\nexport const Text: React.FC<TextProps> = ({\n  variant = 'body1',\n  color,\n  size,\n  weight,\n  align,\n  style,\n  children,\n  accessibilityLabel,\n  accessibilityHint,\n  numberOfLines,\n  ellipsizeMode = 'tail',\n  ...props\n}) => {\n  const variantStyle = variantStyles[variant];\n\n  const textStyle: TextStyle = {\n    ...variantStyle,\n    ...(size && { fontSize: theme.typography.fontSize[size] }),\n    ...(weight && { fontWeight: theme.typography.fontWeight[weight] }),\n    ...(color && { color: getColorValue(color) }),\n    ...(align && { textAlign: align }),\n  };\n\n  const combinedStyle = [textStyle, style];\n\n  return (\n    <RNText\n      style={combinedStyle}\n      accessibilityLabel={\n        accessibilityLabel ||\n        (typeof children === 'string' ? children : undefined)\n      }\n      accessibilityHint={accessibilityHint}\n      accessibilityRole='text'\n      numberOfLines={numberOfLines}\n      ellipsizeMode={ellipsizeMode}\n      {...props}\n    >\n      {children}\n    </RNText>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/components/ui/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/components/ui/theme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/database/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/database/init.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":30,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":30,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[724,768],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":34,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":34,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[800,847],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":43,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":43,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1040,1089],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":45,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":45,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[1118,1174],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":58,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":58,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1446,1488],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":84,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":84,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2134,2241],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":102,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":102,"endColumn":25,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[2788,2845],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":106,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":106,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2877,2935],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":108,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":108,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2959,3004],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":111,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":111,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[3041,3083],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":218,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":218,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[6981,7025],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":231,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":231,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7301,7304],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7301,7304],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":237,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":237,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[7495,7554],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":252,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":252,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[7933,7987],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":281,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":281,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[8806,8860],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":299,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":299,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9384,9457],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":301,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":301,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[9486,9543],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import SQLite from 'react-native-sqlite-storage';\nimport { ErrorCode, AppError } from '../types';\n\n// Enable debugging in development\nif (__DEV__) {\n  SQLite.DEBUG(true);\n}\n\n// Enable promise-based API\nSQLite.enablePromise(true);\n\nexport class DatabaseManager {\n  private static instance: DatabaseManager;\n  private db: SQLite.SQLiteDatabase | null = null;\n  private readonly DB_NAME = 'mobdeck.db';\n  private readonly DB_VERSION = 1;\n\n  private constructor() {}\n\n  static getInstance(): DatabaseManager {\n    if (!DatabaseManager.instance) {\n      DatabaseManager.instance = new DatabaseManager();\n    }\n    return DatabaseManager.instance;\n  }\n\n  async initialize(): Promise<void> {\n    try {\n      if (this.db) {\n        console.log('Database already initialized');\n        return;\n      }\n\n      console.log('Initializing SQLite database...');\n\n      this.db = await SQLite.openDatabase({\n        name: this.DB_NAME,\n        location: 'default',\n        createFromLocation: undefined,\n      });\n\n      await this.runMigrations();\n      console.log('Database initialized successfully');\n    } catch (error) {\n      console.error('Database initialization failed:', error);\n      throw new AppError({\n        code: ErrorCode.DATABASE_ERROR,\n        message: 'Failed to initialize database',\n        details: error,\n      });\n    }\n  }\n\n  async close(): Promise<void> {\n    if (this.db) {\n      await this.db.close();\n      this.db = null;\n      console.log('Database connection closed');\n    }\n  }\n\n  getDatabase(): SQLite.SQLiteDatabase {\n    if (!this.db) {\n      throw new AppError({\n        code: ErrorCode.DATABASE_ERROR,\n        message: 'Database not initialized. Call initialize() first.',\n      });\n    }\n    return this.db;\n  }\n\n  private async runMigrations(): Promise<void> {\n    if (!this.db) return;\n\n    try {\n      // Check current schema version\n      const versionResult = await this.db.executeSql(\n        'SELECT version FROM schema_version ORDER BY version DESC LIMIT 1'\n      );\n\n      const currentVersion = versionResult[0]?.rows?.item(0)?.version || 0;\n\n      if (currentVersion < this.DB_VERSION) {\n        console.log(\n          `Running migrations from version ${currentVersion} to ${this.DB_VERSION}`\n        );\n\n        // Read and execute schema\n        const schemaSQL = await this.loadSchemaSQL();\n\n        // Split by semicolon and execute each statement\n        const statements = schemaSQL\n          .split(';')\n          .map(stmt => stmt.trim())\n          .filter(stmt => stmt.length > 0 && !stmt.startsWith('--'));\n\n        for (const statement of statements) {\n          try {\n            await this.db.executeSql(statement);\n          } catch (error) {\n            // Log but don't fail on expected errors (like table already exists)\n            console.warn('SQL statement warning:', statement, error);\n          }\n        }\n\n        console.log('Database migrations completed successfully');\n      } else {\n        console.log('Database schema is up to date');\n      }\n    } catch (error) {\n      console.error('Migration failed:', error);\n      throw new AppError({\n        code: ErrorCode.DATABASE_ERROR,\n        message: 'Database migration failed',\n        details: error,\n      });\n    }\n  }\n\n  private async loadSchemaSQL(): Promise<string> {\n    // In a real implementation, you would load this from the schema.sql file\n    // For React Native, we'll embed it directly or use a bundler plugin\n    return `\n      PRAGMA foreign_keys = ON;\n\n      CREATE TABLE IF NOT EXISTS articles (\n        id TEXT PRIMARY KEY NOT NULL,\n        title TEXT NOT NULL,\n        summary TEXT,\n        content TEXT,\n        url TEXT NOT NULL,\n        image_url TEXT,\n        read_time INTEGER,\n        is_archived INTEGER NOT NULL DEFAULT 0,\n        is_favorite INTEGER NOT NULL DEFAULT 0,\n        is_read INTEGER NOT NULL DEFAULT 0,\n        source_url TEXT,\n        created_at INTEGER NOT NULL,\n        updated_at INTEGER NOT NULL,\n        synced_at INTEGER,\n        is_modified INTEGER NOT NULL DEFAULT 0,\n        deleted_at INTEGER\n      );\n\n      CREATE TABLE IF NOT EXISTS labels (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        name TEXT NOT NULL UNIQUE,\n        color TEXT,\n        created_at INTEGER NOT NULL,\n        updated_at INTEGER NOT NULL,\n        synced_at INTEGER\n      );\n\n      CREATE TABLE IF NOT EXISTS article_labels (\n        article_id TEXT NOT NULL,\n        label_id INTEGER NOT NULL,\n        created_at INTEGER NOT NULL,\n        PRIMARY KEY (article_id, label_id),\n        FOREIGN KEY (article_id) REFERENCES articles(id) ON DELETE CASCADE,\n        FOREIGN KEY (label_id) REFERENCES labels(id) ON DELETE CASCADE\n      );\n\n      CREATE TABLE IF NOT EXISTS sync_metadata (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        entity_type TEXT NOT NULL,\n        entity_id TEXT NOT NULL,\n        operation TEXT NOT NULL,\n        local_timestamp INTEGER NOT NULL,\n        server_timestamp INTEGER,\n        sync_status TEXT NOT NULL DEFAULT 'pending',\n        conflict_resolution TEXT,\n        retry_count INTEGER DEFAULT 0,\n        error_message TEXT,\n        created_at INTEGER NOT NULL,\n        updated_at INTEGER NOT NULL\n      );\n\n      CREATE TABLE IF NOT EXISTS schema_version (\n        version INTEGER PRIMARY KEY,\n        applied_at INTEGER NOT NULL,\n        description TEXT\n      );\n\n      CREATE INDEX IF NOT EXISTS idx_articles_is_archived ON articles(is_archived);\n      CREATE INDEX IF NOT EXISTS idx_articles_is_favorite ON articles(is_favorite);\n      CREATE INDEX IF NOT EXISTS idx_articles_is_read ON articles(is_read);\n      CREATE INDEX IF NOT EXISTS idx_articles_created_at ON articles(created_at DESC);\n      CREATE INDEX IF NOT EXISTS idx_articles_updated_at ON articles(updated_at DESC);\n      CREATE INDEX IF NOT EXISTS idx_articles_is_modified ON articles(is_modified);\n      CREATE INDEX IF NOT EXISTS idx_articles_deleted_at ON articles(deleted_at);\n      CREATE INDEX IF NOT EXISTS idx_articles_synced_at ON articles(synced_at);\n      CREATE INDEX IF NOT EXISTS idx_sync_metadata_entity ON sync_metadata(entity_type, entity_id);\n      CREATE INDEX IF NOT EXISTS idx_sync_metadata_status ON sync_metadata(sync_status);\n      CREATE INDEX IF NOT EXISTS idx_sync_metadata_timestamp ON sync_metadata(local_timestamp DESC);\n\n      INSERT OR IGNORE INTO schema_version (version, applied_at, description) \n      VALUES (1, strftime('%s', 'now'), 'Initial database schema with articles, labels, and sync metadata');\n    `;\n  }\n\n  // Utility methods for common database operations\n  async transaction<T>(\n    operation: (tx: SQLite.Transaction) => Promise<T>\n  ): Promise<T> {\n    const db = this.getDatabase();\n\n    return new Promise((resolve, reject) => {\n      db.transaction(\n        async tx => {\n          try {\n            const result = await operation(tx);\n            resolve(result);\n          } catch (error) {\n            reject(error);\n          }\n        },\n        error => {\n          console.error('Transaction failed:', error);\n          reject(\n            new AppError({\n              code: ErrorCode.DATABASE_ERROR,\n              message: 'Database transaction failed',\n              details: error,\n            })\n          );\n        }\n      );\n    });\n  }\n\n  async executeSql(sql: string, params: any[] = []): Promise<SQLite.ResultSet> {\n    try {\n      const db = this.getDatabase();\n      const [result] = await db.executeSql(sql, params);\n      return result;\n    } catch (error) {\n      console.error('SQL execution failed:', sql, params, error);\n      throw new AppError({\n        code: ErrorCode.DATABASE_ERROR,\n        message: 'SQL execution failed',\n        details: { sql, params, error },\n      });\n    }\n  }\n\n  // Database health check\n  async healthCheck(): Promise<boolean> {\n    try {\n      const result = await this.executeSql('SELECT 1 as test');\n      return result.rows.length > 0;\n    } catch (error) {\n      console.error('Database health check failed:', error);\n      return false;\n    }\n  }\n\n  // Get database statistics\n  async getStats(): Promise<{\n    articlesCount: number;\n    labelsCount: number;\n    pendingSyncCount: number;\n    dbSize?: number;\n  }> {\n    try {\n      const [articlesResult, labelsResult, syncResult] = await Promise.all([\n        this.executeSql(\n          'SELECT COUNT(*) as count FROM articles WHERE deleted_at IS NULL'\n        ),\n        this.executeSql('SELECT COUNT(*) as count FROM labels'),\n        this.executeSql(\n          'SELECT COUNT(*) as count FROM sync_metadata WHERE sync_status = \"pending\"'\n        ),\n      ]);\n\n      return {\n        articlesCount: articlesResult.rows.item(0).count,\n        labelsCount: labelsResult.rows.item(0).count,\n        pendingSyncCount: syncResult.rows.item(0).count,\n      };\n    } catch (error) {\n      console.error('Failed to get database stats:', error);\n      throw new AppError({\n        code: ErrorCode.DATABASE_ERROR,\n        message: 'Failed to retrieve database statistics',\n        details: error,\n      });\n    }\n  }\n\n  // Clean up old sync metadata\n  async cleanupSyncMetadata(olderThanDays: number = 30): Promise<void> {\n    const cutoffTimestamp = Date.now() - olderThanDays * 24 * 60 * 60 * 1000;\n\n    try {\n      await this.executeSql(\n        'DELETE FROM sync_metadata WHERE sync_status = \"completed\" AND updated_at < ?',\n        [cutoffTimestamp]\n      );\n      console.log(`Cleaned up sync metadata older than ${olderThanDays} days`);\n    } catch (error) {\n      console.error('Failed to cleanup sync metadata:', error);\n      throw new AppError({\n        code: ErrorCode.DATABASE_ERROR,\n        message: 'Failed to cleanup old sync metadata',\n        details: error,\n      });\n    }\n  }\n}\n\n// Export singleton instance\nexport const databaseManager = DatabaseManager.getInstance();\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/database/types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":133,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3372,3375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3372,3375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3970,3973],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3970,3973],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":161,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":161,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3995,3998],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3995,3998],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Database Entity Types for SQLite Storage\n// These types map directly to the database schema\n\nexport interface DBArticle {\n  id: string;\n  title: string;\n  summary: string | null;\n  content: string | null;\n  url: string;\n  image_url: string | null;\n  read_time: number | null;\n  is_archived: number; // SQLite boolean (0/1)\n  is_favorite: number; // SQLite boolean (0/1)\n  is_read: number; // SQLite boolean (0/1)\n  source_url: string | null;\n  created_at: number; // Unix timestamp\n  updated_at: number; // Unix timestamp\n  synced_at: number | null; // Unix timestamp\n  is_modified: number; // SQLite boolean (0/1)\n  deleted_at: number | null; // Unix timestamp for soft delete\n}\n\nexport interface DBLabel {\n  id: number;\n  name: string;\n  color: string | null;\n  created_at: number; // Unix timestamp\n  updated_at: number; // Unix timestamp\n  synced_at: number | null; // Unix timestamp\n}\n\nexport interface DBArticleLabel {\n  article_id: string;\n  label_id: number;\n  created_at: number; // Unix timestamp\n}\n\nexport interface DBSyncMetadata {\n  id: number;\n  entity_type: 'article' | 'label' | 'article_label';\n  entity_id: string;\n  operation: 'create' | 'update' | 'delete';\n  local_timestamp: number;\n  server_timestamp: number | null;\n  sync_status: 'pending' | 'syncing' | 'completed' | 'failed';\n  conflict_resolution: 'local_wins' | 'server_wins' | 'merged' | null;\n  retry_count: number;\n  error_message: string | null;\n  created_at: number; // Unix timestamp\n  updated_at: number; // Unix timestamp\n}\n\nexport interface DBSchemaVersion {\n  version: number;\n  applied_at: number; // Unix timestamp\n  description: string | null;\n}\n\n// Query result types\nexport interface ArticleQueryResult {\n  rows: {\n    length: number;\n    item: (index: number) => DBArticle;\n  };\n}\n\nexport interface LabelQueryResult {\n  rows: {\n    length: number;\n    item: (index: number) => DBLabel;\n  };\n}\n\n// Database operation types\nexport interface InsertArticleParams {\n  id: string;\n  title: string;\n  summary?: string;\n  content?: string;\n  url: string;\n  image_url?: string;\n  read_time?: number;\n  is_archived?: boolean;\n  is_favorite?: boolean;\n  is_read?: boolean;\n  source_url?: string;\n  created_at?: number;\n  updated_at?: number;\n}\n\nexport interface UpdateArticleParams {\n  id: string;\n  title?: string;\n  summary?: string;\n  content?: string;\n  url?: string;\n  image_url?: string;\n  read_time?: number;\n  is_archived?: boolean;\n  is_favorite?: boolean;\n  is_read?: boolean;\n  source_url?: string;\n  updated_at?: number;\n}\n\nexport interface ArticleFilters {\n  is_archived?: boolean;\n  is_favorite?: boolean;\n  is_read?: boolean;\n  labels?: string[];\n  search?: string;\n  limit?: number;\n  offset?: number;\n  sort_by?: 'created_at' | 'updated_at' | 'title';\n  sort_order?: 'ASC' | 'DESC';\n}\n\n// Utility types for conversion between DB and App types\nexport interface ArticleConversionUtils {\n  dbToApp: (dbArticle: DBArticle) => import('../types').Article;\n  appToDb: (article: import('../types').Article) => DBArticle;\n  boolToInt: (value: boolean) => number;\n  intToBool: (value: number) => boolean;\n  timestampToDate: (timestamp: number) => string;\n  dateToTimestamp: (date: string) => number;\n}\n\n// Sync operation types\nexport interface SyncOperation {\n  entity_type: DBSyncMetadata['entity_type'];\n  entity_id: string;\n  operation: DBSyncMetadata['operation'];\n  data?: any;\n}\n\nexport interface BatchSyncParams {\n  operations: SyncOperation[];\n  conflict_resolution?: DBSyncMetadata['conflict_resolution'];\n}\n\n// Database statistics\nexport interface DatabaseStats {\n  articles_count: number;\n  labels_count: number;\n  pending_sync_count: number;\n  failed_sync_count: number;\n  last_sync_time: number | null;\n  db_size_mb?: number;\n}\n\n// Error types specific to database operations\nexport interface DatabaseError {\n  code:\n    | 'CONSTRAINT_VIOLATION'\n    | 'TABLE_NOT_FOUND'\n    | 'SYNTAX_ERROR'\n    | 'CONNECTION_ERROR';\n  message: string;\n  sql?: string;\n  params?: any[];\n  originalError?: any;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/database/validate.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":65,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":65,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1783,1890],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":149,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4025,4028],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4025,4028],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":162,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":162,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[4324,4391],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":172,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":172,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4634,4695],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":181,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":181,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[4926,4984],"text":""},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Database schema validation utilities\nimport { DatabaseManager, databaseManager } from './init';\nimport { DatabaseStats } from './types';\n\nexport class DatabaseValidator {\n  private db: DatabaseManager;\n\n  constructor() {\n    this.db = databaseManager;\n  }\n\n  async validateSchema(): Promise<{\n    isValid: boolean;\n    errors: string[];\n    tables: string[];\n  }> {\n    const errors: string[] = [];\n    const tables: string[] = [];\n\n    try {\n      // Check if database is initialized\n      const isHealthy = await this.db.healthCheck();\n      if (!isHealthy) {\n        errors.push('Database health check failed');\n        return { isValid: false, errors, tables };\n      }\n\n      // Validate table existence\n      const expectedTables = [\n        'articles',\n        'labels',\n        'article_labels',\n        'sync_metadata',\n        'schema_version',\n        'articles_fts',\n      ];\n\n      for (const tableName of expectedTables) {\n        try {\n          const result = await this.db.executeSql(\n            \"SELECT name FROM sqlite_master WHERE type='table' AND name=?\",\n            [tableName]\n          );\n\n          if (result.rows.length > 0) {\n            tables.push(tableName);\n          } else {\n            errors.push(`Table '${tableName}' not found`);\n          }\n        } catch (error) {\n          errors.push(`Error checking table '${tableName}': ${error}`);\n        }\n      }\n\n      // Validate schema version\n      try {\n        const versionResult = await this.db.executeSql(\n          'SELECT version, description FROM schema_version ORDER BY version DESC LIMIT 1'\n        );\n\n        if (versionResult.rows.length === 0) {\n          errors.push('No schema version found');\n        } else {\n          const version = versionResult.rows.item(0);\n          console.log(\n            `Current schema version: ${version.version} - ${version.description}`\n          );\n        }\n      } catch (error) {\n        errors.push(`Error checking schema version: ${error}`);\n      }\n\n      // Validate indexes\n      const expectedIndexes = [\n        'idx_articles_is_archived',\n        'idx_articles_is_favorite',\n        'idx_articles_is_read',\n        'idx_articles_created_at',\n        'idx_sync_metadata_status',\n      ];\n\n      for (const indexName of expectedIndexes) {\n        try {\n          const result = await this.db.executeSql(\n            \"SELECT name FROM sqlite_master WHERE type='index' AND name=?\",\n            [indexName]\n          );\n\n          if (result.rows.length === 0) {\n            errors.push(`Index '${indexName}' not found`);\n          }\n        } catch (error) {\n          errors.push(`Error checking index '${indexName}': ${error}`);\n        }\n      }\n\n      return {\n        isValid: errors.length === 0,\n        errors,\n        tables,\n      };\n    } catch (error) {\n      errors.push(`Schema validation failed: ${error}`);\n      return { isValid: false, errors, tables };\n    }\n  }\n\n  async validateConstraints(): Promise<{\n    isValid: boolean;\n    errors: string[];\n  }> {\n    const errors: string[] = [];\n\n    try {\n      // Test foreign key constraints\n      await this.db.executeSql('PRAGMA foreign_keys');\n\n      // Test article insertion constraints\n      try {\n        await this.db.executeSql(\n          'INSERT INTO articles (id, title, url, created_at, updated_at) VALUES (?, ?, ?, ?, ?)',\n          [\n            'test-id',\n            'Test Article',\n            'https://example.com',\n            Date.now(),\n            Date.now(),\n          ]\n        );\n\n        // Clean up test data\n        await this.db.executeSql('DELETE FROM articles WHERE id = ?', [\n          'test-id',\n        ]);\n      } catch (error) {\n        errors.push(`Article insertion constraint test failed: ${error}`);\n      }\n\n      return {\n        isValid: errors.length === 0,\n        errors,\n      };\n    } catch (error) {\n      errors.push(`Constraint validation failed: ${error}`);\n      return { isValid: false, errors };\n    }\n  }\n\n  async getTableInfo(tableName: string): Promise<any[]> {\n    try {\n      const result = await this.db.executeSql(\n        `PRAGMA table_info(${tableName})`\n      );\n      const columns = [];\n\n      for (let i = 0; i < result.rows.length; i++) {\n        columns.push(result.rows.item(i));\n      }\n\n      return columns;\n    } catch (error) {\n      console.error(`Error getting table info for ${tableName}:`, error);\n      return [];\n    }\n  }\n\n  async performFullValidation(): Promise<{\n    schema: { isValid: boolean; errors: string[]; tables: string[] };\n    constraints: { isValid: boolean; errors: string[] };\n    stats: DatabaseStats | null;\n  }> {\n    console.log('Starting comprehensive database validation...');\n\n    const schema = await this.validateSchema();\n    const constraints = await this.validateConstraints();\n\n    let stats: DatabaseStats | null = null;\n    try {\n      stats = await this.db.getStats();\n    } catch (error) {\n      console.warn('Could not retrieve database stats:', error);\n    }\n\n    return { schema, constraints, stats };\n  }\n}\n\nexport const validator = new DatabaseValidator();\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/domain/entities/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/domain/repositories/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/domain/usecases/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/examples/BackgroundSyncUsage.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":19,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[555,558],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[555,558],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":27,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":27,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[751,798],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":35,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":35,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[979,1035],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":37,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":37,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[1064,1126],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":55,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":55,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1491,1544],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":60,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":60,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1726,1790],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":83,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":83,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2520,2617],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":90,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":90,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2751,2801],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":94,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":94,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[2895,2954],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":155,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":155,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4326,4390],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":223,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":223,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6333,6336],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6333,6336],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":237,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":237,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6744,6747],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6744,6747],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":253,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":253,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7193,7196],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7193,7196],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":266,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":266,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7508,7511],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7508,7511],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":266,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":266,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7516,7519],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7516,7519],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":289,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":289,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8139,8238],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * BackgroundSyncUsage - Example implementation of background sync integration\n *\n * This file demonstrates how to integrate the BackgroundSyncService\n * into your React Native app lifecycle and components.\n */\n\nimport { AppState, AppStateStatus } from 'react-native';\nimport {\n  backgroundSyncService,\n  SYNC_INTERVALS,\n} from '../services/BackgroundSyncService';\n\n/**\n * Example: App.tsx integration\n * Add this to your main App component to initialize background sync\n */\nexport class BackgroundSyncAppIntegration {\n  private appStateSubscription: any = null;\n\n  /**\n   * Initialize background sync when app starts\n   * Call this in your App component's useEffect or componentDidMount\n   */\n  async initializeBackgroundSync() {\n    try {\n      console.log('Initializing background sync...');\n\n      // Initialize the background sync service\n      await backgroundSyncService.initialize();\n\n      // Set up app state monitoring\n      this.setupAppStateMonitoring();\n\n      console.log('Background sync initialized successfully');\n    } catch (error) {\n      console.error('Failed to initialize background sync:', error);\n    }\n  }\n\n  /**\n   * Set up app state monitoring to handle app lifecycle events\n   */\n  private setupAppStateMonitoring() {\n    this.appStateSubscription = AppState.addEventListener(\n      'change',\n      this.handleAppStateChange.bind(this)\n    );\n  }\n\n  /**\n   * Handle app state changes\n   */\n  private handleAppStateChange(nextAppState: AppStateStatus) {\n    console.log(`App state changed to: ${nextAppState}`);\n\n    if (nextAppState === 'background') {\n      // App is going to background - no specific action needed\n      // Background sync will continue based on configured intervals\n      console.log('App backgrounded - background sync will continue');\n    } else if (nextAppState === 'active') {\n      // App is coming to foreground - trigger an immediate sync if needed\n      this.handleAppForegrounded();\n    }\n  }\n\n  /**\n   * Handle app coming to foreground\n   */\n  private async handleAppForegrounded() {\n    try {\n      // Get sync status\n      const status = await backgroundSyncService.getStatus();\n\n      // Check if it's been a while since last sync\n      if (status.lastSyncTime) {\n        const lastSyncTime = new Date(status.lastSyncTime).getTime();\n        const now = Date.now();\n        const timeSinceLastSync = now - lastSyncTime;\n\n        // If more than 10 minutes since last sync, trigger manual sync\n        if (timeSinceLastSync > 10 * 60 * 1000) {\n          console.log(\n            'Triggering foreground sync - been a while since last sync'\n          );\n          await backgroundSyncService.triggerManualSync();\n        }\n      } else {\n        // No previous sync, trigger one\n        console.log('Triggering initial foreground sync');\n        await backgroundSyncService.triggerManualSync();\n      }\n    } catch (error) {\n      console.error('Failed to handle app foregrounded:', error);\n    }\n  }\n\n  /**\n   * Clean up when app is unmounted\n   * Call this in your App component's cleanup\n   */\n  cleanup() {\n    if (this.appStateSubscription) {\n      this.appStateSubscription.remove();\n    }\n\n    backgroundSyncService.cleanup();\n  }\n}\n\n/**\n * Example: Settings configuration helper\n */\nexport class BackgroundSyncConfigHelper {\n  /**\n   * Configure background sync with common presets\n   */\n  static async configurePreset(\n    preset: 'aggressive' | 'balanced' | 'conservative' | 'manual'\n  ) {\n    const configurations = {\n      aggressive: {\n        enabled: true,\n        interval: SYNC_INTERVALS.FIFTEEN_MINUTES,\n        wifiOnly: false,\n        allowCellular: true,\n        allowMetered: true,\n      },\n      balanced: {\n        enabled: true,\n        interval: SYNC_INTERVALS.THIRTY_MINUTES,\n        wifiOnly: false,\n        allowCellular: true,\n        allowMetered: false,\n      },\n      conservative: {\n        enabled: true,\n        interval: SYNC_INTERVALS.ONE_HOUR,\n        wifiOnly: true,\n        allowCellular: false,\n        allowMetered: false,\n      },\n      manual: {\n        enabled: false,\n        interval: SYNC_INTERVALS.MANUAL,\n        wifiOnly: false,\n        allowCellular: true,\n        allowMetered: true,\n      },\n    };\n\n    const config = configurations[preset];\n    await backgroundSyncService.updatePreferences(config);\n\n    console.log(`Background sync configured with ${preset} preset`);\n  }\n\n  /**\n   * Get readable sync configuration\n   */\n  static async getCurrentConfiguration() {\n    const status = await backgroundSyncService.getStatus();\n\n    return {\n      isEnabled: true, // Get from Redux store\n      intervalLabel: this.getIntervalLabel(15), // Get from Redux store\n      networkPreference: 'WiFi + Cellular', // Get from Redux store\n      lastSync: status.lastSyncTime,\n      nextSync: status.nextScheduledSync,\n      recentSyncs: status.syncHistory.slice(0, 5),\n    };\n  }\n\n  /**\n   * Get human-readable interval label\n   */\n  private static getIntervalLabel(intervalMinutes: number): string {\n    switch (intervalMinutes) {\n      case SYNC_INTERVALS.MANUAL:\n        return 'Manual Only';\n      case SYNC_INTERVALS.FIFTEEN_MINUTES:\n        return '15 Minutes';\n      case SYNC_INTERVALS.THIRTY_MINUTES:\n        return '30 Minutes';\n      case SYNC_INTERVALS.ONE_HOUR:\n        return '1 Hour';\n      case SYNC_INTERVALS.TWO_HOURS:\n        return '2 Hours';\n      default:\n        return `${intervalMinutes} Minutes`;\n    }\n  }\n}\n\n/**\n * Example: Monitoring and debugging helper\n */\nexport class BackgroundSyncMonitor {\n  /**\n   * Get comprehensive sync statistics\n   */\n  static async getSyncStatistics() {\n    const status = await backgroundSyncService.getStatus();\n\n    const stats = {\n      totalSyncs: status.syncHistory.length,\n      successfulSyncs: status.syncHistory.filter(s => s.success).length,\n      failedSyncs: status.syncHistory.filter(s => !s.success).length,\n      averageDuration: this.calculateAverageDuration(status.syncHistory),\n      averageItemsSynced: this.calculateAverageItems(status.syncHistory),\n      networkDistribution: this.calculateNetworkDistribution(\n        status.syncHistory\n      ),\n      lastWeekSyncs: this.getLastWeekSyncs(status.syncHistory),\n    };\n\n    return stats;\n  }\n\n  /**\n   * Calculate average sync duration\n   */\n  private static calculateAverageDuration(history: any[]): number {\n    const successfulSyncs = history.filter(s => s.success && s.duration);\n    if (successfulSyncs.length === 0) return 0;\n\n    const totalDuration = successfulSyncs.reduce(\n      (sum, sync) => sum + sync.duration,\n      0\n    );\n    return Math.round(totalDuration / successfulSyncs.length);\n  }\n\n  /**\n   * Calculate average items synced\n   */\n  private static calculateAverageItems(history: any[]): number {\n    const successfulSyncs = history.filter(\n      s => s.success && s.itemsSynced !== undefined\n    );\n    if (successfulSyncs.length === 0) return 0;\n\n    const totalItems = successfulSyncs.reduce(\n      (sum, sync) => sum + sync.itemsSynced,\n      0\n    );\n    return Math.round(totalItems / successfulSyncs.length);\n  }\n\n  /**\n   * Calculate network type distribution\n   */\n  private static calculateNetworkDistribution(history: any[]) {\n    const distribution = history.reduce((acc, sync) => {\n      const network = sync.networkType || 'unknown';\n      acc[network] = (acc[network] || 0) + 1;\n      return acc;\n    }, {});\n\n    return distribution;\n  }\n\n  /**\n   * Get syncs from the last week\n   */\n  private static getLastWeekSyncs(history: any[]): any[] {\n    const oneWeekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;\n\n    return history.filter(sync => {\n      const syncTime = new Date(sync.timestamp).getTime();\n      return syncTime >= oneWeekAgo;\n    });\n  }\n\n  /**\n   * Export sync data for debugging\n   */\n  static async exportSyncData() {\n    const status = await backgroundSyncService.getStatus();\n    const stats = await this.getSyncStatistics();\n\n    const exportData = {\n      timestamp: new Date().toISOString(),\n      currentStatus: status,\n      statistics: stats,\n      configuration: await BackgroundSyncConfigHelper.getCurrentConfiguration(),\n    };\n\n    console.log(\n      'Background Sync Export Data:',\n      JSON.stringify(exportData, null, 2)\n    );\n    return exportData;\n  }\n}\n\n/**\n * Example usage in App.tsx:\n *\n * import { BackgroundSyncAppIntegration } from './src/examples/BackgroundSyncUsage';\n *\n * function App() {\n *   const syncIntegration = useRef(new BackgroundSyncAppIntegration());\n *\n *   useEffect(() => {\n *     syncIntegration.current.initializeBackgroundSync();\n *\n *     return () => {\n *       syncIntegration.current.cleanup();\n *     };\n *   }, []);\n *\n *   // ... rest of your app\n * }\n */\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/hooks/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/hooks/useAppInitialization.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":33,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":33,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1007,1063],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":36,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":36,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1110,1160],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":39,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":39,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1231,1290],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":41,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":41,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[1329,1567],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":51,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":51,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1723,1777],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":53,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":53,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1844,1907],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":61,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":61,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2036,2103],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":63,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":63,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[2136,2197],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":80,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":80,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2638,2728],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":84,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":84,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2860,2906],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useState } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { AppDispatch } from '../store';\nimport DatabaseService from '../services/DatabaseService';\nimport { initializeSyncService, startSyncOperation } from '../store/thunks/syncThunks';\nimport { useNetworkStatus } from './useNetworkStatus';\n\ninterface InitializationState {\n  isInitialized: boolean;\n  isInitializing: boolean;\n  error: string | null;\n}\n\nexport const useAppInitialization = () => {\n  const dispatch = useDispatch<AppDispatch>();\n  const networkStatus = useNetworkStatus();\n  const [state, setState] = useState<InitializationState>({\n    isInitialized: false,\n    isInitializing: false,\n    error: null,\n  });\n  const [wasOffline, setWasOffline] = useState(false);\n\n  useEffect(() => {\n    const initializeApp = async () => {\n      if (state.isInitialized || state.isInitializing) {\n        return;\n      }\n\n      setState(prev => ({ ...prev, isInitializing: true, error: null }));\n\n      try {\n        console.log('[AppInit] Starting app initialization...');\n\n        // Initialize database first\n        console.log('[AppInit] Initializing database...');\n        try {\n          await DatabaseService.initialize();\n          console.log('[AppInit] Database initialized successfully');\n        } catch (dbError) {\n          console.error('[AppInit] Database initialization failed:', {\n            message: dbError?.message || 'Unknown database error',\n            code: dbError?.code,\n            stack: dbError?.stack,\n            details: dbError\n          });\n          throw new Error(`Database initialization failed: ${dbError?.message || 'Unknown error'}`);\n        }\n\n        // Initialize sync service\n        console.log('[AppInit] Initializing sync service...');\n        await dispatch(initializeSyncService()).unwrap();\n        console.log('[AppInit] Sync service initialized successfully');\n\n        setState({\n          isInitialized: true,\n          isInitializing: false,\n          error: null,\n        });\n\n        console.log('[AppInit] App initialization completed successfully');\n      } catch (error) {\n        console.error('[AppInit] App initialization failed:', error);\n        setState({\n          isInitialized: false,\n          isInitializing: false,\n          error: error?.message || 'Failed to initialize app',\n        });\n      }\n    };\n\n    initializeApp();\n  }, [dispatch, state.isInitialized, state.isInitializing]);\n\n  // Monitor network status and trigger sync when coming back online\n  useEffect(() => {\n    if (!state.isInitialized) return;\n\n    if (networkStatus.isOnline && wasOffline) {\n      console.log('[AppInit] Network came back online, triggering sync for pending operations');\n      dispatch(startSyncOperation({}));\n      setWasOffline(false);\n    } else if (!networkStatus.isOnline && !wasOffline) {\n      console.log('[AppInit] Network went offline');\n      setWasOffline(true);\n    }\n  }, [networkStatus.isOnline, wasOffline, state.isInitialized, dispatch]);\n\n  return state;\n};","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/hooks/useAppTheme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/hooks/useBackgroundSync.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1004,1007],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1004,1007],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":58,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":58,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[1928,1994],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'handleAppStateChange'. Either include it or remove the dependency array.","line":73,"column":6,"nodeType":"ArrayExpression","endLine":73,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [handleAppStateChange]","fix":{"range":[2243,2245],"text":"[handleAppStateChange]"}}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of arrow function.","line":76,"column":16,"nodeType":"ArrowFunctionExpression","messageId":"missingReturn","endLine":76,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":89,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":89,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2655,2756],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":116,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":116,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[3418,3484],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":132,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":132,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[3863,3966],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":152,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":152,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[4355,4458],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":182,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":182,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[5019,5129],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":200,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":200,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[5403,5502],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":216,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":216,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[5757,5829],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useBackgroundSync - React Hook for Background Sync Management\n *\n * Provides an interface to manage background sync preferences and status\n * from React components, integrating with BackgroundSyncService and Redux store.\n */\n\nimport { useEffect, useState, useCallback } from 'react';\nimport { AppState, AppStateStatus } from 'react-native';\nimport { useAppSelector, useAppDispatch, store } from '../store';\nimport {\n  backgroundSyncService,\n} from '../services/BackgroundSyncService';\nimport { updateSyncConfig } from '../store/slices/syncSlice';\n\ninterface BackgroundSyncHookReturn {\n  // State\n  isEnabled: boolean;\n  syncInterval: number;\n  isWifiOnly: boolean;\n  isSyncing: boolean;\n  lastSyncTime: string | null;\n  nextSyncTime: string | null;\n\n  // Actions\n  setEnabled: (enabled: boolean) => Promise<void>;\n  setSyncInterval: (interval: number) => Promise<void>;\n  setWifiOnly: (wifiOnly: boolean) => Promise<void>;\n  triggerManualSync: () => Promise<void>;\n  getSyncHistory: () => Promise<any[]>;\n}\n\n/**\n * Hook to manage background sync functionality\n */\nexport function useBackgroundSync(): BackgroundSyncHookReturn {\n  const dispatch = useAppDispatch();\n\n  // Get sync state from Redux\n  const syncConfig = useAppSelector(state => state.sync.config);\n  const syncStatus = useAppSelector(state => state.sync.status);\n  const lastSyncRedux = useAppSelector(state => state.sync.lastSyncTime);\n\n  // Local state for sync timing\n  const [lastSyncTime, setLastSyncTime] = useState<string | null>(null);\n  const [nextSyncTime, setNextSyncTime] = useState<string | null>(null);\n  const [appState, setAppState] = useState<AppStateStatus>(\n    AppState.currentState\n  );\n\n  // Initialize background sync service on mount\n  useEffect(() => {\n    const initializeBackgroundSync = async () => {\n      try {\n        await backgroundSyncService.initialize();\n        await updateSyncStatus();\n      } catch (error) {\n        console.error('[useBackgroundSync] Failed to initialize:', error);\n      }\n    };\n\n    initializeBackgroundSync();\n\n    // Listen for app state changes\n    const subscription = AppState.addEventListener(\n      'change',\n      handleAppStateChange\n    );\n\n    return () => {\n      subscription.remove();\n    };\n  }, []);\n\n  // Update sync status periodically when app is active\n  useEffect(() => {\n    if (appState === 'active') {\n      updateSyncStatus();\n\n      const interval = setInterval(updateSyncStatus, 30000); // Update every 30 seconds\n      return () => clearInterval(interval);\n    }\n  }, [appState]);\n\n  /**\n   * Handle app state changes\n   */\n  const handleAppStateChange = (nextAppState: AppStateStatus) => {\n    console.log(\n      `[useBackgroundSync] App state changed from ${appState} to ${nextAppState}`\n    );\n\n    if (appState.match(/inactive|background/) && nextAppState === 'active') {\n      // App has come to foreground, update sync status\n      updateSyncStatus();\n    }\n\n    setAppState(nextAppState);\n  };\n\n  /**\n   * Update sync status from background service\n   */\n  const updateSyncStatus = async () => {\n    try {\n      // Only update sync status if user is authenticated\n      const state = store.getState();\n      if (!state.auth.isAuthenticated) {\n        return;\n      }\n\n      const status = await backgroundSyncService.getStatus();\n      setLastSyncTime(status.lastSyncTime);\n      setNextSyncTime(status.nextScheduledSync);\n    } catch (error) {\n      console.error('[useBackgroundSync] Failed to get status:', error);\n    }\n  };\n\n  /**\n   * Enable/disable background sync\n   */\n  const setEnabled = useCallback(\n    async (enabled: boolean) => {\n      try {\n        await backgroundSyncService.updatePreferences({ enabled });\n        dispatch(\n          updateSyncConfig({ config: { backgroundSyncEnabled: enabled } })\n        );\n        await updateSyncStatus();\n      } catch (error) {\n        console.error(\n          '[useBackgroundSync] Failed to set enabled state:',\n          error\n        );\n        throw error;\n      }\n    },\n    [dispatch]\n  );\n\n  /**\n   * Set sync interval\n   */\n  const setSyncInterval = useCallback(\n    async (interval: number) => {\n      try {\n        await backgroundSyncService.updatePreferences({ interval });\n        dispatch(updateSyncConfig({ config: { syncInterval: interval } }));\n        await updateSyncStatus();\n      } catch (error) {\n        console.error(\n          '[useBackgroundSync] Failed to set sync interval:',\n          error\n        );\n        throw error;\n      }\n    },\n    [dispatch]\n  );\n\n  /**\n   * Set WiFi-only preference\n   */\n  const setWifiOnly = useCallback(\n    async (wifiOnly: boolean) => {\n      try {\n        await backgroundSyncService.updatePreferences({\n          wifiOnly,\n          allowCellular: !wifiOnly,\n        });\n        dispatch(\n          updateSyncConfig({\n            config: {\n              syncOnWifiOnly: wifiOnly,\n              syncOnCellular: !wifiOnly,\n            },\n          })\n        );\n        await updateSyncStatus();\n      } catch (error) {\n        console.error(\n          '[useBackgroundSync] Failed to set WiFi-only preference:',\n          error\n        );\n        throw error;\n      }\n    },\n    [dispatch]\n  );\n\n  /**\n   * Trigger manual sync\n   */\n  const triggerManualSync = useCallback(async () => {\n    try {\n      await backgroundSyncService.triggerManualSync();\n      await updateSyncStatus();\n    } catch (error) {\n      console.error(\n        '[useBackgroundSync] Failed to trigger manual sync:',\n        error\n      );\n      throw error;\n    }\n  }, []);\n\n  /**\n   * Get sync history\n   */\n  const getSyncHistory = useCallback(async () => {\n    try {\n      const status = await backgroundSyncService.getStatus();\n      return status.syncHistory;\n    } catch (error) {\n      console.error('[useBackgroundSync] Failed to get sync history:', error);\n      return [];\n    }\n  }, []);\n\n  return {\n    // State\n    isEnabled: syncConfig.backgroundSyncEnabled,\n    syncInterval: syncConfig.syncInterval,\n    isWifiOnly: syncConfig.syncOnWifiOnly,\n    isSyncing: syncStatus === 'syncing',\n    lastSyncTime: lastSyncTime || lastSyncRedux,\n    nextSyncTime,\n\n    // Actions\n    setEnabled,\n    setSyncInterval,\n    setWifiOnly,\n    triggerManualSync,\n    getSyncHistory,\n  };\n}\n\n// Export sync interval constants for use in UI\nexport { SYNC_INTERVALS } from '../services/BackgroundSyncService';\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/hooks/useNetworkStatus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/hooks/useShareIntent.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":20,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":20,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[713,774],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":25,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":25,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[839,910],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":29,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":29,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[999,1059],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":32,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":32,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1112,1164],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":37,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":37,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[1298,1375],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":41,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":41,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1458,1516],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useState, useCallback } from 'react';\nimport { AppState, AppStateStatus } from 'react-native';\nimport { ShareService } from '../services/ShareService';\nimport { SharedData } from '../types';\n\ninterface UseShareIntentResult {\n  sharedData: SharedData | null;\n  isProcessing: boolean;\n  error: string | null;\n  clearSharedData: () => void;\n  processSharedData: () => Promise<void>;\n}\n\nexport const useShareIntent = (): UseShareIntentResult => {\n  const [sharedData, setSharedData] = useState<SharedData | null>(null);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const processSharedData = useCallback(async () => {\n    console.log('useShareIntent: Starting processSharedData...');\n    setIsProcessing(true);\n    setError(null);\n\n    try {\n      console.log('useShareIntent: Calling ShareService.getSharedData()...');\n      const data = await ShareService.getSharedData();\n      \n      if (data) {\n        console.log('useShareIntent: Share intent detected:', data);\n        setSharedData(data);\n      } else {\n        console.log('useShareIntent: No shared data found');\n      }\n    } catch (e) {\n      const errorMessage =\n        e instanceof Error ? e.message : 'Failed to process shared data';\n      console.error('useShareIntent: Error processing shared data:', errorMessage);\n      setError(errorMessage);\n    } finally {\n      setIsProcessing(false);\n      console.log('useShareIntent: Finished processSharedData');\n    }\n  }, []);\n\n  const clearSharedData = useCallback(async () => {\n    setSharedData(null);\n    setError(null);\n    await ShareService.clearSharedData();\n  }, []);\n\n  // Check for shared data when app becomes active\n  useEffect(() => {\n    const handleAppStateChange = (nextAppState: AppStateStatus) => {\n      if (nextAppState === 'active') {\n        processSharedData();\n      }\n    };\n\n    // Check immediately when hook is mounted\n    processSharedData();\n\n    // Listen for app state changes\n    const subscription = AppState.addEventListener(\n      'change',\n      handleAppStateChange\n    );\n\n    return () => subscription?.remove();\n  }, [processSharedData]);\n\n  return {\n    sharedData,\n    isProcessing,\n    error,\n    clearSharedData,\n    processSharedData,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/navigation/AppNavigator.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'RootState' is defined but never used.","line":16,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":32},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":35,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":35,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1505,1564],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":44,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":44,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1739,1950],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":51,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":51,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1999,2066],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":53,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":53,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2133,2182],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":56,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":56,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2209,2273],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":66,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":66,"endColumn":28,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2607,2657],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":76,"column":19,"nodeType":"MemberExpression","messageId":"unexpected","endLine":76,"endColumn":30,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2963,3029],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":79,"column":21,"nodeType":"MemberExpression","messageId":"unexpected","endLine":79,"endColumn":32,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3106,3189],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'image_url' is not in camel case.","line":95,"column":23,"nodeType":"Identifier","messageId":"notCamelCase","endLine":95,"endColumn":32},{"ruleId":"camelcase","severity":2,"message":"Identifier 'read_time' is not in camel case.","line":96,"column":23,"nodeType":"Identifier","messageId":"notCamelCase","endLine":96,"endColumn":32},{"ruleId":"camelcase","severity":2,"message":"Identifier 'source_url' is not in camel case.","line":97,"column":23,"nodeType":"Identifier","messageId":"notCamelCase","endLine":97,"endColumn":33},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_archived' is not in camel case.","line":98,"column":23,"nodeType":"Identifier","messageId":"notCamelCase","endLine":98,"endColumn":34},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_favorite' is not in camel case.","line":99,"column":23,"nodeType":"Identifier","messageId":"notCamelCase","endLine":99,"endColumn":34},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_read' is not in camel case.","line":100,"column":23,"nodeType":"Identifier","messageId":"notCamelCase","endLine":100,"endColumn":30},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_modified' is not in camel case.","line":101,"column":23,"nodeType":"Identifier","messageId":"notCamelCase","endLine":101,"endColumn":34},{"ruleId":"camelcase","severity":2,"message":"Identifier 'synced_at' is not in camel case.","line":102,"column":23,"nodeType":"Identifier","messageId":"notCamelCase","endLine":102,"endColumn":32},{"ruleId":"camelcase","severity":2,"message":"Identifier 'deleted_at' is not in camel case.","line":103,"column":23,"nodeType":"Identifier","messageId":"notCamelCase","endLine":103,"endColumn":33},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":107,"column":23,"nodeType":"MemberExpression","messageId":"unexpected","endLine":107,"endColumn":34,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4578,4639],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'entity_type' is not in camel case.","line":111,"column":25,"nodeType":"Identifier","messageId":"notCamelCase","endLine":111,"endColumn":36},{"ruleId":"camelcase","severity":2,"message":"Identifier 'entity_id' is not in camel case.","line":112,"column":25,"nodeType":"Identifier","messageId":"notCamelCase","endLine":112,"endColumn":34},{"ruleId":"camelcase","severity":2,"message":"Identifier 'local_timestamp' is not in camel case.","line":114,"column":25,"nodeType":"Identifier","messageId":"notCamelCase","endLine":114,"endColumn":40},{"ruleId":"camelcase","severity":2,"message":"Identifier 'server_timestamp' is not in camel case.","line":115,"column":25,"nodeType":"Identifier","messageId":"notCamelCase","endLine":115,"endColumn":41},{"ruleId":"camelcase","severity":2,"message":"Identifier 'sync_status' is not in camel case.","line":116,"column":25,"nodeType":"Identifier","messageId":"notCamelCase","endLine":116,"endColumn":36},{"ruleId":"camelcase","severity":2,"message":"Identifier 'conflict_resolution' is not in camel case.","line":117,"column":25,"nodeType":"Identifier","messageId":"notCamelCase","endLine":117,"endColumn":44},{"ruleId":"camelcase","severity":2,"message":"Identifier 'retry_count' is not in camel case.","line":118,"column":25,"nodeType":"Identifier","messageId":"notCamelCase","endLine":118,"endColumn":36},{"ruleId":"camelcase","severity":2,"message":"Identifier 'error_message' is not in camel case.","line":119,"column":25,"nodeType":"Identifier","messageId":"notCamelCase","endLine":119,"endColumn":38},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":123,"column":23,"nodeType":"MemberExpression","messageId":"unexpected","endLine":123,"endColumn":34,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5408,5482],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":128,"column":25,"nodeType":"MemberExpression","messageId":"unexpected","endLine":128,"endColumn":36,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5756,5843],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":138,"column":29,"nodeType":"MemberExpression","messageId":"unexpected","endLine":138,"endColumn":40,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6401,6475],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":142,"column":27,"nodeType":"MemberExpression","messageId":"unexpected","endLine":142,"endColumn":38,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6662,6740],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":152,"column":23,"nodeType":"MemberExpression","messageId":"unexpected","endLine":152,"endColumn":34,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7251,7355],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":154,"column":23,"nodeType":"MemberExpression","messageId":"unexpected","endLine":154,"endColumn":36,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[7407,7490],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":159,"column":19,"nodeType":"MemberExpression","messageId":"unexpected","endLine":159,"endColumn":32,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[7674,7747],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":169,"column":19,"nodeType":"MemberExpression","messageId":"unexpected","endLine":169,"endColumn":30,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8169,8219],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":178,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":178,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8415,8488],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'networkConnected'. Either include it or remove the dependency array.","line":183,"column":6,"nodeType":"ArrayExpression","endLine":183,"endColumn":62,"suggestions":[{"desc":"Update the dependencies array to be: [isAuthenticated, sharedData, clearSharedData, dispatch, networkConnected]","fix":{"range":[8571,8627],"text":"[isAuthenticated, sharedData, clearSharedData, dispatch, networkConnected]"}}]}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\nimport { NavigationContainer } from '@react-navigation/native';\nimport { useDispatch, useSelector } from 'react-redux';\nimport {\n  selectIsUserAuthenticated,\n  selectAuthLoading,\n} from '../store/selectors/authSelectors';\nimport { initializeAuth } from '../store/slices/authSlice';\nimport AuthNavigator from './AuthNavigator';\nimport MainNavigator from './MainNavigator';\nimport { View, ActivityIndicator, StyleSheet, Alert } from 'react-native';\nimport { theme } from '../components/ui/theme';\nimport { useShareIntent } from '../hooks/useShareIntent';\nimport { ShareService } from '../services/ShareService';\nimport { fetchArticles, loadLocalArticles } from '../store/slices/articlesSlice';\nimport { AppDispatch, RootState } from '../store';\nimport DatabaseService from '../services/DatabaseService';\nimport NetInfo from '@react-native-community/netinfo';\nimport { ConnectivityIndicator } from '../components/ConnectivityIndicator';\n\nconst AppNavigator: React.FC = () => {\n  const dispatch = useDispatch<AppDispatch>();\n  const isAuthenticated = useSelector(selectIsUserAuthenticated);\n  const authLoading = useSelector(selectAuthLoading);\n  const { sharedData, clearSharedData } = useShareIntent();\n  const [networkConnected, setNetworkConnected] = useState(true);\n\n  useEffect(() => {\n    dispatch(initializeAuth());\n  }, [dispatch]);\n\n  // Monitor network status\n  useEffect(() => {\n    const unsubscribe = NetInfo.addEventListener(state => {\n      console.log('AppNavigator: Network state changed:', state);\n      setNetworkConnected(state.isConnected ?? false);\n    });\n\n    return unsubscribe;\n  }, []);\n\n  // Handle shared data when user is authenticated\n  useEffect(() => {\n    console.log('AppNavigator: Share effect triggered', {\n      isAuthenticated,\n      hasSharedData: !!sharedData,\n      sharedDataText: `${sharedData?.text?.substring(0, 100)  }...` // Show first 100 chars\n    });\n\n    if (isAuthenticated && sharedData) {\n      console.log('AppNavigator: Processing shared data...', sharedData);\n      const url = ShareService.extractUrl(sharedData.text);\n      console.log('AppNavigator: Extracted URL:', url);\n\n      if (url) {\n        console.log('AppNavigator: Showing share dialog for URL:', url);\n        // Add small delay to ensure dialog shows after app is fully loaded\n        setTimeout(() => {\n          Alert.alert(\n            'Share Detected',\n            `Would you like to add this URL to your articles?\\n\\n${url}`,\n          [\n            {\n              text: 'Cancel',\n              onPress: () => {\n                console.log('AppNavigator: User cancelled share');\n                clearSharedData();\n              },\n              style: 'cancel',\n            },\n            {\n              text: 'Add Article',\n              onPress: async () => {\n                try {\n                  const articleData = ShareService.formatForArticle(sharedData);\n                  console.log('AppNavigator: Formatted article data:', articleData);\n                  \n                  if (articleData) {\n                    console.log('AppNavigator: Saving article locally first (offline-first approach)');\n                    \n                    // Always save locally first\n                    const db = DatabaseService;\n                    await db.initialize();\n                    \n                    // Generate a local ID for the article\n                    const localId = `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n                    \n                    // Create article in local database with correct SQLite field names and types\n                    const createResult = await db.createArticle({\n                      id: localId,\n                      title: articleData.title || 'Shared Article',\n                      url: articleData.url,\n                      summary: '',\n                      content: '',\n                      image_url: '',\n                      read_time: 0,\n                      source_url: articleData.url,\n                      is_archived: 0, // SQLite boolean as integer\n                      is_favorite: 0, // SQLite boolean as integer\n                      is_read: 0, // SQLite boolean as integer\n                      is_modified: 1, // Mark as modified for sync (SQLite boolean as integer)\n                      synced_at: null, // Not synced yet\n                      deleted_at: null, // Not deleted\n                    });\n                    \n                    if (createResult.success) {\n                      console.log('AppNavigator: Article saved locally:', localId);\n                      \n                      // Add to sync queue for background sync\n                      await db.createSyncMetadata({\n                        entity_type: 'article',\n                        entity_id: localId,\n                        operation: 'create',\n                        local_timestamp: Date.now(),\n                        server_timestamp: null,\n                        sync_status: 'pending',\n                        conflict_resolution: null,\n                        retry_count: 0,\n                        error_message: JSON.stringify({ url: articleData.url, title: articleData.title }),\n                      });\n                      \n                      // Refresh the articles list to show the new article\n                      console.log('AppNavigator: Refreshing articles list to show new article');\n                      if (networkConnected) {\n                        dispatch(fetchArticles({ page: 1, forceRefresh: true }));\n                        \n                        // If online, try to create the article on the server and fetch content\n                        console.log('AppNavigator: Attempting to sync article to server and fetch content...');\n                        try {\n                          const { articlesApiService } = await import('../services/ArticlesApiService');\n                          const serverArticle = await articlesApiService.createArticle({\n                            title: articleData.title || 'Shared Article',\n                            url: articleData.url,\n                          });\n                          \n                          // Update local article with server ID and content\n                          if (serverArticle) {\n                            console.log('AppNavigator: Article created on server:', serverArticle.id);\n                            // Note: Content fetching will be handled by sync service\n                          }\n                        } catch (syncError) {\n                          console.log('AppNavigator: Server sync failed, will retry later:', syncError);\n                          // This is okay - sync service will handle it later\n                        }\n                      } else {\n                        dispatch(loadLocalArticles({ page: 1, forceRefresh: true }));\n                      }\n                      \n                      Alert.alert('Success', 'Article saved! Content will be downloaded when online.');\n                      \n                      // Note: Sync will happen automatically in background via sync service\n                      console.log('AppNavigator: Article saved locally, background sync will handle server sync when online');\n                    } else {\n                      console.error('AppNavigator: Failed to save article locally:', createResult.error);\n                      Alert.alert('Error', 'Failed to save article. Please try again.');\n                    }\n                  }\n                } catch (error) {\n                  console.error('AppNavigator: Error creating article from share:', error);\n                  \n                  // Fallback to offline queue\n                  const queueId = await ShareService.queueSharedUrl(sharedData);\n                  if (queueId) {\n                    Alert.alert('Success', 'Article saved!');\n                  } else {\n                    Alert.alert('Error', 'Failed to add article. Please try again.');\n                  }\n                } finally {\n                  console.log('AppNavigator: Clearing shared data');\n                  clearSharedData();\n                }\n              },\n            },\n          ]\n        );\n        }, 500); // 500ms delay to ensure app is fully loaded\n      } else {\n        console.log('AppNavigator: No valid URL found in shared data, clearing');\n        // Clear invalid share data\n        clearSharedData();\n      }\n    }\n  }, [isAuthenticated, sharedData, clearSharedData, dispatch]);\n\n  if (authLoading) {\n    return (\n      <View style={styles.loadingContainer}>\n        <ActivityIndicator size='large' color={theme.colors.primary[500]} />\n      </View>\n    );\n  }\n\n  return (\n    <>\n      <ConnectivityIndicator />\n      <NavigationContainer>\n        {isAuthenticated ? <MainNavigator /> : <AuthNavigator />}\n      </NavigationContainer>\n    </>\n  );\n};\n\nconst styles = StyleSheet.create({\n  loadingContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: theme.colors.neutral[50],\n  },\n});\n\nexport default AppNavigator;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/navigation/AuthNavigator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/navigation/MainNavigator.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CustomHeader' is assigned a value but never used.","line":14,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { createStackNavigator } from '@react-navigation/stack';\nimport { View, StyleSheet } from 'react-native';\nimport { ArticlesListScreen } from '../screens/main/ArticlesListScreen';\nimport { ArticleDetailScreen } from '../screens/main/ArticleDetailScreen';\nimport { SettingsScreen } from '../screens/main/SettingsScreen';\nimport { MainStackParamList } from './types';\nimport { theme } from '../components/ui/theme';\nimport { Text } from '../components/ui/Text';\nimport MobdeckLogo from '../components/MobdeckLogo';\n\nconst Stack = createStackNavigator<MainStackParamList>();\n\nconst CustomHeader: React.FC = () => {\n  return (\n    <View style={styles.headerContainer}>\n      <MobdeckLogo size={28} color={theme.colors.neutral[50]} />\n      <Text style={styles.headerTitle}>Mobdeck</Text>\n    </View>\n  );\n};\n\nconst MainNavigator: React.FC = () => {\n  return (\n    <Stack.Navigator\n      screenOptions={{\n        headerStyle: {\n          backgroundColor: theme.colors.primary[500],\n        },\n        headerTintColor: theme.colors.neutral[50],\n        headerTitleStyle: {\n          fontWeight: 'bold',\n          color: theme.colors.neutral[50],\n        },\n      }}\n    >\n      <Stack.Screen\n        name='ArticlesList'\n        component={ArticlesListScreen}\n        options={{\n          headerShown: false,\n        }}\n      />\n      <Stack.Screen\n        name='ArticleDetail'\n        component={ArticleDetailScreen}\n        options={({ route }) => ({\n          title: route.params?.title || 'Article',\n        })}\n      />\n      <Stack.Screen\n        name='Settings'\n        component={SettingsScreen}\n        options={{\n          title: 'Settings',\n        }}\n      />\n    </Stack.Navigator>\n  );\n};\n\nconst styles = StyleSheet.create({\n  headerContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingHorizontal: theme.spacing[2],\n  },\n  headerTitle: {\n    fontSize: theme.typography.fontSize.lg,\n    fontWeight: theme.typography.fontWeight.bold,\n    color: theme.colors.neutral[50],\n    marginLeft: theme.spacing[2],\n  },\n});\n\nexport default MainNavigator;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/navigation/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/navigation/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/screens/ArticleScreen.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":22,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":22,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[761,809],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\nimport { View, Image, StyleSheet, ActivityIndicator } from 'react-native';\nimport { Text } from '../components/ui/Text';\nimport { fetchArticleById } from '../services/api';\nimport { MainScreenProps } from '../navigation/types';\nimport { colors } from '../components/ui/theme';\n\nconst ArticleScreen: React.FC<MainScreenProps<'ArticleDetail'>> = ({\n  navigation: _navigation,\n  route,\n}) => {\n  const { articleId } = route.params;\n  const [article, setArticle] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const getArticle = async () => {\n      try {\n        const data = await fetchArticleById(articleId);\n        setArticle(data);\n      } catch (error) {\n        console.error('Error fetching article:', error);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    getArticle();\n  }, [articleId]);\n\n  if (loading) {\n    return (\n      <View style={styles.loadingContainer}>\n        <ActivityIndicator size='large' color={colors.primary[500]} />\n      </View>\n    );\n  }\n\n  if (!article) {\n    return (\n      <View style={styles.errorContainer}>\n        <Text>Error loading article.</Text>\n      </View>\n    );\n  }\n\n  return (\n    <View style={styles.container}>\n      <Image source={{ uri: article.image }} style={styles.image} />\n      <Text style={styles.title}>{article.title}</Text>\n      <Text style={styles.summary}>{article.summary}</Text>\n      <Text style={styles.content}>{article.content}</Text>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    padding: 16,\n    backgroundColor: colors.neutral[50],\n  },\n  loadingContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  errorContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  image: {\n    width: '100%',\n    height: 200,\n    borderRadius: 8,\n  },\n  title: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    marginVertical: 8,\n  },\n  summary: {\n    fontSize: 16,\n    color: colors.neutral[600],\n    marginBottom: 8,\n  },\n  content: {\n    fontSize: 14,\n    lineHeight: 20,\n  },\n});\n\nexport default ArticleScreen;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/screens/HomeScreen.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":37,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":37,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1424,1465],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\nimport { View, FlatList, StyleSheet, ActivityIndicator } from 'react-native';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchArticles, selectAllArticles, setFilters } from '../store/slices/articlesSlice';\nimport ArticleCard from '../components/ArticleCard';\nimport SearchBar from '../components/SearchBar';\nimport { Text } from '../components/ui/Text';\nimport { MainScreenProps } from '../navigation/types';\nimport { RootState, AppDispatch } from '../store';\nimport { theme } from '../components/ui/theme';\n\nconst HomeScreen: React.FC<MainScreenProps<'ArticlesList'>> = ({\n  navigation: _navigation,\n  route: _route,\n}) => {\n  const dispatch = useDispatch<AppDispatch>();\n  const articles = useSelector(selectAllArticles);\n  const { loading, error } = useSelector((state: RootState) => ({\n    loading: state.articles.loading.fetch,\n    error: state.articles.error.fetch,\n  }));\n  const isAuthenticated = useSelector((state: RootState) => state.auth.isAuthenticated);\n  const [searchQuery, setSearchQuery] = useState('');\n\n  useEffect(() => {\n    // Only fetch articles if authenticated\n    if (isAuthenticated) {\n      dispatch(fetchArticles({}));\n    }\n  }, [dispatch, isAuthenticated]);\n\n  const renderItem = ({ item }) => (\n    <ArticleCard \n      article={item} \n      onPress={() => {\n        // TODO: Navigate to article detail screen\n        console.log('Article pressed:', item.id);\n      }}\n    />\n  );\n\n  if (!isAuthenticated) {\n    return (\n      <View style={styles.centerContainer}>\n        <Text style={styles.errorText}>Please log in to view your articles</Text>\n      </View>\n    );\n  }\n\n  if (loading) {\n    return (\n      <View style={styles.centerContainer}>\n        <ActivityIndicator size=\"large\" color={theme.colors.primary[500]} />\n      </View>\n    );\n  }\n\n  if (error) {\n    return (\n      <View style={styles.centerContainer}>\n        <Text style={styles.errorText}>{error}</Text>\n      </View>\n    );\n  }\n\n  const handleSearch = () => {\n    dispatch(setFilters({ searchQuery }));\n    dispatch(fetchArticles({ searchQuery }));\n  };\n\n  return (\n    <View style={styles.container}>\n      <SearchBar \n        searchQuery={searchQuery}\n        onSearchChange={setSearchQuery}\n        onSearchSubmit={handleSearch}\n      />\n      <FlatList\n        data={articles}\n        renderItem={renderItem}\n        keyExtractor={item => item.id.toString()}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    padding: 16,\n    backgroundColor: theme.colors.neutral[50],\n  },\n  centerContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    padding: 16,\n    backgroundColor: theme.colors.neutral[50],\n  },\n  errorText: {\n    fontSize: 16,\n    color: theme.colors.error[500],\n    textAlign: 'center',\n  },\n});\n\nexport default HomeScreen;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/screens/auth/LoginScreen.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":81,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":81,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2376,2431],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":82,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":82,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2436,2488],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":83,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":83,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2493,2553],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":92,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":92,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[2789,2857],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":97,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":97,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2994,3063],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":108,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":108,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[3433,3486],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":113,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":113,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3590,3660],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":130,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":130,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4171,4218],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":132,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":132,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[4245,4294],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"react-native/no-raw-text","severity":2,"message":"Raw text (Connect to Server) cannot be used outside of a <Text> tag","line":252,"column":12,"nodeType":"JSXText","endLine":254,"endColumn":11},{"ruleId":"react-native/no-raw-text","severity":2,"message":"Raw text (Need help? Setup Guide) cannot be used outside of a <Text> tag","line":276,"column":12,"nodeType":"JSXText","endLine":278,"endColumn":11},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { backgroundColor: 'rgba(255, 255, 255, 0.9)' }","line":374,"column":19,"nodeType":"ObjectExpression","endLine":383,"endColumn":4}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback, useEffect } from 'react';\nimport {\n  View,\n  StyleSheet,\n  ScrollView,\n  KeyboardAvoidingView,\n  Platform,\n  TextInput,\n  Alert,\n  ActivityIndicator,\n} from 'react-native';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { Button } from '../../components/ui/Button';\nimport { Text } from '../../components/ui/Text';\nimport { theme } from '../../components/ui/theme';\nimport MobdeckLogo from '../../components/MobdeckLogo';\nimport { AuthScreenProps } from '../../navigation/types';\nimport { AppDispatch, RootState } from '../../store';\nimport { clearError } from '../../store/slices/authSlice';\nimport { authStorageService } from '../../services/AuthStorageService';\nimport { validateApiToken } from '../../services/api';\nimport { readeckApiService } from '../../services/ReadeckApiService';\n\nconst LoginScreen: React.FC<AuthScreenProps<'Login'>> = ({ navigation }) => {\n  const dispatch = useDispatch<AppDispatch>();\n  const { loading, error } = useSelector((state: RootState) => state.auth);\n\n  const [serverUrl, setServerUrl] = useState('');\n  const [apiToken, setApiToken] = useState('');\n  const [urlError, setUrlError] = useState('');\n  const [tokenError, setTokenError] = useState('');\n  const [isValidating, setIsValidating] = useState(false);\n\n  useEffect(() => {\n    dispatch(clearError());\n  }, [dispatch]);\n\n  const validateUrl = (url: string): boolean => {\n    if (!url.trim()) {\n      setUrlError('Server URL is required');\n      return false;\n    }\n\n    try {\n      const urlObj = new URL(url);\n      if (urlObj.protocol !== 'http:' && urlObj.protocol !== 'https:') {\n        setUrlError('URL must start with http:// or https://');\n        return false;\n      }\n      setUrlError('');\n      return true;\n    } catch {\n      setUrlError('Please enter a valid URL');\n      return false;\n    }\n  };\n\n  const validateToken = (token: string): boolean => {\n    if (!token.trim()) {\n      setTokenError('API token is required');\n      return false;\n    }\n\n    if (token.length < 10) {\n      setTokenError('Token seems too short');\n      return false;\n    }\n\n    setTokenError('');\n    return true;\n  };\n\n  const handleLogin = useCallback(async () => {\n    const isUrlValid = validateUrl(serverUrl);\n    const isTokenValid = validateToken(apiToken);\n\n    if (!isUrlValid || !isTokenValid) {\n      return;\n    }\n\n    console.log('[LoginScreen] Starting login process...');\n    console.log('[LoginScreen] Server URL:', serverUrl);\n    console.log('[LoginScreen] Token length:', apiToken.length);\n\n    setIsValidating(true);\n\n    try {\n      // Validate the API token against the Readeck server\n      const validationResult = await validateApiToken(serverUrl.trim(), apiToken);\n      \n      if (!validationResult.isValid) {\n        console.error('[LoginScreen] Validation failed - result not valid');\n        Alert.alert('Login Failed', 'Invalid credentials. Please check your server URL and API token.');\n        return;\n      }\n\n      console.log('[LoginScreen] Validation successful, storing token...');\n      \n      // Create user object for storage\n      const userForStorage = {\n        ...validationResult.user,\n        serverUrl: serverUrl.trim().replace(/\\/$/, ''),\n      };\n      \n      // Store the token securely after successful validation\n      const tokenStored = await authStorageService.storeToken(apiToken, userForStorage);\n      if (!tokenStored) {\n        console.error('[LoginScreen] Failed to store token');\n        Alert.alert('Storage Error', 'Failed to store token securely');\n        return;\n      }\n\n      console.log('[LoginScreen] Token stored, configuring API service...');\n      \n      // Configure the ReadeckApiService with the server URL\n      // Ensure the URL includes the /api path\n      const cleanUrl = serverUrl.trim().replace(/\\/$/, '');\n      const apiUrl = cleanUrl.includes('/api') ? cleanUrl : `${cleanUrl}/api`;\n      \n      readeckApiService.updateConfig({\n        baseUrl: apiUrl,\n      });\n      \n      // Dispatch success action with validated user data\n      dispatch({\n        type: 'auth/setUser',\n        payload: validationResult.user,\n      });\n      \n      console.log('[LoginScreen] Login successful!');\n    } catch (err) {\n      console.error('[LoginScreen] Login error:', err);\n      Alert.alert(\n        'Login Failed',\n        err instanceof Error\n          ? err.message\n          : 'Failed to authenticate with the server'\n      );\n    } finally {\n      setIsValidating(false);\n    }\n  }, [serverUrl, apiToken, dispatch]);\n\n  const handleSetupPress = useCallback(() => {\n    navigation.navigate('Setup');\n  }, [navigation]);\n\n  return (\n    <KeyboardAvoidingView\n      style={styles.container}\n      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}\n    >\n      <ScrollView\n        contentContainerStyle={styles.scrollContent}\n        keyboardShouldPersistTaps='handled'\n      >\n        <View style={styles.headerContainer}>\n          <View style={styles.titleContainer}>\n            <MobdeckLogo size={48} />\n            <Text variant='h1' align='center' style={styles.title}>\n              Mobdeck\n            </Text>\n          </View>\n          <Text variant='body1' align='center' color='neutral.600'>\n            Connect to your Readeck server\n          </Text>\n        </View>\n\n        <View style={styles.formContainer}>\n          <View style={styles.inputGroup}>\n            <Text variant='body2' weight='medium' style={styles.label}>\n              Server URL\n            </Text>\n            <TextInput\n              style={[styles.input, urlError ? styles.inputError : null]}\n              placeholder='https://readeck.example.com'\n              placeholderTextColor={theme.colors.neutral[400]}\n              value={serverUrl}\n              onChangeText={(text: string) => {\n                setServerUrl(text);\n                if (urlError) validateUrl(text);\n              }}\n              onBlur={() => validateUrl(serverUrl)}\n              autoCapitalize='none'\n              autoCorrect={false}\n              keyboardType='url'\n              textContentType='URL'\n              accessibilityLabel='Server URL input'\n              accessibilityHint='Enter your Readeck server URL'\n            />\n            {urlError ? (\n              <Text\n                variant='caption'\n                color='error.500'\n                style={styles.errorText}\n              >\n                {urlError}\n              </Text>\n            ) : null}\n          </View>\n\n          <View style={styles.inputGroup}>\n            <Text variant='body2' weight='medium' style={styles.label}>\n              API Token\n            </Text>\n            <TextInput\n              style={[styles.input, tokenError ? styles.inputError : null]}\n              placeholder='Enter your API token'\n              placeholderTextColor={theme.colors.neutral[400]}\n              value={apiToken}\n              onChangeText={(text: string) => {\n                setApiToken(text);\n                if (tokenError) validateToken(text);\n              }}\n              onBlur={() => validateToken(apiToken)}\n              secureTextEntry\n              autoCapitalize='none'\n              autoCorrect={false}\n              textContentType='password'\n              accessibilityLabel='API token input'\n              accessibilityHint='Enter your Readeck API token'\n            />\n            {tokenError ? (\n              <Text\n                variant='caption'\n                color='error.500'\n                style={styles.errorText}\n              >\n                {tokenError}\n              </Text>\n            ) : null}\n          </View>\n\n          {error ? (\n            <View style={styles.errorContainer}>\n              <Text variant='body2' color='error.600' align='center'>\n                {error}\n              </Text>\n            </View>\n          ) : null}\n\n          <Button\n            variant='primary'\n            size='lg'\n            fullWidth\n            onPress={handleLogin}\n            loading={loading || isValidating}\n            disabled={loading || isValidating}\n            style={styles.loginButton}\n            accessibilityLabel='Login button'\n            accessibilityHint='Tap to connect to your Readeck server'\n          >\n            Connect to Server\n          </Button>\n\n          <View style={styles.divider}>\n            <View style={styles.dividerLine} />\n            <Text\n              variant='caption'\n              color='neutral.500'\n              style={styles.dividerText}\n            >\n              OR\n            </Text>\n            <View style={styles.dividerLine} />\n          </View>\n\n          <Button\n            variant='outline'\n            size='md'\n            fullWidth\n            onPress={handleSetupPress}\n            disabled={loading || isValidating}\n            accessibilityLabel='Setup button'\n            accessibilityHint='Tap to get help setting up your API token'\n          >\n            Need help? Setup Guide\n          </Button>\n        </View>\n\n        {loading || isValidating ? (\n          <View style={styles.loadingOverlay}>\n            <ActivityIndicator size='large' color={theme.colors.primary[500]} />\n            <Text\n              variant='body2'\n              color='neutral.600'\n              style={styles.loadingText}\n            >\n              Validating connection...\n            </Text>\n          </View>\n        ) : null}\n      </ScrollView>\n    </KeyboardAvoidingView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: theme.colors.neutral[50],\n  },\n  scrollContent: {\n    flexGrow: 1,\n    paddingHorizontal: theme.spacing[6],\n    paddingVertical: theme.spacing[8],\n  },\n  headerContainer: {\n    marginTop: theme.spacing[8],\n    marginBottom: theme.spacing[10],\n    alignItems: 'center',\n  },\n  titleContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginBottom: theme.spacing[2],\n  },\n  title: {\n    color: theme.colors.primary[500],\n    marginLeft: theme.spacing[3],\n  },\n  formContainer: {\n    flex: 1,\n    maxWidth: 400,\n    width: '100%',\n    alignSelf: 'center',\n  },\n  inputGroup: {\n    marginBottom: theme.spacing[6],\n  },\n  label: {\n    marginBottom: theme.spacing[2],\n    color: theme.colors.neutral[700],\n  },\n  input: {\n    borderWidth: 1,\n    borderColor: theme.colors.neutral[300],\n    borderRadius: theme.borderRadius.base,\n    paddingHorizontal: theme.spacing[4],\n    paddingVertical: theme.spacing[3],\n    fontSize: theme.typography.fontSize.base,\n    color: theme.colors.neutral[900],\n    backgroundColor: theme.colors.neutral[50],\n  },\n  inputError: {\n    borderColor: theme.colors.error[500],\n  },\n  errorText: {\n    marginTop: theme.spacing[1],\n  },\n  errorContainer: {\n    backgroundColor: theme.colors.error[50],\n    borderRadius: theme.borderRadius.base,\n    padding: theme.spacing[3],\n    marginBottom: theme.spacing[4],\n  },\n  loginButton: {\n    marginTop: theme.spacing[2],\n    marginBottom: theme.spacing[6],\n  },\n  divider: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginVertical: theme.spacing[6],\n  },\n  dividerLine: {\n    flex: 1,\n    height: 1,\n    backgroundColor: theme.colors.neutral[300],\n  },\n  dividerText: {\n    marginHorizontal: theme.spacing[3],\n  },\n  loadingOverlay: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    backgroundColor: 'rgba(255, 255, 255, 0.9)',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  loadingText: {\n    marginTop: theme.spacing[3],\n  },\n});\n\nexport default LoginScreen;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/screens/auth/SetupScreen.tsx","messages":[{"ruleId":"react-native/no-raw-text","severity":2,"message":"Raw text (Test Connection) cannot be used outside of a <Text> tag","line":231,"column":10,"nodeType":"JSXText","endLine":233,"endColumn":9}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback } from 'react';\nimport {\n  View,\n  StyleSheet,\n  ScrollView,\n  TextInput,\n  Alert,\n  Platform,\n} from 'react-native';\nimport { Button } from '../../components/ui/Button';\nimport { Text } from '../../components/ui/Text';\nimport { theme } from '../../components/ui/theme';\nimport { AuthScreenProps } from '../../navigation/types';\nimport { authStorageService } from '../../services/AuthStorageService';\n\ninterface SetupStep {\n  id: number;\n  title: string;\n  description: string;\n}\n\nconst SetupScreen: React.FC<AuthScreenProps<'Setup'>> = ({ navigation }) => {\n  const [testUrl, setTestUrl] = useState('');\n  const [testToken, setTestToken] = useState('');\n  const [isTesting, setIsTesting] = useState(false);\n  const [testResult, setTestResult] = useState<{\n    success: boolean;\n    message: string;\n  } | null>(null);\n\n\n  const testConnection = useCallback(async () => {\n    if (!testUrl.trim() || !testToken.trim()) {\n      Alert.alert(\n        'Missing Information',\n        'Please enter both URL and token to test'\n      );\n      return;\n    }\n\n    setIsTesting(true);\n    setTestResult(null);\n\n    try {\n      // Test the connection by making a simple API call\n      const response = await fetch(`${testUrl.trim()}/api/bookmarks`, {\n        method: 'GET',\n        headers: {\n          Authorization: `Bearer ${testToken.trim()}`,\n          Accept: 'application/json',\n        },\n      });\n\n      if (response.ok) {\n        setTestResult({\n          success: true,\n          message: 'Connection successful! Your token is valid.',\n        });\n\n        // Store the validated token\n        const stored = await authStorageService.storeToken(testToken);\n        if (!stored) {\n          Alert.alert(\n            'Warning',\n            'Connection test passed but failed to store token securely'\n          );\n        }\n      } else {\n        const errorMessage =\n          response.status === 401\n            ? 'Invalid token. Please check your API token.'\n            : `Connection failed with status: ${response.status}`;\n\n        setTestResult({\n          success: false,\n          message: errorMessage,\n        });\n      }\n    } catch (error) {\n      setTestResult({\n        success: false,\n        message:\n          error instanceof Error\n            ? `Network error: ${error.message}`\n            : 'Failed to connect. Check your URL and network connection.',\n      });\n    } finally {\n      setIsTesting(false);\n    }\n  }, [testUrl, testToken]);\n\n  const handleBackToLogin = useCallback(() => {\n    if (testResult?.success && testUrl && testToken) {\n      // Pass validated credentials back to login screen\n      navigation.navigate('Login');\n    } else {\n      navigation.goBack();\n    }\n  }, [navigation, testResult, testUrl, testToken]);\n\n  const setupSteps: SetupStep[] = [\n    {\n      id: 1,\n      title: 'Access your Readeck settings',\n      description:\n        'Log in to your Readeck web interface and navigate to Settings > API Tokens',\n    },\n    {\n      id: 2,\n      title: 'Create a new API token',\n      description:\n        'Click \"Create New Token\", give it a descriptive name like \"Mobdeck Mobile\", and set the expiration as needed',\n    },\n    {\n      id: 3,\n      title: 'Copy the API token',\n      description:\n        \"Copy the generated token for easy access. The token will look like a long string of random characters\",\n    },\n    {\n      id: 4,\n      title: 'Enter your server details',\n      description: 'Use the form below to test your connection',\n    },\n  ];\n\n  return (\n    <ScrollView\n      style={styles.container}\n      contentContainerStyle={styles.scrollContent}\n      keyboardShouldPersistTaps='handled'\n    >\n      <View style={styles.header}>\n        <Text variant='h3' style={styles.title}>\n          Setup Instructions\n        </Text>\n        <Text variant='body2' color='neutral.600' align='center'>\n          Follow these steps to get your API token from Readeck\n        </Text>\n      </View>\n\n      <View style={styles.stepsContainer}>\n        {setupSteps.map(step => (\n          <View key={step.id} style={styles.step}>\n            <View style={styles.stepHeader}>\n              <View style={styles.stepNumber}>\n                <Text variant='body2' color='neutral.50' weight='bold'>\n                  {step.id}\n                </Text>\n              </View>\n              <Text variant='h6' style={styles.stepTitle}>\n                {step.title}\n              </Text>\n            </View>\n            <Text\n              variant='body2'\n              color='neutral.700'\n              style={styles.stepDescription}\n            >\n              {step.description}\n            </Text>\n          </View>\n        ))}\n      </View>\n\n      <View style={styles.testContainer}>\n        <Text variant='h5' style={styles.sectionTitle}>\n          Test Your Connection\n        </Text>\n\n        <View style={styles.inputGroup}>\n          <Text variant='body2' weight='medium' style={styles.label}>\n            Server URL\n          </Text>\n          <TextInput\n            style={styles.input}\n            placeholder='https://readeck.example.com'\n            placeholderTextColor={theme.colors.neutral[400]}\n            value={testUrl}\n            onChangeText={setTestUrl}\n            autoCapitalize='none'\n            autoCorrect={false}\n            keyboardType='url'\n            textContentType='URL'\n          />\n        </View>\n\n        <View style={styles.inputGroup}>\n          <Text variant='body2' weight='medium' style={styles.label}>\n            API Token\n          </Text>\n          <TextInput\n            style={styles.input}\n            placeholder='Paste your token here'\n            placeholderTextColor={theme.colors.neutral[400]}\n            value={testToken}\n            onChangeText={setTestToken}\n            autoCapitalize='none'\n            autoCorrect={false}\n            secureTextEntry\n            multiline={Platform.OS === 'ios'} // Allow multiline on iOS for easier pasting\n            numberOfLines={Platform.OS === 'ios' ? 2 : 1}\n          />\n        </View>\n\n        {testResult && (\n          <View\n            style={[\n              styles.testResult,\n              testResult.success ? styles.testSuccess : styles.testError,\n            ]}\n          >\n            <Text\n              variant='body2'\n              color={testResult.success ? 'success.700' : 'error.700'}\n              weight='medium'\n            >\n              {testResult.message}\n            </Text>\n          </View>\n        )}\n\n        <Button\n          variant='primary'\n          size='md'\n          fullWidth\n          onPress={testConnection}\n          loading={isTesting}\n          disabled={isTesting || !testUrl.trim() || !testToken.trim()}\n          style={styles.testButton}\n        >\n          Test Connection\n        </Button>\n      </View>\n\n      <View style={styles.footer}>\n        <Button\n          variant={testResult?.success ? 'primary' : 'outline'}\n          size='lg'\n          fullWidth\n          onPress={handleBackToLogin}\n          style={styles.backButton}\n        >\n          {testResult?.success ? 'Continue to Login' : 'Back to Login'}\n        </Button>\n\n        <Text\n          variant='caption'\n          color='neutral.500'\n          align='center'\n          style={styles.hint}\n        >\n          Your token is stored securely on your device\n        </Text>\n      </View>\n    </ScrollView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: theme.colors.neutral[50],\n  },\n  scrollContent: {\n    paddingHorizontal: theme.spacing[6],\n    paddingVertical: theme.spacing[6],\n  },\n  header: {\n    alignItems: 'center',\n    marginBottom: theme.spacing[8],\n  },\n  title: {\n    color: theme.colors.neutral[900],\n    marginBottom: theme.spacing[2],\n  },\n  stepsContainer: {\n    marginBottom: theme.spacing[8],\n  },\n  step: {\n    marginBottom: theme.spacing[6],\n    backgroundColor: theme.colors.neutral[50],\n    borderRadius: theme.borderRadius.base,\n    padding: theme.spacing[4],\n    borderWidth: 1,\n    borderColor: theme.colors.neutral[200],\n  },\n  stepHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginBottom: theme.spacing[2],\n  },\n  stepNumber: {\n    width: 28,\n    height: 28,\n    borderRadius: theme.borderRadius.full,\n    backgroundColor: theme.colors.primary[500],\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginRight: theme.spacing[3],\n  },\n  stepTitle: {\n    flex: 1,\n    color: theme.colors.neutral[900],\n  },\n  stepDescription: {\n    marginLeft: 40,\n    lineHeight: 22,\n  },\n  testContainer: {\n    backgroundColor: theme.colors.neutral[100],\n    borderRadius: theme.borderRadius.lg,\n    padding: theme.spacing[6],\n    marginBottom: theme.spacing[8],\n  },\n  sectionTitle: {\n    color: theme.colors.neutral[900],\n    marginBottom: theme.spacing[4],\n  },\n  inputGroup: {\n    marginBottom: theme.spacing[4],\n  },\n  label: {\n    marginBottom: theme.spacing[2],\n    color: theme.colors.neutral[700],\n  },\n  input: {\n    borderWidth: 1,\n    borderColor: theme.colors.neutral[300],\n    borderRadius: theme.borderRadius.base,\n    paddingHorizontal: theme.spacing[4],\n    paddingVertical: theme.spacing[3],\n    fontSize: theme.typography.fontSize.base,\n    color: theme.colors.neutral[900],\n    backgroundColor: theme.colors.neutral[50],\n    minHeight: Platform.OS === 'ios' ? 60 : 48,\n  },\n  testButton: {\n    marginTop: theme.spacing[2],\n  },\n  testResult: {\n    borderRadius: theme.borderRadius.base,\n    padding: theme.spacing[3],\n    marginBottom: theme.spacing[4],\n  },\n  testSuccess: {\n    backgroundColor: theme.colors.success[50],\n    borderWidth: 1,\n    borderColor: theme.colors.success[200],\n  },\n  testError: {\n    backgroundColor: theme.colors.error[50],\n    borderWidth: 1,\n    borderColor: theme.colors.error[200],\n  },\n  footer: {\n    marginTop: theme.spacing[4],\n  },\n  backButton: {\n    marginBottom: theme.spacing[3],\n  },\n  hint: {\n    marginTop: theme.spacing[2],\n  },\n});\n\nexport default SetupScreen;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/screens/main/ArticleDetailScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Article' is defined but never used.","line":29,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":17},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":73,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":73,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2277,2361],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":77,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":77,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2508,2601],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":78,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":78,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2612,2872],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":88,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":88,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2958,3025],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":94,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":94,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3211,3304],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":98,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":98,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3471,3551],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":99,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":99,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3564,4019],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":116,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":116,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4329,4585],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":132,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":132,"endColumn":28,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4945,5050],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":134,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":134,"endColumn":28,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5090,5162],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-shadow","severity":2,"message":"'error' is already declared in the upper scope on line 45 column 20.","line":138,"column":20,"nodeType":"Identifier","messageId":"noShadow","endLine":138,"endColumn":25},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":139,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":139,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[5254,5340],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":140,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":140,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[5353,5527],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":147,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":147,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5601,5671],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":152,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":152,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5811,5900],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":155,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":155,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6025,6112],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-shadow","severity":2,"message":"'error' is already declared in the upper scope on line 45 column 20.","line":163,"column":20,"nodeType":"Identifier","messageId":"noShadow","endLine":163,"endColumn":25},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":164,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":164,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[6343,6419],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":179,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":179,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6700,6779],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":180,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":180,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6786,7077],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":192,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":192,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7214,7306],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":198,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":198,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7538,7621],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":205,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":205,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7868,8228],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":225,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":225,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8647,8947],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":240,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":240,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9137,9202],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-shadow","severity":2,"message":"'error' is already declared in the upper scope on line 45 column 20.","line":248,"column":14,"nodeType":"Identifier","messageId":"noShadow","endLine":248,"endColumn":19},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":249,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":249,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[9559,9632],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-shadow","severity":2,"message":"'error' is already declared in the upper scope on line 45 column 20.","line":271,"column":14,"nodeType":"Identifier","messageId":"noShadow","endLine":271,"endColumn":19},{"ruleId":"@typescript-eslint/no-shadow","severity":2,"message":"'error' is already declared in the upper scope on line 45 column 20.","line":291,"column":14,"nodeType":"Identifier","messageId":"noShadow","endLine":291,"endColumn":19},{"ruleId":"@typescript-eslint/no-shadow","severity":2,"message":"'error' is already declared in the upper scope on line 45 column 20.","line":311,"column":14,"nodeType":"Identifier","messageId":"noShadow","endLine":311,"endColumn":19},{"ruleId":"@typescript-eslint/no-shadow","severity":2,"message":"'error' is already declared in the upper scope on line 45 column 20.","line":328,"column":14,"nodeType":"Identifier","messageId":"noShadow","endLine":328,"endColumn":19},{"ruleId":"@typescript-eslint/no-shadow","severity":2,"message":"'error' is already declared in the upper scope on line 45 column 20.","line":351,"column":22,"nodeType":"Identifier","messageId":"noShadow","endLine":351,"endColumn":27},{"ruleId":"react-native/no-raw-text","severity":2,"message":"Raw text (Go Back) cannot be used outside of a <Text> tag","line":421,"column":10,"nodeType":"JSXText","endLine":423,"endColumn":9},{"ruleId":"react-native/no-raw-text","severity":2,"message":"Raw text (Go Back) cannot be used outside of a <Text> tag","line":442,"column":10,"nodeType":"JSXText","endLine":444,"endColumn":9},{"ruleId":"react-native/no-raw-text","severity":2,"message":"Raw text (Manage Labels) cannot be used outside of a <Text> tag","line":575,"column":16,"nodeType":"JSXText","endLine":577,"endColumn":15},{"ruleId":"react-native/no-raw-text","severity":2,"message":"Raw text (Share) cannot be used outside of a <Text> tag","line":584,"column":16,"nodeType":"JSXText","endLine":586,"endColumn":15},{"ruleId":"react-native/no-raw-text","severity":2,"message":"Raw text (Delete) cannot be used outside of a <Text> tag","line":594,"column":16,"nodeType":"JSXText","endLine":596,"endColumn":15}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":24,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState, useCallback } from 'react';\nimport {\n  View,\n  ScrollView,\n  StyleSheet,\n  ActivityIndicator,\n  TouchableOpacity,\n  Share,\n  Alert,\n  RefreshControl,\n} from 'react-native';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport { Text } from '../../components/ui/Text';\nimport { Button } from '../../components/ui/Button';\nimport { ArticleContent } from '../../components/ArticleContent';\nimport { LabelManagementModal } from '../../components/LabelManagementModal';\nimport { theme } from '../../components/ui/theme';\nimport { MainScreenProps } from '../../navigation/types';\nimport { RootState } from '../../store';\nimport {\n  selectArticleById,\n  updateArticle,\n  deleteArticle,\n  updateArticleLocal,\n  updateArticleLocalWithDB,\n} from '../../store/slices/articlesSlice';\nimport { articlesApiService } from '../../services/ArticlesApiService';\nimport { Article } from '../../types';\n\ntype ArticleDetailScreenProps = MainScreenProps<'ArticleDetail'>;\n\nexport const ArticleDetailScreen: React.FC<ArticleDetailScreenProps> = ({\n  navigation,\n  route,\n}) => {\n  const dispatch = useDispatch();\n  const insets = useSafeAreaInsets();\n  const { articleId } = route.params;\n\n  const article = useSelector((state: RootState) =>\n    selectArticleById(state, articleId)\n  );\n\n  const { loading, error } = useSelector((state: RootState) => state.articles);\n\n  const [refreshing, setRefreshing] = useState(false);\n  const [showActions, setShowActions] = useState(false);\n  const [showLabelModal, setShowLabelModal] = useState(false);\n  const [contentFetched, setContentFetched] = useState(false);\n\n  // Set navigation title\n  useEffect(() => {\n    if (article?.title) {\n      navigation.setOptions({\n        title:\n          article.title.length > 30\n            ? `${article.title.substring(0, 30)}...`\n            : article.title,\n      });\n    }\n  }, [article?.title, navigation]);\n\n\n  // Fetch content on first load if not already present\n  useEffect(() => {\n    const fetchContentIfNeeded = async () => {\n      if (!article || contentFetched) return;\n      \n      // Check if article has no content\n      if (!article.content) {\n        setContentFetched(true);\n        console.log('[ArticleDetailScreen] Article has no content, attempting to fetch...');\n        \n        // If it's a local article (offline-saved), try to sync to server first\n        if (article.id.startsWith('local_')) {\n          console.log('[ArticleDetailScreen] Local article detected, attempting to sync to server...');\n          console.log('[ArticleDetailScreen] Article details:', {\n            id: article.id,\n            title: article.title,\n            url: article.url,\n            hasContent: !!article.content,\n            contentLength: article.content?.length || 0\n          });\n          \n          try {\n            // Create article on server first\n            console.log('[ArticleDetailScreen] Creating article on server...');\n            const createdArticle = await articlesApiService.createArticle({\n              title: article.title,\n              url: article.url,\n            });\n            \n            console.log('[ArticleDetailScreen] Article created on server, now fetching full content...');\n            // Fetch the full article with content\n            const serverArticle = await articlesApiService.getArticle(createdArticle.id);\n            \n            console.log('[ArticleDetailScreen] Article with content fetched successfully!');\n            console.log('[ArticleDetailScreen] Server article:', {\n              id: serverArticle.id,\n              title: serverArticle.title,\n              hasContent: !!serverArticle.content,\n              contentLength: serverArticle.content?.length || 0,\n              contentPreview: serverArticle.content?.substring(0, 100) || 'NO_CONTENT',\n              hasImageUrl: !!serverArticle.imageUrl,\n              hasSummary: !!serverArticle.summary\n            });\n            \n            // Update local article with server data and content\n            const updateData = {\n              content: serverArticle.content || '',\n              summary: serverArticle.summary || '',\n              imageUrl: serverArticle.imageUrl || '',\n            };\n            \n            console.log('[ArticleDetailScreen] Updating local article with server data:', {\n              contentLength: updateData.content.length,\n              summaryLength: updateData.summary.length,\n              hasImageUrl: !!updateData.imageUrl\n            });\n            \n            dispatch(\n              updateArticleLocalWithDB({\n                id: articleId,\n                updates: updateData,\n              })\n            );\n            \n            // Show success message to user\n            setTimeout(() => {\n              if (serverArticle.content && serverArticle.content.length > 0) {\n                console.log('[ArticleDetailScreen] Content fetched successfully, length:', serverArticle.content.length);\n              } else {\n                console.log('[ArticleDetailScreen] No content was fetched from server');\n              }\n            }, 1000);\n            \n          } catch (error) {\n            console.error('[ArticleDetailScreen] Failed to sync local article to server:', error);\n            console.error('[ArticleDetailScreen] Error details:', {\n              message: error.message,\n              stack: error.stack,\n              name: error.name\n            });\n            \n            // Show user-friendly error message\n            console.log('[ArticleDetailScreen] Will try again on manual refresh');\n          }\n        } \n        // If it's a server article with contentUrl, fetch content\n        else if (article.contentUrl) {\n          console.log('[ArticleDetailScreen] Server article with contentUrl, fetching content...');\n          try {\n            const htmlContent = await articlesApiService.getArticleContent(article.contentUrl);\n            console.log('[ArticleDetailScreen] Auto-fetched content, length:', htmlContent.length);\n            \n            dispatch(\n              updateArticleLocalWithDB({\n                id: articleId,\n                updates: { content: htmlContent },\n              })\n            );\n          } catch (error) {\n            console.error('[ArticleDetailScreen] Failed to auto-fetch content:', error);\n          }\n        }\n      }\n    };\n\n    fetchContentIfNeeded();\n  }, [article, articleId, dispatch, contentFetched]);\n\n  // Handle refresh - fetch full content\n  const handleRefresh = useCallback(async () => {\n    if (!article) return;\n\n    setRefreshing(true);\n    try {\n      console.log('[ArticleDetailScreen] Manual refresh - fetching full content...');\n      console.log('[ArticleDetailScreen] Current article state:', {\n        id: article.id,\n        title: article.title,\n        hasContent: !!article.content,\n        contentLength: article.content?.length || 0,\n        contentPreview: article.content?.substring(0, 50) || 'NO_CONTENT'\n      });\n      \n      let updatedArticle;\n      \n      // Handle local articles differently\n      if (article.id.startsWith('local_')) {\n        console.log('[ArticleDetailScreen] Refreshing local article - creating on server first...');\n        // For local articles, create on server first, then fetch full content\n        const createdArticle = await articlesApiService.createArticle({\n          title: article.title,\n          url: article.url,\n        });\n        console.log('[ArticleDetailScreen] Article created, now fetching full content...');\n        updatedArticle = await articlesApiService.getArticle(createdArticle.id);\n      } else {\n        // For server articles, fetch existing article\n        updatedArticle = await articlesApiService.getArticle(article.id);\n      }\n      \n      console.log('[ArticleDetailScreen] Refresh response:', {\n        hasContent: !!updatedArticle.content,\n        contentLength: updatedArticle.content?.length || 0,\n        contentPreview: updatedArticle.content?.substring(0, 100) || 'NO_CONTENT',\n        fullArticleKeys: Object.keys(updatedArticle),\n        hasContentUrl: !!updatedArticle.contentUrl\n      });\n      \n      // Content should already be fetched by getArticle method\n      // Log the result for debugging\n      \n      // Debug: Show all fields being updated\n      const updateData = {\n        content: updatedArticle.content,\n        summary: updatedArticle.summary,\n        title: updatedArticle.title,\n        imageUrl: updatedArticle.imageUrl,\n        updatedAt: updatedArticle.updatedAt,\n      };\n      \n      console.log('[ArticleDetailScreen] Dispatching updates:', {\n        content: updateData.content?.substring(0, 100) || 'NO_CONTENT',\n        contentLength: updateData.content?.length || 0,\n        summary: updateData.summary?.substring(0, 50) || 'NO_SUMMARY',\n        title: updateData.title\n      });\n      \n      // Update local state with fresh content\n      dispatch(\n        updateArticleLocal({\n          id: article.id,\n          updates: updateData,\n        })\n      );\n      \n      console.log('[ArticleDetailScreen] Article updated via refresh');\n      \n      // Show alert with debugging info to user\n      Alert.alert(\n        'Refresh Complete',\n        `Content fetched: ${updatedArticle.content ? 'YES' : 'NO'}\\nContent length: ${updatedArticle.content?.length || 0} chars\\nFields available: ${Object.keys(updatedArticle).join(', ')}`,\n        [{ text: 'OK' }]\n      );\n    } catch (error) {\n      console.error('[ArticleDetailScreen] Failed to refresh article:', error);\n      Alert.alert(\n        'Refresh Failed',\n        `Unable to fetch latest article content. Error: ${error.message || 'Unknown error'}`,\n        [{ text: 'OK' }]\n      );\n    } finally {\n      setRefreshing(false);\n    }\n  }, [article, dispatch]);\n\n  // Handle favorite toggle\n  const handleToggleFavorite = useCallback(async () => {\n    if (!article) return;\n\n    try {\n      await dispatch(\n        updateArticle({\n          id: articleId,\n          updates: { isFavorite: !article.isFavorite },\n        })\n      ).unwrap();\n    } catch (error) {\n      Alert.alert(\n        'Error',\n        'Failed to update favorite status. Please try again.',\n        [{ text: 'OK' }]\n      );\n    }\n  }, [article, articleId, dispatch]);\n\n  // Handle archive toggle\n  const handleToggleArchive = useCallback(async () => {\n    if (!article) return;\n\n    try {\n      await dispatch(\n        updateArticle({\n          id: articleId,\n          updates: { isArchived: !article.isArchived },\n        })\n      ).unwrap();\n    } catch (error) {\n      Alert.alert(\n        'Error',\n        'Failed to update archive status. Please try again.',\n        [{ text: 'OK' }]\n      );\n    }\n  }, [article, articleId, dispatch]);\n\n  // Handle read toggle\n  const handleToggleRead = useCallback(async () => {\n    if (!article) return;\n\n    try {\n      await dispatch(\n        updateArticle({\n          id: articleId,\n          updates: { isRead: !article.isRead },\n        })\n      ).unwrap();\n    } catch (error) {\n      Alert.alert('Error', 'Failed to update read status. Please try again.', [\n        { text: 'OK' },\n      ]);\n    }\n  }, [article, articleId, dispatch]);\n\n  // Handle share\n  const handleShare = useCallback(async () => {\n    if (!article) return;\n\n    try {\n      await Share.share({\n        message: `${article.title}\\n\\n${article.url}`,\n        url: article.url,\n        title: article.title,\n      });\n    } catch (error) {\n      Alert.alert('Error', 'Failed to share article. Please try again.', [\n        { text: 'OK' },\n      ]);\n    }\n  }, [article]);\n\n  // Handle delete\n  const handleDelete = useCallback(() => {\n    if (!article) return;\n\n    Alert.alert(\n      'Delete Article',\n      'Are you sure you want to delete this article? This action cannot be undone.',\n      [\n        { text: 'Cancel', style: 'cancel' },\n        {\n          text: 'Delete',\n          style: 'destructive',\n          onPress: async () => {\n            try {\n              await dispatch(deleteArticle({ id: articleId })).unwrap();\n              navigation.goBack();\n            } catch (error) {\n              Alert.alert(\n                'Error',\n                'Failed to delete article. Please try again.',\n                [{ text: 'OK' }]\n              );\n            }\n          },\n        },\n      ]\n    );\n  }, [article, articleId, dispatch, navigation]);\n\n  // Handle label management\n  const handleManageLabels = useCallback(() => {\n    setShowLabelModal(true);\n  }, []);\n\n  // Handle labels changed\n  const handleLabelsChanged = useCallback(\n    (labelIds: string[]) => {\n      // Update the article's tags in the Redux store and database\n      dispatch(\n        updateArticleLocalWithDB({\n          id: articleId,\n          updates: { tags: labelIds },\n        })\n      );\n    },\n    [articleId, dispatch]\n  );\n\n  // Format date\n  const formatDate = (dateString: string): string => {\n    const date = new Date(dateString);\n    return date.toLocaleDateString('en-US', {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  };\n\n  // Show loading state\n  if (loading.fetch && !article) {\n    return (\n      <View style={[styles.container, styles.centeredContainer]}>\n        <ActivityIndicator size='large' color={theme.colors.primary[500]} />\n        <Text variant='body1' style={styles.loadingText}>\n          Loading article...\n        </Text>\n      </View>\n    );\n  }\n\n  // Show error state\n  if (error.fetch && !article) {\n    return (\n      <View style={[styles.container, styles.centeredContainer]}>\n        <Text variant='h6' style={styles.errorTitle}>\n          Article Not Found\n        </Text>\n        <Text variant='body1' style={styles.errorMessage}>\n          The article you're looking for could not be loaded.\n        </Text>\n        <Button\n          variant='outline'\n          onPress={() => navigation.goBack()}\n          style={styles.backButton}\n        >\n          Go Back\n        </Button>\n      </View>\n    );\n  }\n\n  // Show article not found\n  if (!article) {\n    return (\n      <View style={[styles.container, styles.centeredContainer]}>\n        <Text variant='h6' style={styles.errorTitle}>\n          Article Not Found\n        </Text>\n        <Text variant='body1' style={styles.errorMessage}>\n          This article may have been deleted or moved.\n        </Text>\n        <Button\n          variant='outline'\n          onPress={() => navigation.goBack()}\n          style={styles.backButton}\n        >\n          Go Back\n        </Button>\n      </View>\n    );\n  }\n\n  return (\n    <View style={[styles.container, { paddingTop: insets.top }]}>\n      <ScrollView\n        style={styles.scrollView}\n        contentContainerStyle={styles.scrollContent}\n        refreshControl={\n          <RefreshControl\n            refreshing={refreshing}\n            onRefresh={handleRefresh}\n            colors={[theme.colors.primary[500]]}\n            tintColor={theme.colors.primary[500]}\n          />\n        }\n      >\n        {/* Article Header */}\n        <View style={styles.header}>\n          <Text variant='h4' style={styles.title}>\n            {article.title}\n          </Text>\n\n          <View style={styles.metadata}>\n            <Text variant='caption' style={styles.metadataText}>\n              Added {formatDate(article.createdAt)}\n            </Text>\n\n            {!!article.readTime && (\n              <>\n                <Text variant='caption' style={styles.separator}>\n                  •\n                </Text>\n                <Text variant='caption' style={styles.metadataText}>\n                  {article.readTime} min read\n                </Text>\n              </>\n            )}\n          </View>\n\n          {article.sourceUrl && (\n            <TouchableOpacity\n              style={styles.sourceContainer}\n              onPress={() => {\n                // TODO: Open source URL in browser\n                Alert.alert('Source', article.sourceUrl);\n              }}\n            >\n              <Text variant='caption' style={styles.sourceUrl}>\n                {(() => {\n                  try {\n                    return new URL(article.sourceUrl).hostname;\n                  } catch {\n                    return article.sourceUrl;\n                  }\n                })()}\n              </Text>\n            </TouchableOpacity>\n          )}\n\n          {/* Tags */}\n          {article.tags && article.tags.length > 0 && (\n            <View style={styles.tagsContainer}>\n              {article.tags.map(tag => (\n                <View key={tag} style={styles.tag}>\n                  <Text variant='caption' style={styles.tagText}>\n                    {tag}\n                  </Text>\n                </View>\n              ))}\n            </View>\n          )}\n        </View>\n\n        {/* Article Content */}\n        <ArticleContent\n          content={article.content}\n          summary={article.summary}\n          imageUrl={article.imageUrl}\n        />\n\n        {/* Actions Section */}\n        <View style={styles.actionsContainer}>\n          <Button\n            variant='ghost'\n            size='sm'\n            onPress={() => setShowActions(!showActions)}\n            style={styles.actionToggle}\n          >\n            {showActions ? 'Hide Actions' : 'Show Actions'}\n          </Button>\n\n          {showActions && (\n            <View style={styles.actionsGrid}>\n              <Button\n                variant='outline'\n                size='sm'\n                onPress={handleToggleFavorite}\n                style={styles.actionButton}\n                loading={loading.update}\n              >\n                {article.isFavorite ? 'Unfavorite' : 'Favorite'}\n              </Button>\n\n              <Button\n                variant='outline'\n                size='sm'\n                onPress={handleToggleArchive}\n                style={styles.actionButton}\n                loading={loading.update}\n              >\n                {article.isArchived ? 'Unarchive' : 'Archive'}\n              </Button>\n\n              <Button\n                variant='outline'\n                size='sm'\n                onPress={handleToggleRead}\n                style={styles.actionButton}\n                loading={loading.update}\n              >\n                {article.isRead ? 'Mark Unread' : 'Mark Read'}\n              </Button>\n\n              <Button\n                variant='outline'\n                size='sm'\n                onPress={handleManageLabels}\n                style={styles.actionButton}\n              >\n                Manage Labels\n              </Button>\n\n              <Button\n                variant='outline'\n                size='sm'\n                onPress={handleShare}\n                style={styles.actionButton}\n              >\n                Share\n              </Button>\n\n              <Button\n                variant='destructive'\n                size='sm'\n                onPress={handleDelete}\n                style={styles.actionButton}\n                loading={loading.delete}\n              >\n                Delete\n              </Button>\n            </View>\n          )}\n        </View>\n      </ScrollView>\n\n      {/* Label Management Modal */}\n      {article && (\n        <LabelManagementModal\n          visible={showLabelModal}\n          onClose={() => setShowLabelModal(false)}\n          articleId={articleId}\n          articleTitle={article.title}\n          currentLabels={article.tags || []}\n          onLabelsChanged={handleLabelsChanged}\n        />\n      )}\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: theme.colors.neutral[100],\n  },\n  centeredContainer: {\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingHorizontal: theme.spacing[6],\n  },\n  scrollView: {\n    flex: 1,\n  },\n  scrollContent: {\n    paddingBottom: theme.spacing[6],\n  },\n  header: {\n    padding: theme.spacing[4],\n    backgroundColor: theme.colors.neutral[50],\n    borderBottomWidth: 1,\n    borderBottomColor: theme.colors.neutral[200],\n  },\n  title: {\n    marginBottom: theme.spacing[3],\n    color: theme.colors.neutral[900],\n    lineHeight: theme.typography.lineHeight['3xl'],\n  },\n  metadata: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginBottom: theme.spacing[2],\n  },\n  metadataText: {\n    color: theme.colors.neutral[600],\n  },\n  separator: {\n    color: theme.colors.neutral[400],\n    marginHorizontal: theme.spacing[2],\n  },\n  sourceContainer: {\n    marginBottom: theme.spacing[3],\n  },\n  sourceUrl: {\n    color: theme.colors.primary[600],\n    textDecorationLine: 'underline',\n  },\n  tagsContainer: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    alignItems: 'center',\n  },\n  tag: {\n    backgroundColor: theme.colors.primary[100],\n    borderRadius: theme.borderRadius.sm,\n    paddingHorizontal: theme.spacing[2],\n    paddingVertical: theme.spacing[1],\n    marginRight: theme.spacing[2],\n    marginBottom: theme.spacing[1],\n  },\n  tagText: {\n    color: theme.colors.primary[700],\n    fontSize: theme.typography.fontSize.xs,\n  },\n  actionsContainer: {\n    padding: theme.spacing[4],\n    backgroundColor: theme.colors.neutral[50],\n    borderTopWidth: 1,\n    borderTopColor: theme.colors.neutral[200],\n  },\n  actionToggle: {\n    alignSelf: 'center',\n    marginBottom: theme.spacing[3],\n  },\n  actionsGrid: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    justifyContent: 'space-between',\n    gap: theme.spacing[2],\n  },\n  actionButton: {\n    flexBasis: '48%',\n    marginBottom: theme.spacing[2],\n  },\n  loadingText: {\n    marginTop: theme.spacing[2],\n    textAlign: 'center',\n    color: theme.colors.neutral[600],\n  },\n  errorTitle: {\n    marginBottom: theme.spacing[2],\n    textAlign: 'center',\n    color: theme.colors.error[700],\n  },\n  errorMessage: {\n    marginBottom: theme.spacing[4],\n    textAlign: 'center',\n    color: theme.colors.neutral[600],\n  },\n  backButton: {\n    marginTop: theme.spacing[2],\n  },\n});\n\nexport default ArticleDetailScreen;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/screens/main/ArticlesListScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'fetchArticles' is defined but never used.","line":21,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":16},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of arrow function.","line":93,"column":16,"nodeType":"ArrowFunctionExpression","messageId":"missingReturn","endLine":93,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":94,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":94,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2855,3042],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":102,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":102,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3169,3242],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":104,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":104,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3290,3360],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'isOnline'. Either include it or remove the dependency array.","line":111,"column":6,"nodeType":"ArrayExpression","endLine":111,"endColumn":50,"suggestions":[{"desc":"Update the dependencies array to be: [dispatch, articles.length, isAuthenticated, isOnline]","fix":{"range":[3571,3615],"text":"[dispatch, articles.length, isAuthenticated, isOnline]"}}]},{"ruleId":"react-native/no-raw-text","severity":2,"message":"Raw text (Clear Search) cannot be used outside of a <Text> tag","line":257,"column":10,"nodeType":"JSXText","endLine":259,"endColumn":9},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { marginRight: 8 }","line":362,"column":45,"nodeType":"ObjectExpression","endLine":362,"endColumn":63},{"ruleId":"react-native/no-raw-text","severity":2,"message":"Raw text (Settings) cannot be used outside of a <Text> tag","line":363,"column":16,"nodeType":"JSXText","endLine":365,"endColumn":15},{"ruleId":"react-native/no-raw-text","severity":2,"message":"Raw text (Retry) cannot be used outside of a <Text> tag","line":375,"column":14,"nodeType":"JSXText","endLine":377,"endColumn":13},{"ruleId":"react-native/no-color-literals","severity":1,"message":"Color literal: { backgroundColor: 'rgba(255, 255, 255, 0.8)' }","line":548,"column":19,"nodeType":"ObjectExpression","endLine":557,"endColumn":4}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState, useCallback, useMemo } from 'react';\nimport {\n  View,\n  FlatList,\n  StyleSheet,\n  RefreshControl,\n  ActivityIndicator,\n  TextInput,\n  TouchableOpacity,\n} from 'react-native';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport { Text } from '../../components/ui/Text';\nimport { Button } from '../../components/ui/Button';\nimport { ArticleCard } from '../../components/ArticleCard';\nimport MobdeckLogo from '../../components/MobdeckLogo';\nimport { theme } from '../../components/ui/theme';\nimport { MainScreenProps } from '../../navigation/types';\nimport { RootState } from '../../store';\nimport {\n  fetchArticles,\n  loadLocalArticles,\n  setFilters,\n  setPage,\n  syncArticles,\n  selectAllArticles,\n} from '../../store/slices/articlesSlice';\nimport { selectIsUserAuthenticated } from '../../store/selectors/authSelectors';\nimport { Article } from '../../types';\nimport { useNetworkStatus } from '../../hooks/useNetworkStatus';\n\nconst DEBOUNCE_DELAY = 300;\n\ntype ArticlesListScreenProps = MainScreenProps<'ArticlesList'>;\n\nexport const ArticlesListScreen: React.FC<ArticlesListScreenProps> = ({\n  navigation,\n}) => {\n  const dispatch = useDispatch();\n  const insets = useSafeAreaInsets();\n\n  const { loading, error, pagination, filters, sync } = useSelector(\n    (state: RootState) => state.articles\n  );\n\n  const articles = useSelector(selectAllArticles);\n  const isAuthenticated = useSelector(selectIsUserAuthenticated);\n  const { isOnline } = useNetworkStatus();\n\n  const [searchQuery, setSearchQuery] = useState(filters.searchQuery);\n  const [debounceTimer, setDebounceTimer] = useState<NodeJS.Timeout | null>(\n    null\n  );\n\n  // Debounced search function\n  const debouncedSearch = useCallback(\n    (query: string) => {\n      if (debounceTimer) {\n        clearTimeout(debounceTimer);\n      }\n\n      const timer = setTimeout(() => {\n        dispatch(setFilters({ searchQuery: query }));\n        // Always search local articles first to include offline-saved articles\n        dispatch(\n          loadLocalArticles({ page: 1, searchQuery: query, forceRefresh: true })\n        );\n      }, DEBOUNCE_DELAY);\n\n      setDebounceTimer(timer);\n    },\n    [dispatch, debounceTimer]\n  );\n\n  // Handle search input change\n  const handleSearchChange = useCallback(\n    (text: string) => {\n      setSearchQuery(text);\n      debouncedSearch(text);\n    },\n    [debouncedSearch]\n  );\n\n  // Clear search\n  const handleClearSearch = useCallback(() => {\n    setSearchQuery('');\n    dispatch(setFilters({ searchQuery: '' }));\n    // Always load local articles to include offline-saved articles\n    dispatch(loadLocalArticles({ page: 1, forceRefresh: true }));\n  }, [dispatch]);\n\n  // Initial load - wait for authentication to complete\n  useEffect(() => {\n    console.log('[ArticlesListScreen] useEffect triggered:', {\n      isAuthenticated,\n      articlesLength: articles.length,\n      willFetch: isAuthenticated && articles.length === 0,\n    });\n    \n    if (isAuthenticated && articles.length === 0) {\n      // Add a small delay to ensure API service is configured\n      console.log('[ArticlesListScreen] Scheduling article fetch after delay');\n      const timer = setTimeout(() => {\n        console.log('[ArticlesListScreen] Loading articles...', { isOnline });\n        // Always load local articles first to show offline-saved articles immediately\n        dispatch(loadLocalArticles({ page: 1 }));\n      }, 100);\n      \n      return () => clearTimeout(timer);\n    }\n  }, [dispatch, articles.length, isAuthenticated]);\n\n  // Pull to refresh\n  const handleRefresh = useCallback(() => {\n    dispatch(syncArticles({ fullSync: false }));\n  }, [dispatch]);\n\n  // Load more articles (pagination)\n  const handleLoadMore = useCallback(() => {\n    if (pagination.hasMore && !loading.fetch) {\n      dispatch(setPage(pagination.page + 1));\n      const loadParams = {\n        page: pagination.page + 1,\n        searchQuery: filters.searchQuery,\n        filters: {\n          searchQuery: filters.searchQuery,\n          isArchived: filters.isArchived,\n          isFavorite: filters.isFavorite,\n          isRead: filters.isRead,\n          tags: filters.tags,\n        },\n      };\n      \n      // Always load from local to include offline-saved articles\n      dispatch(loadLocalArticles(loadParams));\n    }\n  }, [dispatch, pagination.hasMore, pagination.page, loading.fetch, filters]);\n\n  // Handle article press\n  const handleArticlePress = useCallback(\n    (article: Article) => {\n      navigation.navigate('ArticleDetail', {\n        articleId: article.id,\n        title: article.title,\n      });\n    },\n    [navigation]\n  );\n\n  // Filter options\n  const filterOptions = useMemo(\n    () => [\n      {\n        key: 'all',\n        label: 'All',\n        active: filters.isRead === undefined && filters.isArchived === undefined && filters.isFavorite === undefined,\n      },\n      { key: 'unread', label: 'Unread', active: filters.isRead === false },\n      { key: 'read', label: 'Read', active: filters.isRead === true },\n      {\n        key: 'favorites',\n        label: 'Favorites',\n        active: filters.isFavorite === true,\n      },\n      {\n        key: 'archived',\n        label: 'Archived',\n        active: filters.isArchived === true,\n      },\n    ],\n    [filters]\n  );\n\n  // Handle filter selection\n  const handleFilterPress = useCallback(\n    (filterKey: string) => {\n      let newFilters = {};\n\n      switch (filterKey) {\n        case 'all':\n          newFilters = {\n            isRead: undefined,\n            isArchived: undefined,\n            isFavorite: undefined,\n          };\n          break;\n        case 'unread':\n          newFilters = {\n            isRead: false,\n            isArchived: undefined,\n            isFavorite: undefined,\n          };\n          break;\n        case 'read':\n          newFilters = {\n            isRead: true,\n            isArchived: undefined,\n            isFavorite: undefined,\n          };\n          break;\n        case 'favorites':\n          newFilters = {\n            isFavorite: true,\n            isRead: undefined,\n            isArchived: undefined,\n          };\n          break;\n        case 'archived':\n          newFilters = {\n            isArchived: true,\n            isRead: undefined,\n            isFavorite: undefined,\n          };\n          break;\n      }\n\n      dispatch(setFilters(newFilters));\n      const loadParams = { \n        page: 1, \n        filters: {\n          ...filters,\n          ...newFilters\n        }, \n        forceRefresh: true \n      };\n      \n      // Always load from local to include offline-saved articles\n      dispatch(loadLocalArticles(loadParams));\n    },\n    [dispatch, filters]\n  );\n\n  // Render article item\n  const renderArticleItem = useCallback(\n    ({ item }: { item: Article }) => (\n      <ArticleCard article={item} onPress={() => handleArticlePress(item)} />\n    ),\n    [handleArticlePress]\n  );\n\n  // Render empty state\n  const renderEmptyState = () => (\n    <View style={styles.emptyContainer}>\n      <Text variant='h4' style={styles.emptyTitle}>\n        {searchQuery ? 'No articles found' : 'No articles yet'}\n      </Text>\n      <Text variant='body1' style={styles.emptyMessage}>\n        {searchQuery\n          ? `No articles match \"${searchQuery}\"`\n          : 'Pull down to sync your articles from Readeck'}\n      </Text>\n      {searchQuery && (\n        <Button\n          variant='outline'\n          onPress={handleClearSearch}\n          style={styles.clearButton}\n        >\n          Clear Search\n        </Button>\n      )}\n    </View>\n  );\n\n  // Render footer with loading indicator for pagination\n  const renderFooter = () => {\n    if (!loading.fetch || pagination.page === 1) return null;\n\n    return (\n      <View style={styles.footerLoader}>\n        <ActivityIndicator size='small' color={theme.colors.primary[500]} />\n        <Text variant='caption' style={styles.loadingText}>\n          Loading more articles...\n        </Text>\n      </View>\n    );\n  };\n\n  // Render filter chips\n  const renderFilters = () => (\n    <View style={styles.filtersContainer}>\n      <FlatList\n        horizontal\n        showsHorizontalScrollIndicator={false}\n        data={filterOptions}\n        keyExtractor={item => item.key}\n        contentContainerStyle={styles.filtersContent}\n        renderItem={({ item }) => (\n          <TouchableOpacity\n            style={[styles.filterChip, item.active && styles.filterChipActive]}\n            onPress={() => handleFilterPress(item.key)}\n          >\n            <Text\n              variant='body2'\n              style={[\n                styles.filterChipText,\n                item.active && styles.filterChipTextActive,\n              ]}\n            >\n              {item.label}\n            </Text>\n          </TouchableOpacity>\n        )}\n      />\n    </View>\n  );\n\n  return (\n    <View style={[styles.container, { paddingTop: insets.top }]}>\n      {/* Header */}\n      <View style={styles.header}>\n        <View style={styles.headerLeft}>\n          <MobdeckLogo \n            size={24}\n            color={theme.colors.accent[500]} // Tiffany Blue for contrast on green\n          />\n          <Text variant='h3' style={styles.headerTitle}>\n            Mobdeck\n          </Text>\n        </View>\n        <TouchableOpacity\n          style={styles.settingsButton}\n          onPress={() => navigation.navigate('Settings')}\n        >\n          <Text style={styles.settingsIcon}>⚙️</Text>\n        </TouchableOpacity>\n      </View>\n\n      {/* Search Bar */}\n      <View style={styles.searchContainer}>\n        <TextInput\n          style={styles.searchInput}\n          placeholder='Search articles...'\n          value={searchQuery}\n          onChangeText={handleSearchChange}\n          placeholderTextColor={theme.colors.neutral[500]}\n        />\n        {searchQuery.length > 0 && (\n          <TouchableOpacity\n            style={styles.clearSearchButton}\n            onPress={handleClearSearch}\n          >\n            <Text style={styles.clearSearchIcon}>✕</Text>\n          </TouchableOpacity>\n        )}\n      </View>\n\n      {/* Filters */}\n      {renderFilters()}\n\n      {/* Error State */}\n      {error.fetch && (\n        <View style={styles.errorContainer}>\n          <Text variant='body1' style={styles.errorText}>\n            {error.fetch}\n          </Text>\n          <View style={styles.errorButtonsContainer}>\n            {error.fetch.includes('server settings') || error.fetch.includes('Authentication') || error.fetch.includes('Server not found') ? (\n              <Button\n                variant='primary'\n                size='sm'\n                onPress={() => navigation.navigate('Settings')}\n                style={[styles.retryButton, { marginRight: 8 }]}\n              >\n                Settings\n              </Button>\n            ) : null}\n            <Button\n              variant='outline'\n              size='sm'\n              onPress={() => {\n                // Always load from local to include offline-saved articles\n                dispatch(loadLocalArticles({ page: 1, forceRefresh: true }));\n              }}\n              style={styles.retryButton}\n            >\n              Retry\n            </Button>\n          </View>\n        </View>\n      )}\n\n      {/* Articles List */}\n      <FlatList\n        data={articles}\n        renderItem={renderArticleItem}\n        keyExtractor={item => item.id}\n        contentContainerStyle={styles.listContainer}\n        refreshControl={\n          <RefreshControl\n            refreshing={sync.isSyncing}\n            onRefresh={handleRefresh}\n            colors={[theme.colors.primary[500]]}\n            tintColor={theme.colors.primary[500]}\n          />\n        }\n        onEndReached={handleLoadMore}\n        onEndReachedThreshold={0.1}\n        ListEmptyComponent={!loading.fetch ? renderEmptyState : null}\n        ListFooterComponent={renderFooter}\n        showsVerticalScrollIndicator={false}\n        removeClippedSubviews={true}\n        maxToRenderPerBatch={10}\n        windowSize={10}\n        initialNumToRender={10}\n      />\n\n      {/* Loading overlay for initial load */}\n      {loading.fetch && articles.length === 0 && (\n        <View style={styles.loadingOverlay}>\n          <ActivityIndicator size='large' color={theme.colors.primary[500]} />\n          <Text variant='body1' style={styles.loadingText}>\n            Loading articles...\n          </Text>\n        </View>\n      )}\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: theme.colors.neutral[100],\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    paddingHorizontal: theme.spacing[4],\n    paddingVertical: theme.spacing[3],\n    backgroundColor: theme.colors.success[700], // Castleton Green\n    borderBottomWidth: 1,\n    borderBottomColor: theme.colors.success[800],\n  },\n  headerLeft: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  headerTitle: {\n    color: theme.colors.neutral[50], // White text for contrast on green background\n    marginLeft: theme.spacing[2],\n  },\n  settingsButton: {\n    padding: theme.spacing[2],\n  },\n  settingsIcon: {\n    fontSize: 20,\n    color: theme.colors.neutral[50], // White color for contrast on green background\n  },\n  searchContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginHorizontal: theme.spacing[4],\n    marginVertical: theme.spacing[3],\n    backgroundColor: theme.colors.neutral[50],\n    borderRadius: theme.borderRadius.md,\n    paddingHorizontal: theme.spacing[3],\n    ...theme.shadows.sm,\n  },\n  searchInput: {\n    flex: 1,\n    paddingVertical: theme.spacing[3],\n    fontSize: theme.typography.fontSize.base,\n    color: theme.colors.neutral[900],\n  },\n  clearSearchButton: {\n    padding: theme.spacing[1],\n  },\n  clearSearchIcon: {\n    fontSize: 16,\n    color: theme.colors.neutral[500],\n  },\n  filtersContainer: {\n    backgroundColor: theme.colors.neutral[50],\n    borderBottomWidth: 1,\n    borderBottomColor: theme.colors.neutral[200],\n  },\n  filtersContent: {\n    paddingHorizontal: theme.spacing[4],\n    paddingVertical: theme.spacing[2],\n  },\n  filterChip: {\n    paddingHorizontal: theme.spacing[3],\n    paddingVertical: theme.spacing[2],\n    marginRight: theme.spacing[2],\n    borderRadius: theme.borderRadius.full,\n    backgroundColor: theme.colors.neutral[200],\n  },\n  filterChipActive: {\n    backgroundColor: theme.colors.primary[500],\n  },\n  filterChipText: {\n    color: theme.colors.neutral[700],\n  },\n  filterChipTextActive: {\n    color: theme.colors.neutral[50],\n  },\n  errorContainer: {\n    alignItems: 'center',\n    padding: theme.spacing[4],\n    backgroundColor: theme.colors.error[50],\n    marginHorizontal: theme.spacing[4],\n    marginVertical: theme.spacing[2],\n    borderRadius: theme.borderRadius.md,\n  },\n  errorText: {\n    color: theme.colors.error[700],\n    marginBottom: theme.spacing[2],\n    textAlign: 'center',\n  },\n  errorButtonsContainer: {\n    flexDirection: 'row',\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginTop: theme.spacing[2],\n  },\n  retryButton: {\n    minWidth: 80,\n  },\n  listContainer: {\n    flexGrow: 1,\n    paddingBottom: theme.spacing[4],\n  },\n  emptyContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingHorizontal: theme.spacing[6],\n  },\n  emptyTitle: {\n    marginBottom: theme.spacing[2],\n    textAlign: 'center',\n  },\n  emptyMessage: {\n    textAlign: 'center',\n    color: theme.colors.neutral[600],\n    marginBottom: theme.spacing[4],\n  },\n  clearButton: {\n    marginTop: theme.spacing[2],\n  },\n  footerLoader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingVertical: theme.spacing[4],\n  },\n  loadingOverlay: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: 'rgba(255, 255, 255, 0.8)',\n  },\n  loadingText: {\n    marginTop: theme.spacing[2],\n    marginLeft: theme.spacing[2],\n    color: theme.colors.neutral[600],\n  },\n});\n\nexport default ArticlesListScreen;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/screens/main/SettingsScreen.tsx","messages":[{"ruleId":"react-native/no-raw-text","severity":2,"message":"Raw text (Logout) cannot be used outside of a <Text> tag","line":228,"column":14,"nodeType":"JSXText","endLine":230,"endColumn":13},{"ruleId":"react-native/no-raw-text","severity":2,"message":"Raw text (Reset to Defaults) cannot be used outside of a <Text> tag","line":345,"column":18,"nodeType":"JSXText","endLine":347,"endColumn":17}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback } from 'react';\nimport {\n  View,\n  StyleSheet,\n  ScrollView,\n  Switch,\n  Alert,\n  TextInput,\n  TouchableOpacity,\n} from 'react-native';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport { Text } from '../../components/ui/Text';\nimport { Button } from '../../components/ui/Button';\nimport { theme } from '../../components/ui/theme';\nimport { MainScreenProps } from '../../navigation/types';\nimport { RootState } from '../../store';\nimport {\n  updateSyncConfig,\n  resetSyncConfig,\n} from '../../store/slices/syncSlice';\nimport { logoutUser } from '../../store/slices/authSlice';\nimport { SyncSettings } from '../../components/SyncSettings';\n\ntype SettingsScreenProps = MainScreenProps<'Settings'>;\n\ninterface SettingsSectionProps {\n  title: string;\n  children: React.ReactNode;\n}\n\nconst SettingsSection: React.FC<SettingsSectionProps> = ({\n  title,\n  children,\n}) => (\n  <View style={styles.section}>\n    <Text variant='h5' style={styles.sectionTitle}>\n      {title}\n    </Text>\n    <View style={styles.sectionContent}>{children}</View>\n  </View>\n);\n\ninterface SettingsRowProps {\n  label: string;\n  value?: string;\n  children?: React.ReactNode;\n  onPress?: () => void;\n}\n\nconst SettingsRow: React.FC<SettingsRowProps> = ({\n  label,\n  value,\n  children,\n  onPress,\n}) => (\n  <TouchableOpacity\n    style={styles.settingsRow}\n    onPress={onPress}\n    disabled={!onPress}\n    activeOpacity={onPress ? 0.7 : 1}\n  >\n    <View style={styles.settingsRowContent}>\n      <Text variant='body1' style={styles.settingsLabel}>\n        {label}\n      </Text>\n      {value && (\n        <Text variant='body2' style={styles.settingsValue}>\n          {value}\n        </Text>\n      )}\n    </View>\n    {children && <View style={styles.settingsControl}>{children}</View>}\n  </TouchableOpacity>\n);\n\nexport const SettingsScreen: React.FC<SettingsScreenProps> = ({\n  navigation: _navigation,\n}) => {\n  const dispatch = useDispatch();\n  const insets = useSafeAreaInsets();\n\n  const { user, loading: authLoading } = useSelector(\n    (state: RootState) => state.auth\n  );\n  const { config: syncConfig, stats } = useSelector(\n    (state: RootState) => state.sync\n  );\n\n  const [customSyncInterval, setCustomSyncInterval] = useState(\n    syncConfig.syncInterval.toString()\n  );\n  const [showAdvancedSync, setShowAdvancedSync] = useState(false);\n\n  // Sync configuration handlers\n  const handleBackgroundSyncToggle = useCallback(\n    (value: boolean) => {\n      dispatch(updateSyncConfig({ config: { backgroundSyncEnabled: value } }));\n    },\n    [dispatch]\n  );\n\n  const handleWifiOnlyToggle = useCallback(\n    (value: boolean) => {\n      dispatch(\n        updateSyncConfig({\n          config: { syncOnWifiOnly: value, syncOnCellular: !value },\n        })\n      );\n    },\n    [dispatch]\n  );\n\n  const handleDownloadImagesToggle = useCallback(\n    (value: boolean) => {\n      dispatch(updateSyncConfig({ config: { downloadImages: value } }));\n    },\n    [dispatch]\n  );\n\n  const handleFullTextSyncToggle = useCallback(\n    (value: boolean) => {\n      dispatch(updateSyncConfig({ config: { fullTextSync: value } }));\n    },\n    [dispatch]\n  );\n\n  const handleSyncIntervalChange = useCallback(() => {\n    const interval = parseInt(customSyncInterval, 10);\n    if (isNaN(interval) || interval < 1) {\n      Alert.alert(\n        'Invalid Interval',\n        'Please enter a valid sync interval (minimum 1 minute)'\n      );\n      setCustomSyncInterval(syncConfig.syncInterval.toString());\n      return;\n    }\n\n    if (interval > 1440) {\n      Alert.alert(\n        'Invalid Interval',\n        'Sync interval cannot exceed 24 hours (1440 minutes)'\n      );\n      setCustomSyncInterval(syncConfig.syncInterval.toString());\n      return;\n    }\n\n    dispatch(updateSyncConfig({ config: { syncInterval: interval } }));\n  }, [customSyncInterval, dispatch, syncConfig.syncInterval]);\n\n  const handleResetSyncSettings = useCallback(() => {\n    Alert.alert(\n      'Reset Sync Settings',\n      'Are you sure you want to reset all sync settings to default values?',\n      [\n        { text: 'Cancel', style: 'cancel' },\n        {\n          text: 'Reset',\n          style: 'destructive',\n          onPress: () => {\n            dispatch(resetSyncConfig());\n            setCustomSyncInterval('15');\n          },\n        },\n      ]\n    );\n  }, [dispatch]);\n\n  // Account management handlers\n  const handleLogout = useCallback(() => {\n    Alert.alert(\n      'Logout',\n      'Are you sure you want to logout? You will need to enter your credentials again to access your articles.',\n      [\n        { text: 'Cancel', style: 'cancel' },\n        {\n          text: 'Logout',\n          style: 'destructive',\n          onPress: () => dispatch(logoutUser()),\n        },\n      ]\n    );\n  }, [dispatch]);\n\n  const formatLastSync = () => {\n    if (!stats.lastSyncDuration) return 'Never';\n    const duration = Math.round(stats.lastSyncDuration / 1000);\n    return `${duration}s ago`;\n  };\n\n  const formatDataTransfer = () => {\n    const { bytesDownloaded, bytesUploaded } = stats.dataTransfer;\n    const totalMB = (bytesDownloaded + bytesUploaded) / (1024 * 1024);\n    return totalMB > 0.1 ? `${totalMB.toFixed(1)} MB` : '< 0.1 MB';\n  };\n\n  return (\n    <View style={[styles.container, { paddingTop: insets.top }]}>\n      <ScrollView\n        style={styles.scrollView}\n        contentContainerStyle={styles.scrollContent}\n        showsVerticalScrollIndicator={false}\n      >\n        {/* Account Information */}\n        <SettingsSection title='Account'>\n          <SettingsRow\n            label='Server URL'\n            value={user?.serverUrl || 'Not connected'}\n          />\n          <SettingsRow\n            label='Username'\n            value={user?.username || 'Not logged in'}\n          />\n          <SettingsRow\n            label='Last Login'\n            value={\n              user?.lastLoginAt\n                ? new Date(user.lastLoginAt).toLocaleDateString()\n                : 'Never'\n            }\n          />\n          <View style={styles.buttonContainer}>\n            <Button\n              variant='destructive'\n              onPress={handleLogout}\n              loading={authLoading}\n              fullWidth\n            >\n              Logout\n            </Button>\n          </View>\n        </SettingsSection>\n\n        {/* Sync Settings */}\n        <SettingsSection title='Sync Settings'>\n          <SyncSettings />\n\n          <SettingsRow label='Background Sync'>\n            <Switch\n              value={syncConfig.backgroundSyncEnabled}\n              onValueChange={handleBackgroundSyncToggle}\n              trackColor={{\n                false: theme.colors.neutral[300],\n                true: theme.colors.primary[200],\n              }}\n              thumbColor={\n                syncConfig.backgroundSyncEnabled\n                  ? theme.colors.primary[500]\n                  : theme.colors.neutral[400]\n              }\n            />\n          </SettingsRow>\n\n          <SettingsRow label='WiFi Only'>\n            <Switch\n              value={syncConfig.syncOnWifiOnly}\n              onValueChange={handleWifiOnlyToggle}\n              trackColor={{\n                false: theme.colors.neutral[300],\n                true: theme.colors.primary[200],\n              }}\n              thumbColor={\n                syncConfig.syncOnWifiOnly\n                  ? theme.colors.primary[500]\n                  : theme.colors.neutral[400]\n              }\n            />\n          </SettingsRow>\n\n          <SettingsRow label='Download Images'>\n            <Switch\n              value={syncConfig.downloadImages}\n              onValueChange={handleDownloadImagesToggle}\n              trackColor={{\n                false: theme.colors.neutral[300],\n                true: theme.colors.primary[200],\n              }}\n              thumbColor={\n                syncConfig.downloadImages\n                  ? theme.colors.primary[500]\n                  : theme.colors.neutral[400]\n              }\n            />\n          </SettingsRow>\n\n          <SettingsRow label='Full Text Sync'>\n            <Switch\n              value={syncConfig.fullTextSync}\n              onValueChange={handleFullTextSyncToggle}\n              trackColor={{\n                false: theme.colors.neutral[300],\n                true: theme.colors.primary[200],\n              }}\n              thumbColor={\n                syncConfig.fullTextSync\n                  ? theme.colors.primary[500]\n                  : theme.colors.neutral[400]\n              }\n            />\n          </SettingsRow>\n\n          <View style={styles.syncIntervalContainer}>\n            <Text variant='body1' style={styles.settingsLabel}>\n              Sync Interval (minutes)\n            </Text>\n            <View style={styles.syncIntervalInput}>\n              <TextInput\n                style={styles.textInput}\n                value={customSyncInterval}\n                onChangeText={setCustomSyncInterval}\n                onBlur={handleSyncIntervalChange}\n                keyboardType='numeric'\n                placeholder='15'\n                maxLength={4}\n              />\n            </View>\n          </View>\n\n          <TouchableOpacity\n            style={styles.advancedToggle}\n            onPress={() => setShowAdvancedSync(!showAdvancedSync)}\n          >\n            <Text variant='body2' style={styles.advancedToggleText}>\n              {showAdvancedSync ? 'Hide' : 'Show'} Advanced Settings\n            </Text>\n          </TouchableOpacity>\n\n          {showAdvancedSync && (\n            <View style={styles.advancedSettings}>\n              <SettingsRow\n                label='Batch Size'\n                value={`${syncConfig.batchSize} articles`}\n              />\n              <SettingsRow\n                label='Conflict Resolution'\n                value={syncConfig.conflictResolutionStrategy\n                  .replace('_', ' ')\n                  .toLowerCase()}\n              />\n              <View style={styles.buttonContainer}>\n                <Button\n                  variant='outline'\n                  onPress={handleResetSyncSettings}\n                  fullWidth\n                >\n                  Reset to Defaults\n                </Button>\n              </View>\n            </View>\n          )}\n        </SettingsSection>\n\n        {/* Sync Statistics */}\n        <SettingsSection title='Sync Statistics'>\n          <SettingsRow\n            label='Total Syncs'\n            value={stats.totalSyncs.toString()}\n          />\n          <SettingsRow\n            label='Successful Syncs'\n            value={stats.successfulSyncs.toString()}\n          />\n          <SettingsRow\n            label='Failed Syncs'\n            value={stats.failedSyncs.toString()}\n          />\n          <SettingsRow label='Last Sync' value={formatLastSync()} />\n          <SettingsRow label='Data Transferred' value={formatDataTransfer()} />\n          <SettingsRow\n            label='Articles Synced'\n            value={`${stats.itemsSynced.articlesCreated + stats.itemsSynced.articlesUpdated} total`}\n          />\n        </SettingsSection>\n\n        {/* App Information */}\n        <SettingsSection title='About'>\n          <SettingsRow label='App Version' value='1.0.0' />\n          <SettingsRow label='Build' value='Development' />\n        </SettingsSection>\n      </ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: theme.colors.neutral[100],\n  },\n  scrollView: {\n    flex: 1,\n  },\n  scrollContent: {\n    paddingBottom: theme.spacing[6],\n  },\n  section: {\n    marginBottom: theme.spacing[6],\n  },\n  sectionTitle: {\n    paddingHorizontal: theme.spacing[4],\n    paddingVertical: theme.spacing[3],\n    backgroundColor: theme.colors.neutral[200],\n    color: theme.colors.neutral[800],\n    borderTopWidth: 1,\n    borderBottomWidth: 1,\n    borderColor: theme.colors.neutral[300],\n  },\n  sectionContent: {\n    backgroundColor: theme.colors.neutral[50],\n  },\n  settingsRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    paddingHorizontal: theme.spacing[4],\n    paddingVertical: theme.spacing[3],\n    borderBottomWidth: StyleSheet.hairlineWidth,\n    borderBottomColor: theme.colors.neutral[200],\n    minHeight: 56,\n  },\n  settingsRowContent: {\n    flex: 1,\n    marginRight: theme.spacing[3],\n  },\n  settingsLabel: {\n    color: theme.colors.neutral[900],\n    marginBottom: theme.spacing[1],\n  },\n  settingsValue: {\n    color: theme.colors.neutral[600],\n  },\n  settingsControl: {\n    flexShrink: 0,\n  },\n  buttonContainer: {\n    paddingHorizontal: theme.spacing[4],\n    paddingVertical: theme.spacing[3],\n  },\n  syncIntervalContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    paddingHorizontal: theme.spacing[4],\n    paddingVertical: theme.spacing[3],\n    borderBottomWidth: StyleSheet.hairlineWidth,\n    borderBottomColor: theme.colors.neutral[200],\n  },\n  syncIntervalInput: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  textInput: {\n    borderWidth: 1,\n    borderColor: theme.colors.neutral[300],\n    borderRadius: theme.borderRadius.base,\n    paddingHorizontal: theme.spacing[3],\n    paddingVertical: theme.spacing[2],\n    minWidth: 80,\n    textAlign: 'center',\n    fontSize: theme.typography.fontSize.base,\n    color: theme.colors.neutral[900],\n    backgroundColor: theme.colors.neutral[50],\n  },\n  advancedToggle: {\n    paddingHorizontal: theme.spacing[4],\n    paddingVertical: theme.spacing[3],\n    alignItems: 'center',\n  },\n  advancedToggleText: {\n    color: theme.colors.primary[600],\n    textDecorationLine: 'underline',\n  },\n  advancedSettings: {\n    backgroundColor: theme.colors.neutral[100],\n    borderTopWidth: 1,\n    borderBottomWidth: 1,\n    borderColor: theme.colors.neutral[300],\n  },\n});\n\nexport default SettingsScreen;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/services/ArticlesApiService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":92,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2468,2471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2468,2471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":95,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2567,2570],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2567,2570],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":101,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2761,2764],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2761,2764],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2937,2940],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2937,2940],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3071,3074],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3071,3074],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":118,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":118,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3257,3839],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":132,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":132,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3901,4199],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'read_progress' is not in camel case.","line":134,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":134,"endColumn":20},{"ruleId":"camelcase","severity":2,"message":"Identifier 'read_status' is not in camel case.","line":135,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":135,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":145,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":145,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4512,4587],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":164,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":164,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5342,5433],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":169,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":169,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5584,5666],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":182,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":182,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6203,6289],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":209,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":209,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7647,7944],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_archived' is not in camel case.","line":231,"column":51,"nodeType":"Identifier","messageId":"notCamelCase","endLine":231,"endColumn":62},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_marked' is not in camel case.","line":232,"column":51,"nodeType":"Identifier","messageId":"notCamelCase","endLine":232,"endColumn":60},{"ruleId":"camelcase","severity":2,"message":"Identifier 'read_progress' is not in camel case.","line":238,"column":15,"nodeType":"Identifier","messageId":"notCamelCase","endLine":238,"endColumn":28},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_archived' is not in camel case.","line":264,"column":17,"nodeType":"Identifier","messageId":"notCamelCase","endLine":264,"endColumn":28},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_marked' is not in camel case.","line":267,"column":17,"nodeType":"Identifier","messageId":"notCamelCase","endLine":267,"endColumn":26},{"ruleId":"camelcase","severity":2,"message":"Identifier 'read_status' is not in camel case.","line":271,"column":17,"nodeType":"Identifier","messageId":"notCamelCase","endLine":271,"endColumn":28},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":272,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":272,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9879,10033],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'read_status' is not in camel case.","line":274,"column":11,"nodeType":"Identifier","messageId":"notCamelCase","endLine":274,"endColumn":22},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":282,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":282,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10244,10531],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":297,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":297,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10668,10671],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10668,10671],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async arrow function.","line":323,"column":16,"nodeType":"ArrowFunctionExpression","messageId":"missingReturn","endLine":323,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":325,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":325,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11454,11565],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":335,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":335,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11835,12223],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":347,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":347,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12455,12458],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12455,12458],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":348,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":348,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[12485,12878],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":349,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":349,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12606,12609],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12606,12609],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'read_progress' is not in camel case.","line":352,"column":13,"nodeType":"Identifier","messageId":"notCamelCase","endLine":352,"endColumn":26},{"ruleId":"camelcase","severity":2,"message":"Identifier 'computed_isRead' is not in camel case.","line":353,"column":13,"nodeType":"Identifier","messageId":"notCamelCase","endLine":353,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":358,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":358,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12992,12995],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12992,12995],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":358,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":358,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13006,13009],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13006,13009],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":372,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":372,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[13492,13646],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":380,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":380,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[13759,13835],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":394,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":394,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14273,14276],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14273,14276],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":417,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":417,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15243,15246],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15243,15246],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":417,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":417,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15293,15296],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15293,15296],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":418,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":418,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15349,15352],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15349,15352],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":418,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":418,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15385,15388],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15385,15388],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":421,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":421,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15496,15499],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15496,15499],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":423,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":423,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15576,15579],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15576,15579],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":424,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":424,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15645,15648],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15645,15648],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":425,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":425,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15721,15724],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15721,15724],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":432,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":432,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[15923,16026],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":439,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":439,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[16315,16399],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":446,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":446,"endColumn":28,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[16652,16737],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":449,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":449,"endColumn":28,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[16863,17053],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":457,"column":19,"nodeType":"MemberExpression","messageId":"unexpected","endLine":457,"endColumn":30,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[17290,17427],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":463,"column":19,"nodeType":"MemberExpression","messageId":"unexpected","endLine":463,"endColumn":31,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[17718,17811],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":467,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":467,"endColumn":29,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[17912,18052],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":467,"column":121,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":467,"endColumn":124,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18016,18019],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18016,18019],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":476,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":476,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[18307,18404],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":490,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":490,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[18951,19272],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":495,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":495,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19230,19233],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19230,19233],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":502,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":502,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[19357,19593],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":517,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":517,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[19823,19989],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":521,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":521,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20042,20045],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20042,20045],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":535,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":535,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"debug"},"fix":{"range":[20530,20629],"text":""},"desc":"Remove the console.debug()."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async method 'createArticle'.","line":544,"column":9,"nodeType":"FunctionExpression","messageId":"missingReturn","endLine":544,"endColumn":22},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":546,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":546,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[20795,20914],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":561,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":561,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[21304,21406],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async method 'updateArticle'.","line":574,"column":9,"nodeType":"FunctionExpression","messageId":"missingReturn","endLine":574,"endColumn":22},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":576,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":576,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[21645,21779],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":589,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":589,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[22170,22272],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":604,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":604,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[22499,22624],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":614,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":614,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[22762,22863],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async method 'syncArticles'.","line":626,"column":9,"nodeType":"FunctionExpression","messageId":"missingReturn","endLine":626,"endColumn":21},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":630,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":630,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[23124,23186],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'include_deleted' is not in camel case.","line":634,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":634,"endColumn":24},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":641,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":641,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[23488,23569],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":648,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":648,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[23794,23889],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":656,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":656,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[24128,24255],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async method 'getArticle'.","line":669,"column":9,"nodeType":"FunctionExpression","messageId":"missingReturn","endLine":669,"endColumn":19},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":674,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":674,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[24634,24697],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":678,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":678,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[24743,24813],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":686,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":686,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[25128,25208],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":690,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":690,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[25354,25456],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":692,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":692,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[25493,25571],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":700,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":700,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[25740,25912],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":717,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":717,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26166,26245],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":722,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":722,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26392,26491],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":725,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":725,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[26543,26621],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async method 'batchUpdateArticles'.","line":734,"column":9,"nodeType":"FunctionExpression","messageId":"missingReturn","endLine":734,"endColumn":28},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":738,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":738,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26920,27021],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":749,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":749,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[27236,27350],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":764,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":764,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[27590,27663],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":769,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":769,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[27785,27894],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async method 'getArticleStats'.","line":781,"column":9,"nodeType":"FunctionExpression","messageId":"missingReturn","endLine":781,"endColumn":24},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":788,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":788,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[28168,28232],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":792,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":792,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28394,28397],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28394,28397],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":809,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":809,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[28741,28800],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":74,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Articles API Service\n * Bridge between ReadeckApiService and Redux articles slice\n * Handles type conversions and provides interface expected by Redux\n */\n\nimport { readeckApiService } from './ReadeckApiService';\nimport { Article, PaginatedResponse } from '../types';\nimport {\n  ReadeckArticle,\n  ReadeckArticleList,\n  CreateArticleRequest,\n  UpdateArticleRequest,\n  ArticleFilters,\n  ReadeckApiResponse,\n} from '../types/readeck';\nimport { RetryManager } from '../utils/retryManager';\nimport { connectivityManager } from '../utils/connectivityManager';\nimport { cacheService } from './CacheService';\n\n/**\n * Interface for article operations expected by Redux slice\n */\nexport interface IArticlesApiService {\n  fetchArticles(\n    params: FetchArticlesParams\n  ): Promise<PaginatedResponse<Article>>;\n  createArticle(params: CreateArticleParams): Promise<Article>;\n  updateArticle(params: UpdateArticleParams): Promise<Article>;\n  deleteArticle(params: DeleteArticleParams): Promise<void>;\n  syncArticles(\n    params: SyncArticlesParams\n  ): Promise<{ syncedCount: number; conflictCount: number }>;\n}\n\n/**\n * Parameters for article operations\n */\nexport interface FetchArticlesParams {\n  page?: number;\n  limit?: number;\n  searchQuery?: string;\n  filters?: {\n    isArchived?: boolean;\n    isFavorite?: boolean;\n    isRead?: boolean;\n    tags?: string[];\n  };\n  forceRefresh?: boolean;\n  fetchFullContent?: boolean; // Whether to fetch full content for each article\n}\n\nexport interface CreateArticleParams {\n  title: string;\n  url: string;\n  summary?: string;\n  content?: string;\n  tags?: string[];\n}\n\nexport interface UpdateArticleParams {\n  id: string;\n  updates: Partial<Omit<Article, 'id' | 'createdAt' | 'updatedAt'>>;\n}\n\nexport interface DeleteArticleParams {\n  id: string;\n  permanent?: boolean;\n}\n\nexport interface SyncArticlesParams {\n  fullSync?: boolean;\n  articlesOnly?: boolean;\n}\n\n/**\n * ArticlesApiService - Bridge between ReadeckApiService and Redux slice\n *\n * Features:\n * - Type conversion between ReadeckArticle and Article formats\n * - Pagination response transformation\n * - Error handling with proper error propagation\n * - Comprehensive logging for debugging\n * - Consistent interface for Redux async thunks\n */\nclass ArticlesApiService implements IArticlesApiService {\n  /**\n   * Convert ReadeckArticle (snake_case) to Article (camelCase)\n   * @private\n   */\n  private convertReadeckArticleToArticle(\n    readeckArticle: ReadeckArticle | any\n  ): Article {\n    // Helper function to ensure string values\n    const ensureString = (value: any): string => {\n      if (value === null || value === undefined) return '';\n      return String(value);\n    };\n\n    // Helper function to ensure number values\n    const ensureNumber = (value: any): number => {\n      const num = Number(value);\n      return isNaN(num) ? 0 : num;\n    };\n\n    // Helper function to ensure boolean values\n    const ensureBoolean = (value: any): boolean => {\n      return Boolean(value);\n    };\n\n    // Helper function to ensure array values\n    const ensureArray = (value: any): string[] => {\n      if (Array.isArray(value)) return value.map(ensureString);\n      return [];\n    };\n\n    // Debug: Log the raw API response to understand the field structure\n    console.log('[ArticlesApiService] Converting Readeck article:', {\n      id: readeckArticle.id,\n      hasContent: !!readeckArticle.content,\n      hasHtml: !!readeckArticle.html,\n      hasText: !!readeckArticle.text,\n      hasBody: !!readeckArticle.body,\n      hasDescription: !!readeckArticle.description,\n      fieldKeys: Object.keys(readeckArticle),\n      contentPreview: readeckArticle.content?.substring(0, 100) || 'NO_CONTENT',\n      htmlPreview: readeckArticle.html?.substring(0, 100) || 'NO_HTML',\n      textPreview: readeckArticle.text?.substring(0, 100) || 'NO_TEXT'\n    });\n\n    // Debug: Print key fields for read/unread analysis\n    console.log('[ArticlesApiService] Read status analysis:', {\n      id: readeckArticle.id,\n      read_progress: readeckArticle.read_progress,\n      read_status: readeckArticle.read_status,\n      isReadComputed: readeckArticle.read_progress !== undefined && readeckArticle.read_progress >= 100\n    });\n\n    // Extract content from resources.article.src as per Readeck API schema\n    let content = '';\n    \n    // Primary: Check resources.article.src field (URL to article content)\n    if (readeckArticle.resources?.article?.src) {\n      const articleUrl = ensureString(readeckArticle.resources.article.src);\n      console.log('[ArticlesApiService] Found article content URL:', articleUrl);\n      \n      // Note: For now, we'll store the URL and fetch content separately when needed\n      // This prevents blocking the article list loading with individual content fetches\n      content = ''; // Will be fetched on demand\n    }\n    \n    // Fallback: Try other possible content fields if resources.article.src is empty\n    // NOTE: Do NOT use description as content - it's the summary!\n    if (!content && !readeckArticle.resources?.article?.src) {\n      content = ensureString(\n        readeckArticle.content || \n        readeckArticle.content_html || \n        readeckArticle.html || \n        readeckArticle.text || \n        readeckArticle.body ||\n        readeckArticle.cached_content ||\n        '' // Empty content if none found\n      );\n      console.log('[ArticlesApiService] Using fallback content fields, length:', content.length);\n    }\n    \n    // Additional fallback: Check if resource field contains content (legacy support)\n    if (!content && readeckArticle.resource) {\n      console.log('[ArticlesApiService] Checking legacy resource field for content...');\n      if (typeof readeckArticle.resource === 'string' && readeckArticle.resource.length > 200) {\n        // Only use if it looks like actual content, not a short description\n        content = ensureString(readeckArticle.resource);\n      } else if (typeof readeckArticle.resource === 'object') {\n        content = ensureString(\n          readeckArticle.resource.content ||\n          readeckArticle.resource.html ||\n          readeckArticle.resource.data ||\n          readeckArticle.resource.body ||\n          ''\n        );\n      }\n      console.log(`[ArticlesApiService] Legacy resource content length: ${content.length}`);\n    }\n\n    // Handle the updated API field names to match Readeck API documentation\n    const convertedArticle = {\n      id: ensureString(readeckArticle.id),\n      title: ensureString(readeckArticle.title),\n      summary: ensureString(readeckArticle.description),\n      content,\n      url: ensureString(readeckArticle.url),\n      imageUrl: ensureString(\n        readeckArticle.resources?.image?.src || \n        readeckArticle.resources?.thumbnail?.src\n      ),\n      readTime: ensureNumber(readeckArticle.reading_time),\n      isArchived: ensureBoolean(readeckArticle.is_archived),\n      isFavorite: ensureBoolean(readeckArticle.is_marked), // Note: API uses is_marked for favorites\n      isRead: ensureBoolean(readeckArticle.read_progress !== undefined && readeckArticle.read_progress >= 100), // Article is read when progress is 100%\n      tags: ensureArray(readeckArticle.labels), // Note: API uses labels instead of tags\n      sourceUrl: ensureString(readeckArticle.url), // sourceUrl same as url in Readeck\n      createdAt: ensureString(readeckArticle.created || new Date().toISOString()),\n      updatedAt: ensureString(readeckArticle.updated || new Date().toISOString()),\n      syncedAt: new Date().toISOString(),\n      // Store the content URL for on-demand fetching\n      contentUrl: ensureString(readeckArticle.resources?.article?.src),\n    };\n\n    console.log('[ArticlesApiService] Converted article:', {\n      id: convertedArticle.id,\n      title: convertedArticle.title,\n      hasContent: !!convertedArticle.content,\n      contentLength: convertedArticle.content.length,\n      contentPreview: convertedArticle.content.substring(0, 100)\n    });\n\n    return convertedArticle;\n  }\n\n  /**\n   * Convert Article (camelCase) to UpdateArticleRequest (snake_case)\n   * Updated to match Readeck API documentation\n   * @private\n   */\n  private convertArticleToUpdateRequest(\n    updates: Partial<Article>\n  ): UpdateArticleRequest {\n    const request: UpdateArticleRequest = {};\n\n    if (updates.title !== undefined) request.title = updates.title;\n    if (updates.isArchived !== undefined) request.is_archived = updates.isArchived;\n    if (updates.isFavorite !== undefined) request.is_marked = updates.isFavorite; // Note: API uses is_marked\n    if (updates.tags !== undefined) request.labels = updates.tags; // Note: API uses labels\n\n    // Note: isRead is not directly supported in Readeck API\n    // Read status is tracked via read_progress instead\n    if (updates.isRead !== undefined) {\n      request.read_progress = updates.isRead ? 100 : 0;\n    }\n\n    return request;\n  }\n\n  /**\n   * Convert filters to ArticleFilters format\n   * Updated to match Readeck API documentation\n   * @private\n   */\n  private convertFiltersToReadeckFilters(\n    params: FetchArticlesParams\n  ): ArticleFilters {\n    const filters: ArticleFilters = {\n      limit: params.limit || 20,\n      offset: ((params.page || 1) - 1) * (params.limit || 20), // Convert page to offset\n      sort: ['-created'], // Default sort by created date descending\n    };\n\n    if (params.searchQuery) {\n      filters.search = params.searchQuery;\n    }\n\n    if (params.filters) {\n      if (params.filters.isArchived !== undefined) {\n        filters.is_archived = params.filters.isArchived;\n      }\n      if (params.filters.isFavorite !== undefined) {\n        filters.is_marked = params.filters.isFavorite; // Note: API uses is_marked\n      }\n      if (params.filters.isRead !== undefined) {\n        // Map isRead to read_status array\n        filters.read_status = params.filters.isRead ? ['read'] : ['unread', 'reading'];\n        console.log('[ArticlesApiService] Read filter applied:', {\n          isRead: params.filters.isRead,\n          read_status: filters.read_status\n        });\n      }\n      if (params.filters.tags && params.filters.tags.length > 0) {\n        filters.labels = params.filters.tags.join(','); // Note: API uses labels and expects comma-separated string\n      }\n    }\n\n    console.log('[ArticlesApiService] Final filters being sent to API:', {\n      ...filters,\n      'FILTER_ANALYSIS': {\n        hasReadFilter: filters.read_status !== undefined,\n        readFilterValue: filters.read_status,\n        originalIsReadParam: params.filters?.isRead\n      }\n    });\n    return filters;\n  }\n\n  /**\n   * Handle API errors with proper error propagation\n   * @private\n   */\n  private handleApiError(error: any, operation: string): never {\n    // Don't log here as error will be handled by calling code\n    if (error.code && error.message) {\n      // ReadeckApiError - pass through\n      throw error;\n    } else {\n      // Unknown error - wrap in standard format\n      throw new Error(`${operation} failed: ${error.message || String(error)}`);\n    }\n  }\n\n  /**\n   * Fetch articles with pagination and filtering\n   */\n  async fetchArticles(\n    params: FetchArticlesParams\n  ): Promise<PaginatedResponse<Article>> {\n    // Check connectivity first\n    if (!connectivityManager.isOnline()) {\n      throw {\n        code: 'CONNECTION_ERROR',\n        message: 'Cannot fetch articles while offline',\n      };\n    }\n    \n    return RetryManager.withRetry(\n      async () => {\n        try {\n          console.log(\n            '[ArticlesApiService] Fetching articles with params:',\n            params\n          );\n\n          const filters = this.convertFiltersToReadeckFilters(params);\n          const response: ReadeckApiResponse<ReadeckArticleList> =\n            await readeckApiService.getArticles(filters);\n\n      // Debug log the response structure and first few articles\n      console.log('[ArticlesApiService] API Response structure:', {\n        hasResponse: !!response,\n        hasData: !!response?.data,\n        dataType: Array.isArray(response?.data) ? 'array' : typeof response?.data,\n        dataKeys: response?.data && typeof response.data === 'object' ? Object.keys(response.data) : [],\n        filtersSent: filters,\n        paramsReceived: params\n      });\n\n      // Log the first few articles to see their read status\n      if (response?.data) {\n        const articles = Array.isArray(response.data) ? response.data : \n                        response.data.articles || (response.data as any).bookmarks || [];\n        console.log('[ArticlesApiService] First 3 articles read status analysis:', \n          articles.slice(0, 3).map((article: any) => ({\n            id: article.id,\n            title: `${article.title?.substring(0, 50)  }...`,\n            read_progress: article.read_progress,\n            computed_isRead: article.read_progress !== undefined && article.read_progress >= 100\n          }))\n        );\n        \n        // Summary of all articles' read status\n        const readStatusSummary = articles.reduce((acc: any, article: any) => {\n          const progress = article.read_progress;\n          if (progress === undefined || progress === null) {\n            acc.undefined++;\n          } else if (progress === 0) {\n            acc.zero++;\n          } else if (progress > 0 && progress < 100) {\n            acc.inProgress++;\n          } else if (progress >= 100) {\n            acc.completed++;\n          }\n          return acc;\n        }, { undefined: 0, zero: 0, inProgress: 0, completed: 0 });\n        \n        console.log('[ArticlesApiService] Read progress summary for all articles:', {\n          total: articles.length,\n          ...readStatusSummary\n        });\n      }\n\n      // Check if response has the expected structure\n      if (!response || !response.data) {\n        console.error('[ArticlesApiService] Invalid response structure:', response);\n        throw new Error('Invalid response from server');\n      }\n\n      // Handle different possible response formats from Readeck API\n      let articles: Article[] = [];\n      let pagination = {\n        page: 1,\n        totalPages: 1,\n        totalItems: 0,\n      };\n\n      // Check if response.data is an array (direct bookmarks response)\n      if (Array.isArray(response.data)) {\n        articles = response.data.map((readeckArticle: any) =>\n          this.convertReadeckArticleToArticle(readeckArticle)\n        );\n        pagination = {\n          page: params.page || 1,\n          totalPages: 1,\n          totalItems: articles.length,\n        };\n      } \n      // Check if response.data has articles property (as per ReadeckArticleList type)\n      else if (response.data.articles && Array.isArray(response.data.articles)) {\n        articles = response.data.articles.map(readeckArticle =>\n          this.convertReadeckArticleToArticle(readeckArticle)\n        );\n        if (response.data.pagination) {\n          pagination = {\n            page: response.data.pagination.page || 1,\n            totalPages: response.data.pagination.total_pages || 1,\n            totalItems: response.data.pagination.total_count || articles.length,\n          };\n        }\n      }\n      // Check if response.data has bookmarks property (alternative naming - some API versions might use this)\n      else if ((response.data as any).bookmarks && Array.isArray((response.data as any).bookmarks)) {\n        articles = (response.data as any).bookmarks.map((readeckArticle: any) =>\n          this.convertReadeckArticleToArticle(readeckArticle)\n        );\n        if ((response.data as any).pagination) {\n          pagination = {\n            page: (response.data as any).pagination.page || 1,\n            totalPages: (response.data as any).pagination.total_pages || 1,\n            totalItems: (response.data as any).pagination.total_count || articles.length,\n          };\n        }\n      }\n\n      // Fetch full content for articles if requested and content is missing\n      if (params.fetchFullContent) {\n        console.log('[ArticlesApiService] fetchFullContent enabled, checking articles for missing content...');\n        \n        const articlesWithFullContent = await Promise.all(\n          articles.map(async (article) => {\n            // Check cache first\n            const cachedArticle = cacheService.getArticle(article.id);\n            if (cachedArticle && cachedArticle.content) {\n              console.log(`[ArticlesApiService] Using cached content for article: ${article.id}`);\n              return { ...article, content: cachedArticle.content };\n            }\n            \n            // Check if article needs full content\n            if (!article.content || article.content.trim() === '') {\n              try {\n                console.log(`[ArticlesApiService] Fetching full content for article: ${article.id}`);\n                const fullContentResponse = await readeckApiService.getArticle(article.id);\n                \n                console.log(`[ArticlesApiService] Full content response:`, {\n                  hasData: !!fullContentResponse?.data,\n                  status: fullContentResponse?.status\n                });\n                \n                if (fullContentResponse.data) {\n                  // Convert and merge full content\n                  const fullArticle = this.convertReadeckArticleToArticle(fullContentResponse.data);\n                  console.log(`[ArticlesApiService] Full content fetched for article: ${article.id}, content length: ${fullArticle.content?.length || 0}`);\n                  const updatedArticle = { ...article, content: fullArticle.content };\n                  // Cache the complete article\n                  cacheService.setArticle(article.id, updatedArticle);\n                  return updatedArticle;\n                } else {\n                  console.warn(`[ArticlesApiService] Failed to fetch full content for article: ${article.id}`);\n                  return article;\n                }\n              } catch (error) {\n                console.warn(`[ArticlesApiService] Failed to fetch full content for article: ${article.id}: ${(error as any)?.message || 'Unknown error'}`);\n                return article; // Return original article if fetch fails\n              }\n            }\n            return article; // Return original if content exists\n          })\n        );\n        \n        articles = articlesWithFullContent;\n        console.log(`[ArticlesApiService] Completed full content fetch for ${articles.length} articles`);\n      }\n\n      // Client-side filtering as fallback for read/unread status\n      // This ensures filtering works even if the API doesn't properly filter server-side\n      if (params.filters?.isRead !== undefined) {\n        const originalCount = articles.length;\n        const targetReadStatus = params.filters.isRead;\n        \n        articles = articles.filter(article => {\n          const articleIsRead = article.isRead;\n          const shouldInclude = articleIsRead === targetReadStatus;\n          \n          if (!shouldInclude) {\n            console.log(`[ArticlesApiService] Client-side filter excluding article:`, {\n              id: article.id,\n              title: `${article.title?.substring(0, 30)  }...`,\n              isRead: articleIsRead,\n              targetReadStatus,\n              readProgress: (article as any).readProgress || 'N/A'\n            });\n          }\n          \n          return shouldInclude;\n        });\n        \n        console.log(`[ArticlesApiService] Client-side read filter applied:`, {\n          originalCount,\n          filteredCount: articles.length,\n          targetReadStatus,\n          articlesRemoved: originalCount - articles.length\n        });\n      }\n\n      const paginatedResponse: PaginatedResponse<Article> = {\n        items: articles,\n        page: pagination.page,\n        totalPages: pagination.totalPages,\n        totalItems: pagination.totalItems,\n      };\n\n      console.log(\n        `[ArticlesApiService] Successfully fetched ${articles.length} articles (page ${paginatedResponse.page}/${paginatedResponse.totalPages})`\n      );\n      return paginatedResponse;\n    } catch (error: any) {\n      // Check for connection errors and provide better error messages\n      if (error?.code === 'CONNECTION_ERROR' || error?.code === 'ECONNREFUSED') {\n        throw {\n          code: 'CONNECTION_ERROR',\n          message: 'Unable to connect to server. Please check your internet connection and server settings.',\n        };\n      }\n      this.handleApiError(error, 'Fetch articles');\n    }\n      },\n      {\n        maxRetries: 3,\n        onRetry: (error, attempt) => {\n          console.debug(`[ArticlesApiService] Retrying fetch articles (attempt ${attempt}):`, error.message);\n        },\n      }\n    );\n  }\n\n  /**\n   * Create a new article from URL\n   */\n  async createArticle(params: CreateArticleParams): Promise<Article> {\n    try {\n      console.log('[ArticlesApiService] Creating article:', {\n        url: params.url,\n        title: params.title,\n      });\n\n      const createRequest: CreateArticleRequest = {\n        url: params.url,\n        title: params.title,\n        labels: params.tags, // Note: API uses labels instead of tags\n      };\n\n      const response: ReadeckApiResponse<ReadeckArticle> =\n        await readeckApiService.createArticle(createRequest);\n      const article = this.convertReadeckArticleToArticle(response.data);\n\n      console.log(\n        '[ArticlesApiService] Successfully created article:',\n        article.id\n      );\n      return article;\n    } catch (error) {\n      this.handleApiError(error, 'Create article');\n    }\n  }\n\n  /**\n   * Update an existing article\n   */\n  async updateArticle(params: UpdateArticleParams): Promise<Article> {\n    try {\n      console.log('[ArticlesApiService] Updating article:', {\n        id: params.id,\n        updates: Object.keys(params.updates),\n      });\n\n      const updateRequest = this.convertArticleToUpdateRequest(params.updates);\n      const response: ReadeckApiResponse<ReadeckArticle> =\n        await readeckApiService.updateArticle(params.id, updateRequest);\n      const article = this.convertReadeckArticleToArticle(response.data);\n\n      // Update cache with new article data\n      cacheService.setArticle(params.id, article);\n\n      console.log(\n        '[ArticlesApiService] Successfully updated article:',\n        article.id\n      );\n      return article;\n    } catch (error) {\n      this.handleApiError(error, 'Update article');\n    }\n  }\n\n  /**\n   * Delete an article\n   */\n  async deleteArticle(params: DeleteArticleParams): Promise<void> {\n    try {\n      console.log('[ArticlesApiService] Deleting article:', {\n        id: params.id,\n        permanent: params.permanent,\n      });\n\n      await readeckApiService.deleteArticle(params.id);\n\n      // Remove from cache\n      cacheService.deleteArticle(params.id);\n\n      console.log(\n        '[ArticlesApiService] Successfully deleted article:',\n        params.id\n      );\n    } catch (error) {\n      this.handleApiError(error, 'Delete article');\n    }\n  }\n\n  /**\n   * Sync articles with server\n   */\n  async syncArticles(\n    params: SyncArticlesParams\n  ): Promise<{ syncedCount: number; conflictCount: number }> {\n    try {\n      console.log('[ArticlesApiService] Syncing articles:', params);\n\n      const syncRequest = {\n        limit: params.fullSync ? undefined : 100,\n        include_deleted: params.fullSync || false,\n      };\n\n      const response = await readeckApiService.syncArticles(syncRequest);\n\n      // Validate response structure\n      if (!response || !response.data) {\n        console.error('[ArticlesApiService] Invalid sync response structure:', response);\n        throw new Error('Invalid sync response from server');\n      }\n\n      // Safely access articles array with validation\n      const articles = response.data.articles || [];\n      if (!Array.isArray(articles)) {\n        console.error('[ArticlesApiService] Expected articles array, got:', typeof articles, articles);\n        throw new Error('Invalid articles data in sync response');\n      }\n\n      // Calculate sync metrics\n      const syncedCount = articles.length;\n      const conflictCount = 0; // Readeck API doesn't report conflicts directly\n\n      console.log(\n        `[ArticlesApiService] Sync completed: ${syncedCount} articles synced, ${conflictCount} conflicts`\n      );\n\n      return { syncedCount, conflictCount };\n    } catch (error) {\n      this.handleApiError(error, 'Sync articles');\n    }\n  }\n\n  /**\n   * Get a single article by ID\n   */\n  async getArticle(id: string): Promise<Article> {\n    try {\n      // Check cache first for optimal performance\n      const cachedArticle = cacheService.getArticle(id);\n      if (cachedArticle) {\n        console.log('[ArticlesApiService] Cache hit for article:', id);\n        return cachedArticle;\n      }\n\n      console.log('[ArticlesApiService] Cache miss, fetching article:', id);\n\n      const response: ReadeckApiResponse<ReadeckArticle> =\n        await readeckApiService.getArticle(id);\n      const article = this.convertReadeckArticleToArticle(response.data);\n\n      // If article has a contentUrl but no content, fetch the content\n      if (article.contentUrl && !article.content) {\n        console.log('[ArticlesApiService] Article has contentUrl, fetching content...');\n        try {\n          const htmlContent = await this.getArticleContent(article.contentUrl);\n          article.content = htmlContent;\n          console.log('[ArticlesApiService] Successfully fetched article content, length:', htmlContent.length);\n        } catch (error) {\n          console.error('[ArticlesApiService] Failed to fetch article content:', error);\n          // Continue without content on error\n        }\n      }\n\n      // Cache the article for subsequent requests\n      cacheService.setArticle(id, article);\n\n      console.log(\n        '[ArticlesApiService] Successfully fetched article:',\n        article.id,\n        'with content length:',\n        article.content?.length || 0\n      );\n      return article;\n    } catch (error) {\n      this.handleApiError(error, 'Get article');\n    }\n  }\n\n  /**\n   * Fetch article content from the article content URL\n   */\n  async getArticleContent(contentUrl: string): Promise<string> {\n    try {\n      console.log('[ArticlesApiService] Fetching article content from:', contentUrl);\n\n      // Use the readeck API service to fetch content\n      const response = await readeckApiService.getArticleContent(contentUrl);\n      \n      console.log('[ArticlesApiService] Successfully fetched article content, length:', response.length);\n      return response;\n    } catch (error) {\n      console.error('[ArticlesApiService] Failed to fetch article content:', error);\n      this.handleApiError(error, 'Get article content');\n      return ''; // Return empty string on error\n    }\n  }\n\n  /**\n   * Batch update multiple articles\n   */\n  async batchUpdateArticles(\n    updates: Array<{ id: string; updates: Partial<Article> }>\n  ): Promise<Article[]> {\n    try {\n      console.log(\n        '[ArticlesApiService] Batch updating articles:',\n        updates.length\n      );\n\n      const updatePromises = updates.map(({ id, updates: articleUpdates }) =>\n        this.updateArticle({ id, updates: articleUpdates })\n      );\n\n      const articles = await Promise.all(updatePromises);\n\n      console.log(\n        '[ArticlesApiService] Successfully batch updated articles:',\n        articles.length\n      );\n      return articles;\n    } catch (error) {\n      this.handleApiError(error, 'Batch update articles');\n    }\n  }\n\n  /**\n   * Batch delete multiple articles\n   */\n  async batchDeleteArticles(ids: string[]): Promise<void> {\n    try {\n      console.log('[ArticlesApiService] Batch deleting articles:', ids.length);\n\n      const deletePromises = ids.map(id => this.deleteArticle({ id }));\n      await Promise.all(deletePromises);\n\n      console.log(\n        '[ArticlesApiService] Successfully batch deleted articles:',\n        ids.length\n      );\n    } catch (error) {\n      this.handleApiError(error, 'Batch delete articles');\n    }\n  }\n\n  /**\n   * Get article statistics\n   */\n  async getArticleStats(): Promise<{\n    total: number;\n    read: number;\n    favorite: number;\n    archived: number;\n  }> {\n    try {\n      console.log('[ArticlesApiService] Fetching article statistics');\n\n      // Fetch user profile which contains article stats\n      const response = await readeckApiService.getUserProfile();\n      const stats = (response.data as any).stats;\n\n      return {\n        total: stats.total_articles,\n        read: stats.read_articles,\n        favorite: stats.favorite_articles,\n        archived: stats.archived_articles,\n      };\n    } catch (error) {\n      this.handleApiError(error, 'Get article stats');\n    }\n  }\n\n  /**\n   * Clear article cache\n   */\n  clearCache(): void {\n    console.log('[ArticlesApiService] Clearing article cache');\n    cacheService.clearArticles();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats() {\n    return cacheService.getStats().articles;\n  }\n}\n\n// Export singleton instance for consistent usage across the app\nexport const articlesApiService = new ArticlesApiService();\n\n// Export class for testing and custom instantiation\nexport default ArticlesApiService;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/services/AuthStorageService.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":178,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":178,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[5999,6119],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":221,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":221,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[7266,7365],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":303,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":303,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9391,9394],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9391,9394],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":340,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":340,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10442,10445],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10442,10445],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":379,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":379,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11588,11591],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11588,11591],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Secure token storage service using react-native-keychain\n * Provides encrypted API token storage with comprehensive error handling\n */\n\nimport * as Keychain from 'react-native-keychain';\nimport {\n  IAuthStorageService,\n  AuthToken,\n  StorageError,\n  StorageErrorCode,\n  TokenValidationResult,\n  KeychainOptions,\n  AuthenticatedUser,\n} from '../types/auth';\n\n// Enhanced storage data that includes user info\ninterface AuthStorageData extends AuthToken {\n  user?: {\n    id: string;\n    username: string;\n    email: string;\n    lastLoginAt: string;\n  };\n}\nimport { generateSecureRandom, hashData } from '../utils/security';\nimport { logger } from '../utils/logger';\n\n/**\n * AuthStorageService - Secure token management using device keychain\n *\n * Features:\n * - Encrypted token storage using react-native-keychain\n * - Comprehensive error handling and recovery\n * - Token validation and expiration checking\n * - Graceful fallback for keychain unavailability\n */\nclass AuthStorageService implements IAuthStorageService {\n  private readonly SERVICE_NAME = 'mobdeck_auth_tokens';\n  private readonly USERNAME_KEY = 'api_token';\n  private readonly TOKEN_VERSION = '1.0';\n  private readonly MAX_TOKEN_AGE = 90 * 24 * 60 * 60 * 1000; // 90 days in ms\n  private tokenRotationEnabled = true;\n  private lastRotationCheck: Date | null = null;\n\n  private readonly keychainOptions: KeychainOptions = {\n    service: this.SERVICE_NAME,\n    accessible: Keychain.ACCESSIBLE.WHEN_UNLOCKED_THIS_DEVICE_ONLY,\n    touchID: false, // Will be configurable later\n    showModal: false,\n    authenticatePrompt: 'Authenticate to access your Readeck account',\n    biometryType: Keychain.BIOMETRY_TYPE.BIOMETRICS,\n    authenticationPrompt: 'Biometric authentication required',\n  };\n\n  /**\n   * Store API token and user data securely in device keychain\n   * @param token - API token string to store\n   * @param user - Optional user data to store with token\n   * @returns Promise<boolean> - Success status\n   */\n  storeToken = async (token: string, user?: AuthenticatedUser): Promise<boolean> => {\n    try {\n      if (!token || typeof token !== 'string' || token.trim().length === 0) {\n        logger.error('Invalid token provided for storage');\n        return false;\n      }\n\n      // Flexible token validation for Readeck API tokens\n      const trimmedToken = token.trim();\n      \n      // Basic validation: must be at least 10 characters\n      if (trimmedToken.length < 10) {\n        logger.error('Token too short for storage');\n        return false;\n      }\n      \n      // Maximum length validation for security\n      if (trimmedToken.length > 4096) {\n        logger.error('Token too long for storage');\n        return false;\n      }\n      \n      // Create token metadata with security enhancements\n      const tokenData: AuthStorageData = {\n        token: trimmedToken,\n        expiresAt: this.calculateTokenExpiration(trimmedToken),\n        issuedAt: new Date().toISOString(),\n        serverUrl: user?.serverUrl || '',\n        version: this.TOKEN_VERSION,\n        checksum: hashData(trimmedToken, generateSecureRandom(16)),\n        user: user ? {\n          id: user.id,\n          username: user.username,\n          email: user.email,\n          lastLoginAt: user.lastLoginAt,\n        } : undefined,\n      };\n\n      const result = await Keychain.setInternetCredentials(\n        this.SERVICE_NAME,\n        this.USERNAME_KEY,\n        JSON.stringify(tokenData),\n        this.keychainOptions\n      );\n\n      if (result) {\n        logger.info('Token stored successfully', { version: this.TOKEN_VERSION });\n        // Schedule token rotation check\n        this.scheduleTokenRotationCheck();\n        return true;\n      } else {\n        logger.error('Failed to store token in keychain');\n        return false;\n      }\n    } catch (error) {\n      const storageError = this.handleStorageError(\n        error,\n        StorageErrorCode.STORAGE_FAILED\n      );\n      logger.error('Token storage failed', { error: storageError });\n      return false;\n    }\n  };\n\n  /**\n   * Retrieve API token from secure keychain storage\n   * @returns Promise<string | null> - Token string or null if not found\n   */\n  retrieveToken = async (): Promise<string | null> => {\n    const data = await this.retrieveAuthData();\n    return data?.token || null;\n  };\n\n  /**\n   * Retrieve complete authentication data from secure keychain storage\n   * @returns Promise<AuthStorageData | null> - Auth data or null if not found\n   */\n  retrieveAuthData = async (): Promise<AuthStorageData | null> => {\n    try {\n      const credentials = await Keychain.getInternetCredentials(\n        this.SERVICE_NAME\n      );\n\n      if (credentials && credentials.password) {\n        try {\n          const authData: AuthStorageData = JSON.parse(credentials.password);\n\n          // Validate token structure and integrity\n          if (this.isValidAuthData(authData)) {\n            // Check token version compatibility\n            if (!this.isTokenVersionCompatible(authData)) {\n              logger.warn('Token version incompatible, migration required');\n              // Future: Implement token migration\n            }\n\n            // Verify token checksum if available\n            if (authData.checksum && !this.verifyTokenChecksum(authData)) {\n              logger.error('Token checksum verification failed');\n              await this.deleteToken(); // Clean up tampered data\n              return null;\n            }\n\n            // Check if token needs rotation\n            if (this.tokenRotationEnabled && this.shouldRotateToken(authData)) {\n              logger.info('Token rotation recommended');\n              // Future: Implement token rotation\n            }\n\n            logger.debug('Auth data retrieved successfully');\n            return authData;\n          } else {\n            logger.error('Invalid auth data structure');\n            await this.deleteToken(); // Clean up invalid data\n            return null;\n          }\n        } catch (parseError) {\n          console.error(\n            '[AuthStorageService] Failed to parse stored auth data:',\n            parseError\n          );\n          await this.deleteToken(); // Clean up corrupted data\n          return null;\n        }\n      } else {\n        logger.debug('No auth data found in keychain');\n        return null;\n      }\n    } catch (error) {\n      const storageError = this.handleStorageError(\n        error,\n        StorageErrorCode.RETRIEVAL_FAILED\n      );\n      logger.error('Token retrieval failed', { error: storageError });\n      return null;\n    }\n  };\n\n  /**\n   * Delete API token from secure storage\n   * @returns Promise<boolean> - Success status\n   */\n  deleteToken = async (): Promise<boolean> => {\n    try {\n      const result = await Keychain.resetInternetCredentials(this.SERVICE_NAME);\n\n      if (result) {\n        logger.info('Token deleted successfully');\n        // Clear rotation check\n        this.lastRotationCheck = null;\n        return true;\n      } else {\n        logger.warn('Token deletion completed (may not have existed)');\n        return true; // Consider success if no token to delete\n      }\n    } catch (error) {\n      const storageError = this.handleStorageError(\n        error,\n        StorageErrorCode.DELETION_FAILED\n      );\n      console.error(\n        '[AuthStorageService] Token deletion failed:',\n        storageError\n      );\n      return false;\n    }\n  };\n\n  /**\n   * Check if an API token is stored in keychain\n   * @returns Promise<boolean> - True if token exists\n   */\n  isTokenStored = async (): Promise<boolean> => {\n    try {\n      const credentials = await Keychain.getInternetCredentials(\n        this.SERVICE_NAME\n      );\n      const hasToken = !!(credentials && credentials.password);\n\n      logger.debug('Token existence check', { hasToken });\n      return hasToken;\n    } catch (error) {\n      logger.error('Token existence check failed', { error });\n      return false;\n    }\n  };\n\n  /**\n   * Validate stored token and check expiration\n   * @returns Promise<TokenValidationResult> - Validation results\n   */\n  validateStoredToken = async (): Promise<TokenValidationResult> => {\n    try {\n      const credentials = await Keychain.getInternetCredentials(\n        this.SERVICE_NAME\n      );\n\n      if (!credentials || !credentials.password) {\n        return {\n          isValid: false,\n          isExpired: true,\n          error: 'No token found in storage',\n        };\n      }\n\n      const authData: AuthStorageData = JSON.parse(credentials.password);\n\n      if (!this.isValidAuthData(authData)) {\n        return {\n          isValid: false,\n          isExpired: true,\n          error: 'Invalid auth data structure',\n        };\n      }\n\n      const expirationDate = new Date(authData.expiresAt);\n      const currentDate = new Date();\n      const isExpired = expirationDate <= currentDate;\n      const expiresIn = isExpired\n        ? 0\n        : Math.floor((expirationDate.getTime() - currentDate.getTime()) / 1000);\n\n      return {\n        isValid: !isExpired,\n        isExpired,\n        expiresIn,\n      };\n    } catch (error) {\n      logger.error('Token validation failed', { error });\n      return {\n        isValid: false,\n        isExpired: true,\n        error: 'Token validation failed',\n      };\n    }\n  };\n\n  /**\n   * Handle storage errors with proper categorization\n   * @private\n   */\n  private handleStorageError = (\n    error: any,\n    defaultCode: StorageErrorCode\n  ): StorageError => {\n    let code = defaultCode;\n    let message = 'Unknown storage error occurred';\n    let details = '';\n\n    if (error) {\n      details = error.message || String(error);\n\n      // Categorize specific keychain errors\n      if (details.includes('UserCancel')) {\n        code = StorageErrorCode.USER_CANCELLED;\n        message = 'User cancelled keychain access';\n      } else if (details.includes('BiometryNotAvailable')) {\n        code = StorageErrorCode.BIOMETRIC_UNAVAILABLE;\n        message = 'Biometric authentication not available';\n      } else if (details.includes('KeychainError')) {\n        code = StorageErrorCode.KEYCHAIN_UNAVAILABLE;\n        message = 'Device keychain unavailable';\n      } else {\n        message = `Storage operation failed: ${details}`;\n      }\n    }\n\n    return {\n      code,\n      message,\n      details,\n      timestamp: new Date().toISOString(),\n    };\n  };\n\n  /**\n   * Validate auth data structure\n   * @private\n   */\n  private isValidAuthData = (authData: any): authData is AuthStorageData => {\n    return (\n      authData &&\n      typeof authData === 'object' &&\n      typeof authData.token === 'string' &&\n      typeof authData.expiresAt === 'string' &&\n      typeof authData.issuedAt === 'string' &&\n      authData.token.trim().length > 0\n    );\n  };\n\n  /**\n   * Calculate token expiration (default 24 hours)\n   * @private\n   */\n  private calculateTokenExpiration = (token: string): string => {\n    // Try to extract expiration from JWT token if it's a JWT\n    try {\n      const tokenParts = token.split('.');\n      if (tokenParts.length === 3) {\n        const payload = JSON.parse(atob(tokenParts[1]));\n        if (payload.exp) {\n          return new Date(payload.exp * 1000).toISOString();\n        }\n      }\n    } catch (error) {\n      // Not a JWT or parsing failed, use default expiration\n    }\n\n    // Default to 24 hours from now\n    const expirationDate = new Date();\n    expirationDate.setHours(expirationDate.getHours() + 24);\n    return expirationDate.toISOString();\n  };\n\n  /**\n   * Check if token version is compatible\n   * @private\n   */\n  private isTokenVersionCompatible = (authData: any): boolean => {\n    if (!authData.version) {\n      return true; // Legacy tokens without version are accepted\n    }\n    return authData.version === this.TOKEN_VERSION;\n  };\n\n  /**\n   * Verify token checksum for integrity\n   * @private\n   */\n  private verifyTokenChecksum = (authData: AuthStorageData): boolean => {\n    if (!authData.checksum) {\n      return true; // Legacy tokens without checksum are accepted\n    }\n    // Checksum verification would require the original salt\n    // For now, we'll trust the checksum presence as a security indicator\n    return true;\n  };\n\n  /**\n   * Check if token should be rotated\n   * @private\n   */\n  private shouldRotateToken = (authData: AuthStorageData): boolean => {\n    const issuedAt = new Date(authData.issuedAt);\n    const now = new Date();\n    const tokenAge = now.getTime() - issuedAt.getTime();\n    \n    // Rotate if token is older than MAX_TOKEN_AGE\n    return tokenAge > this.MAX_TOKEN_AGE;\n  };\n\n  /**\n   * Schedule token rotation check\n   * @private\n   */\n  private scheduleTokenRotationCheck = (): void => {\n    this.lastRotationCheck = new Date();\n    // Future: Implement background rotation check\n  };\n\n  /**\n   * Enable biometric authentication for token access\n   */\n  enableBiometricAuth = async (): Promise<boolean> => {\n    try {\n      const biometryType = await Keychain.getSupportedBiometryType();\n      if (biometryType) {\n        this.keychainOptions.touchID = true;\n        this.keychainOptions.biometryType = biometryType;\n        logger.info('Biometric authentication enabled', { type: biometryType });\n        return true;\n      } else {\n        logger.warn('Biometric authentication not available on this device');\n        return false;\n      }\n    } catch (error) {\n      logger.error('Failed to enable biometric authentication', { error });\n      return false;\n    }\n  };\n\n  /**\n   * Disable biometric authentication\n   */\n  disableBiometricAuth = (): void => {\n    this.keychainOptions.touchID = false;\n    logger.info('Biometric authentication disabled');\n  };\n\n  /**\n   * Get current security configuration\n   */\n  getSecurityConfig = async (): Promise<{\n    biometricEnabled: boolean;\n    biometricType: string | null;\n    tokenRotationEnabled: boolean;\n    lastRotationCheck: Date | null;\n  }> => {\n    const biometryType = await Keychain.getSupportedBiometryType();\n    return {\n      biometricEnabled: this.keychainOptions.touchID || false,\n      biometricType: biometryType,\n      tokenRotationEnabled: this.tokenRotationEnabled,\n      lastRotationCheck: this.lastRotationCheck,\n    };\n  };\n}\n\n// Export singleton instance for consistent usage across the app\nexport const authStorageService = new AuthStorageService();\n\n// Export class for testing and custom instantiation\nexport default AuthStorageService;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/services/BackgroundSyncService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2108,2111],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2108,2111],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":101,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":101,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2794,2853],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":106,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":106,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2891,2946],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":126,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":126,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3405,3469],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":128,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":128,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[3498,3568],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":155,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":155,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[4344,4444],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":172,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":172,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[4713,4813],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":201,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":201,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5457,5460],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5457,5460],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":202,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":202,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5475,5543],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":210,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":210,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5753,5756],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5753,5756],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":211,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":211,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5771,5839],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":224,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":224,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6110,6181],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":234,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":234,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6376,6443],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":236,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":236,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[6472,6578],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":249,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":249,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6770,6840],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":253,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":253,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6956,7026],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":256,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":256,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7065,7176],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":289,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":289,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7893,8014],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":312,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":312,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8534,8637],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":323,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":323,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8817,8879],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":332,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":332,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9079,9151],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":344,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":344,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9416,9492],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":390,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":390,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10822,10825],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10822,10825],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":433,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":433,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[12362,12485],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":444,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":444,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[12766,12890],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":454,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":454,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[13062,13135],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":468,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":468,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[13432,13497],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":470,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":470,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[13526,13597],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":478,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":478,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[13722,13789],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":493,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":493,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[14168,14245],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":499,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":499,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[14361,14456],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":507,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":507,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[14586,14680],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":527,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":527,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[15183,15293],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":531,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":531,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[15322,15394],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":568,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":568,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[16424,16525],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":610,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":610,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[17586,17684],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":620,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":620,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[17814,17920],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":680,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":680,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[19482,19543],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":702,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":702,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[20062,20172],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":39,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * BackgroundSyncService - Enhanced Background Synchronization Service\n *\n * Features:\n * - Configurable sync intervals (15min, 30min, 1hr, 2hr, manual)\n * - Network-aware sync with WiFi/cellular preferences\n * - Integration with existing SyncService for data synchronization\n * - Battery optimization handling\n * - Comprehensive error handling and retry mechanisms\n * - Background sync status reporting\n */\n\nimport BackgroundService from 'react-native-background-actions';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport NetInfo, { NetInfoState } from '@react-native-community/netinfo';\nimport { DeviceEventEmitter } from 'react-native';\nimport { syncService } from './SyncService';\nimport { store } from '../store';\nimport {\n  updateSyncConfig,\n  updateNetworkStatus,\n  syncError,\n} from '../store/slices/syncSlice';\nimport { NetworkType, SyncStatus } from '../types/sync';\n\n// Constants\nconst LAST_SYNC_KEY = '@mobdeck/last_sync_time';\nconst SYNC_PREFERENCES_KEY = '@mobdeck/sync_preferences';\n\n// Sync interval options in minutes\nexport const SYNC_INTERVALS = {\n  MANUAL: 0,\n  FIFTEEN_MINUTES: 15,\n  THIRTY_MINUTES: 30,\n  ONE_HOUR: 60,\n  TWO_HOURS: 120,\n};\n\ninterface BackgroundSyncPreferences {\n  enabled: boolean;\n  interval: number;\n  wifiOnly: boolean;\n  allowCellular: boolean;\n  allowMetered: boolean;\n}\n\ninterface BackgroundSyncStatus {\n  isRunning: boolean;\n  lastSyncTime: string | null;\n  nextScheduledSync: string | null;\n  currentNetworkType: NetworkType | null;\n  syncHistory: SyncHistoryEntry[];\n}\n\ninterface SyncHistoryEntry {\n  timestamp: string;\n  success: boolean;\n  itemsSynced: number;\n  duration: number;\n  networkType: NetworkType;\n  error?: string;\n}\n\n/**\n * BackgroundSyncService - Manages background synchronization tasks\n */\nclass BackgroundSyncService {\n  private static instance: BackgroundSyncService;\n  private isInitialized = false;\n  private syncPreferences: BackgroundSyncPreferences;\n  private currentNetworkState: NetInfoState | null = null;\n  private unsubscribeNetInfo: (() => void) | null = null;\n  private deviceEventSubscriptions: any[] = [];\n\n  private constructor() {\n    // Initialize with default preferences\n    this.syncPreferences = {\n      enabled: true,\n      interval: SYNC_INTERVALS.FIFTEEN_MINUTES,\n      wifiOnly: false,\n      allowCellular: true,\n      allowMetered: true,\n    };\n  }\n\n  /**\n   * Get singleton instance of BackgroundSyncService\n   */\n  public static getInstance(): BackgroundSyncService {\n    if (!BackgroundSyncService.instance) {\n      BackgroundSyncService.instance = new BackgroundSyncService();\n    }\n    return BackgroundSyncService.instance;\n  }\n\n  /**\n   * Initialize background sync service\n   */\n  public async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      console.log('[BackgroundSyncService] Already initialized');\n      return;\n    }\n\n    try {\n      console.log('[BackgroundSyncService] Initializing...');\n\n      // Load saved preferences\n      await this.loadPreferences();\n\n      // Set up network monitoring\n      this.setupNetworkMonitoring();\n\n      // Set up device event listeners\n      this.setupDeviceEventListeners();\n\n      // Register background job\n      await this.registerBackgroundJob();\n\n      // Schedule sync if enabled\n      if (this.syncPreferences.enabled) {\n        await this.scheduleSync();\n      }\n\n      this.isInitialized = true;\n      console.log('[BackgroundSyncService] Initialized successfully');\n    } catch (error) {\n      console.error('[BackgroundSyncService] Failed to initialize:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load sync preferences from storage\n   */\n  private async loadPreferences(): Promise<void> {\n    try {\n      const savedPreferences = await AsyncStorage.getItem(SYNC_PREFERENCES_KEY);\n      if (savedPreferences) {\n        this.syncPreferences = JSON.parse(savedPreferences);\n\n        // Update Redux store with loaded configuration\n        store.dispatch(\n          updateSyncConfig({\n            config: {\n              backgroundSyncEnabled: this.syncPreferences.enabled,\n              syncInterval: this.syncPreferences.interval,\n              syncOnWifiOnly: this.syncPreferences.wifiOnly,\n              syncOnCellular: this.syncPreferences.allowCellular,\n            },\n          })\n        );\n      }\n    } catch (error) {\n      console.error(\n        '[BackgroundSyncService] Failed to load preferences:',\n        error\n      );\n    }\n  }\n\n  /**\n   * Save sync preferences to storage\n   */\n  private async savePreferences(): Promise<void> {\n    try {\n      await AsyncStorage.setItem(\n        SYNC_PREFERENCES_KEY,\n        JSON.stringify(this.syncPreferences)\n      );\n    } catch (error) {\n      console.error(\n        '[BackgroundSyncService] Failed to save preferences:',\n        error\n      );\n    }\n  }\n\n  /**\n   * Set up network state monitoring\n   */\n  private setupNetworkMonitoring(): void {\n    // Subscribe to network state changes\n    this.unsubscribeNetInfo = NetInfo.addEventListener(state => {\n      this.handleNetworkChange(state);\n    });\n\n    // Get initial network state\n    NetInfo.fetch().then(state => {\n      this.handleNetworkChange(state);\n    });\n  }\n\n  /**\n   * Set up device event listeners for Android native events\n   */\n  private setupDeviceEventListeners(): void {\n    // Listen for boot completion events\n    const bootSubscription = DeviceEventEmitter.addListener(\n      'DeviceBootCompleted',\n      (data: any) => {\n        console.log('[BackgroundSyncService] Device boot completed:', data);\n        this.handleDeviceBootCompleted();\n      }\n    );\n\n    // Listen for background sync job events\n    const syncJobSubscription = DeviceEventEmitter.addListener(\n      'BackgroundSyncEvent',\n      (data: any) => {\n        console.log('[BackgroundSyncService] Background sync event:', data);\n        this.handleBackgroundSyncEvent(data);\n      }\n    );\n\n    this.deviceEventSubscriptions.push(bootSubscription, syncJobSubscription);\n  }\n\n  /**\n   * Handle device boot completion\n   */\n  private async handleDeviceBootCompleted(): Promise<void> {\n    try {\n      console.log('[BackgroundSyncService] Handling device boot completion');\n\n      // Reload preferences\n      await this.loadPreferences();\n\n      // Reschedule sync if enabled\n      if (this.syncPreferences.enabled) {\n        await this.scheduleSync();\n      }\n\n      console.log('[BackgroundSyncService] Sync rescheduled after boot');\n    } catch (error) {\n      console.error(\n        '[BackgroundSyncService] Failed to handle boot completion:',\n        error\n      );\n    }\n  }\n\n  /**\n   * Handle background sync job events from Android\n   */\n  private handleBackgroundSyncEvent(eventType: string): void {\n    switch (eventType) {\n      case 'start':\n        console.log('[BackgroundSyncService] Android background job started');\n        // The actual sync work will be handled by performBackgroundSync\n        break;\n      case 'stop':\n        console.log('[BackgroundSyncService] Android background job stopped');\n        break;\n      default:\n        console.log(\n          '[BackgroundSyncService] Unknown background sync event:',\n          eventType\n        );\n    }\n  }\n\n  /**\n   * Handle network state changes\n   */\n  private handleNetworkChange(state: NetInfoState): void {\n    this.currentNetworkState = state;\n\n    // Map network type\n    let networkType: NetworkType | null = null;\n    if (state.type === 'wifi') {\n      networkType = NetworkType.WIFI;\n    } else if (state.type === 'cellular') {\n      networkType = NetworkType.CELLULAR;\n    } else if (state.type === 'ethernet') {\n      networkType = NetworkType.ETHERNET;\n    } else if (state.isConnected) {\n      networkType = NetworkType.UNKNOWN;\n    }\n\n    // Update Redux store\n    store.dispatch(\n      updateNetworkStatus({\n        isOnline: state.isConnected || false,\n        networkType,\n      })\n    );\n\n    console.log(\n      `[BackgroundSyncService] Network state changed: ${state.type}, Connected: ${state.isConnected}`\n    );\n\n    // Check if we should trigger a sync based on network conditions\n    if (this.shouldSyncOnCurrentNetwork()) {\n      this.checkAndTriggerSync();\n    }\n  }\n\n  /**\n   * Check if sync should run on current network\n   */\n  private shouldSyncOnCurrentNetwork(): boolean {\n    if (!this.currentNetworkState || !this.currentNetworkState.isConnected) {\n      return false;\n    }\n\n    // Check WiFi-only preference\n    if (\n      this.syncPreferences.wifiOnly &&\n      this.currentNetworkState.type !== 'wifi'\n    ) {\n      console.log(\n        '[BackgroundSyncService] Sync requires WiFi, current network is not WiFi'\n      );\n      return false;\n    }\n\n    // Check cellular preference\n    if (\n      !this.syncPreferences.allowCellular &&\n      this.currentNetworkState.type === 'cellular'\n    ) {\n      console.log('[BackgroundSyncService] Cellular sync disabled');\n      return false;\n    }\n\n    // Check metered connection preference\n    if (\n      !this.syncPreferences.allowMetered &&\n      this.currentNetworkState.details?.isConnectionExpensive\n    ) {\n      console.log('[BackgroundSyncService] Metered connection sync disabled');\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Register background job with react-native-background-actions\n   */\n  private async registerBackgroundJob(): Promise<void> {\n    // Background job registration is now handled when starting the service\n    console.log('[BackgroundSyncService] Background job registration prepared');\n  }\n\n  /**\n   * Schedule background sync based on current preferences\n   */\n  public async scheduleSync(): Promise<void> {\n    try {\n      if (\n        !this.syncPreferences.enabled ||\n        this.syncPreferences.interval === SYNC_INTERVALS.MANUAL\n      ) {\n        await this.cancelSync();\n        return;\n      }\n\n      // Stop any existing background service\n      if (BackgroundService.isRunning()) {\n        await BackgroundService.stop();\n      }\n\n      // Configure background service options\n      const options = {\n        taskName: 'MobdeckSync',\n        taskTitle: 'Mobdeck Background Sync',\n        taskDesc: 'Syncing your articles in the background',\n        taskIcon: {\n          name: 'ic_launcher',\n          type: 'mipmap',\n        },\n        color: '#2196F3',\n        linkingURI: 'mobdeck://sync',\n        parameters: {\n          syncInterval: this.syncPreferences.interval * 60 * 1000, // Convert minutes to milliseconds\n          wifiOnly: this.syncPreferences.wifiOnly,\n          allowCellular: this.syncPreferences.allowCellular,\n          allowMetered: this.syncPreferences.allowMetered,\n        },\n        progressBar: {\n          max: 100,\n          value: 0,\n          indeterminate: true,\n        },\n      };\n\n      // Define the background task\n      const backgroundTask = async (taskDataArguments: any) => {\n        const { syncInterval, wifiOnly, allowCellular, allowMetered } = taskDataArguments;\n        \n        // Helper function for delays\n        const sleep = (time: number) => new Promise<void>((resolve) => setTimeout(resolve, time));\n        \n        while (BackgroundService.isRunning()) {\n          try {\n            // Check network conditions\n            const networkState = await NetInfo.fetch();\n            \n            if (!networkState.isConnected) {\n              await sleep(syncInterval);\n              continue;\n            }\n            \n            // Check WiFi-only preference\n            if (wifiOnly && networkState.type !== 'wifi') {\n              await sleep(syncInterval);\n              continue;\n            }\n            \n            // Check cellular preference\n            if (!allowCellular && networkState.type === 'cellular') {\n              await sleep(syncInterval);\n              continue;\n            }\n            \n            // Check metered connection preference\n            if (!allowMetered && networkState.details?.isConnectionExpensive) {\n              await sleep(syncInterval);\n              continue;\n            }\n            \n            // Perform the actual sync\n            await this.performBackgroundSync();\n            \n            // Update notification with last sync time\n            await BackgroundService.updateNotification({\n              taskDesc: `Last sync: ${new Date().toLocaleTimeString()}`,\n            });\n            \n          } catch (error) {\n            console.error('[BackgroundSyncService] Error in background task:', error instanceof Error ? error.message : String(error));\n          }\n          \n          await sleep(syncInterval);\n        }\n      };\n\n      // Start the background service\n      await BackgroundService.start(backgroundTask, options);\n\n      const nextSyncTime = new Date(Date.now() + this.syncPreferences.interval * 60 * 1000);\n      console.log(\n        `[BackgroundSyncService] Sync service started, next sync around ${nextSyncTime.toISOString()}`\n      );\n\n      // Save next sync time\n      await AsyncStorage.setItem(\n        '@mobdeck/next_sync_time',\n        nextSyncTime.toISOString()\n      );\n    } catch (error) {\n      console.error('[BackgroundSyncService] Failed to schedule sync:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Cancel scheduled background sync\n   */\n  public async cancelSync(): Promise<void> {\n    try {\n      if (BackgroundService.isRunning()) {\n        await BackgroundService.stop();\n      }\n      await AsyncStorage.removeItem('@mobdeck/next_sync_time');\n      console.log('[BackgroundSyncService] Background sync cancelled');\n    } catch (error) {\n      console.error('[BackgroundSyncService] Failed to cancel sync:', error);\n    }\n  }\n\n  /**\n   * Perform background synchronization\n   */\n  private async performBackgroundSync(): Promise<void> {\n    console.log('[BackgroundSyncService] Starting background sync...');\n\n    const startTime = Date.now();\n    const syncHistory: SyncHistoryEntry = {\n      timestamp: new Date().toISOString(),\n      success: false,\n      itemsSynced: 0,\n      duration: 0,\n      networkType: this.getNetworkType(),\n    };\n\n    try {\n      // Check if user is authenticated first\n      const state = store.getState();\n      if (!state.auth.isAuthenticated) {\n        console.log('[BackgroundSyncService] User not authenticated, skipping sync');\n        return;\n      }\n\n      // Check network conditions\n      if (!this.shouldSyncOnCurrentNetwork()) {\n        console.log(\n          '[BackgroundSyncService] Network conditions not met for sync'\n        );\n        return;\n      }\n\n      // Check if sync is already running\n      if (state.sync.status === SyncStatus.SYNCING) {\n        console.log(\n          '[BackgroundSyncService] Sync already in progress, skipping'\n        );\n        return;\n      }\n\n      // Perform sync using existing SyncService\n      const result = await syncService.startFullSync();\n\n      syncHistory.success = result.success;\n      syncHistory.itemsSynced = result.syncedCount;\n      syncHistory.duration = Date.now() - startTime;\n\n      if (!result.success) {\n        syncHistory.error = result.errors[0]?.error || 'Unknown error';\n      }\n\n      // Save last sync time\n      await AsyncStorage.setItem(LAST_SYNC_KEY, new Date().toISOString());\n\n      console.log(\n        `[BackgroundSyncService] Background sync completed in ${syncHistory.duration}ms`\n      );\n    } catch (error) {\n      console.error('[BackgroundSyncService] Background sync failed:', error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      syncHistory.error = errorMessage;\n\n      // Dispatch error to Redux store\n      store.dispatch(\n        syncError({\n          error: errorMessage,\n          errorCode: 'BACKGROUND_SYNC_FAILED',\n          retryable: true,\n        })\n      );\n    } finally {\n      // Save sync history\n      await this.saveSyncHistory(syncHistory);\n    }\n  }\n\n  /**\n   * Save sync history entry\n   */\n  private async saveSyncHistory(entry: SyncHistoryEntry): Promise<void> {\n    try {\n      const historyKey = '@mobdeck/sync_history';\n      const existingHistory = await AsyncStorage.getItem(historyKey);\n      const history: SyncHistoryEntry[] = existingHistory\n        ? JSON.parse(existingHistory)\n        : [];\n\n      // Add new entry and keep last 20 entries\n      history.unshift(entry);\n      if (history.length > 20) {\n        history.pop();\n      }\n\n      await AsyncStorage.setItem(historyKey, JSON.stringify(history));\n    } catch (error) {\n      console.error(\n        '[BackgroundSyncService] Failed to save sync history:',\n        error\n      );\n    }\n  }\n\n  /**\n   * Get current network type\n   */\n  private getNetworkType(): NetworkType {\n    if (!this.currentNetworkState || !this.currentNetworkState.isConnected) {\n      return NetworkType.UNKNOWN;\n    }\n\n    switch (this.currentNetworkState.type) {\n      case 'wifi':\n        return NetworkType.WIFI;\n      case 'cellular':\n        return NetworkType.CELLULAR;\n      case 'ethernet':\n        return NetworkType.ETHERNET;\n      default:\n        return NetworkType.UNKNOWN;\n    }\n  }\n\n  /**\n   * Check and trigger sync if conditions are met\n   */\n  private async checkAndTriggerSync(): Promise<void> {\n    try {\n      // Check if enough time has passed since last sync\n      const lastSyncTime = await AsyncStorage.getItem(LAST_SYNC_KEY);\n      if (lastSyncTime) {\n        const timeSinceLastSync = Date.now() - new Date(lastSyncTime).getTime();\n        const minInterval = Math.min(\n          this.syncPreferences.interval * 60 * 1000,\n          5 * 60 * 1000\n        ); // At least 5 minutes\n\n        if (timeSinceLastSync < minInterval) {\n          console.log(\n            '[BackgroundSyncService] Too soon since last sync, skipping'\n          );\n          return;\n        }\n      }\n\n      // Trigger sync\n      await this.performBackgroundSync();\n    } catch (error) {\n      console.error(\n        '[BackgroundSyncService] Failed to check and trigger sync:',\n        error\n      );\n    }\n  }\n\n  /**\n   * Update sync preferences\n   */\n  public async updatePreferences(\n    preferences: Partial<BackgroundSyncPreferences>\n  ): Promise<void> {\n    this.syncPreferences = { ...this.syncPreferences, ...preferences };\n    await this.savePreferences();\n\n    // Update Redux store\n    store.dispatch(\n      updateSyncConfig({\n        config: {\n          backgroundSyncEnabled: this.syncPreferences.enabled,\n          syncInterval: this.syncPreferences.interval,\n          syncOnWifiOnly: this.syncPreferences.wifiOnly,\n          syncOnCellular: this.syncPreferences.allowCellular,\n        },\n      })\n    );\n\n    // Reschedule sync if needed\n    if (this.syncPreferences.enabled) {\n      await this.scheduleSync();\n    } else {\n      await this.cancelSync();\n    }\n  }\n\n  /**\n   * Get current sync status\n   */\n  public async getStatus(): Promise<BackgroundSyncStatus> {\n    const lastSyncTime = await AsyncStorage.getItem(LAST_SYNC_KEY);\n    const nextSyncTime = await AsyncStorage.getItem('@mobdeck/next_sync_time');\n    const historyData = await AsyncStorage.getItem('@mobdeck/sync_history');\n    const history: SyncHistoryEntry[] = historyData\n      ? JSON.parse(historyData)\n      : [];\n\n    return {\n      isRunning: BackgroundService.isRunning() || store.getState().sync.status === SyncStatus.SYNCING,\n      lastSyncTime,\n      nextScheduledSync: nextSyncTime,\n      currentNetworkType: this.getNetworkType(),\n      syncHistory: history,\n    };\n  }\n\n  /**\n   * Trigger manual sync\n   */\n  public async triggerManualSync(): Promise<void> {\n    console.log('[BackgroundSyncService] Manual sync triggered');\n    await this.performBackgroundSync();\n  }\n\n  /**\n   * Clean up resources\n   */\n  public cleanup(): void {\n    // Unsubscribe from network monitoring\n    if (this.unsubscribeNetInfo) {\n      this.unsubscribeNetInfo();\n      this.unsubscribeNetInfo = null;\n    }\n\n    // Remove device event subscriptions\n    this.deviceEventSubscriptions.forEach(subscription => {\n      subscription.remove();\n    });\n    this.deviceEventSubscriptions = [];\n\n    // Cancel background sync\n    this.cancelSync().catch(error => {\n      console.error(\n        '[BackgroundSyncService] Failed to cancel sync during cleanup:',\n        error\n      );\n    });\n\n    this.isInitialized = false;\n  }\n}\n\n// Export singleton instance\nexport const backgroundSyncService = BackgroundSyncService.getInstance();\n\n// Export class for testing\nexport default BackgroundSyncService;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/services/BackgroundTaskManager.ts","messages":[{"ruleId":"react-native/split-platform-components","severity":2,"message":"Android components should be placed in android files","line":14,"column":3,"nodeType":"Identifier","endLine":14,"endColumn":21},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":74,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":74,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2100,2159],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":79,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":79,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2197,2252],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":83,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":83,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2345,2453],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":105,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":105,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2979,3043],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":107,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":107,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[3072,3142],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":125,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":125,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3607,3711],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":130,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":130,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[3748,3856],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":148,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":148,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[4190,4298],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":196,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":196,"endColumn":25,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[5824,5965],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":201,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":201,"endColumn":23,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[6014,6137],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":215,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":215,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6546,6646],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":220,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":220,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[6675,6776],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-unreachable","severity":2,"message":"Unreachable code.","line":235,"column":21,"nodeType":"BlockStatement","messageId":"unreachableCode","endLine":241,"endColumn":6},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":236,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":236,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[7124,7235],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":250,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":250,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7523,7594],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":256,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":256,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7771,7843],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":262,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":262,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8011,8076],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":285,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":285,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8683,8747],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":287,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":287,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[8776,8882],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":303,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":303,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9233,9328],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":307,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":307,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[9357,9479],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":317,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":317,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9594,9597],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9594,9597],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":345,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":345,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10387,10390],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10387,10390],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":359,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":359,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10747,10750],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10747,10750],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":371,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":371,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11036,11140],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":404,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":404,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11954,12066],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":408,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":408,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[12095,12203],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":432,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":432,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[12737,12802],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":434,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":434,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[12831,12937],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":469,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":469,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[13782,13897],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":474,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":474,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[13969,14083],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":542,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":542,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[15817,15874],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":31,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * BackgroundTaskManager - Android Background Task Management Service\n *\n * Features:\n * - Android-specific background task scheduling and management\n * - Integration with existing BackgroundSyncService\n * - Android 13+ compatibility with background task restrictions\n * - Network-aware task execution with proper permissions\n * - Foreground service management for long-running sync operations\n */\n\nimport {\n  DeviceEventEmitter,\n  PermissionsAndroid,\n  Platform,\n} from 'react-native';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { backgroundSyncService } from './BackgroundSyncService';\nimport { store } from '../store';\nimport { syncError } from '../store/slices/syncSlice';\n\n// Background task constants\nconst BACKGROUND_TASK_STORAGE_KEY = '@mobdeck/background_tasks';\n\ninterface BackgroundTaskConfig {\n  taskId: string;\n  enabled: boolean;\n  interval: number;\n  networkRequirement: 'any' | 'wifi' | 'unmetered';\n  requiresCharging: boolean;\n  requiresDeviceIdle: boolean;\n  lastExecuted?: string;\n  nextScheduled?: string;\n}\n\ninterface AndroidTaskPermissions {\n  notifications: boolean;\n  exactAlarms: boolean;\n  backgroundActivity: boolean;\n  foregroundService: boolean;\n}\n\n/**\n * BackgroundTaskManager - Manages Android-specific background task scheduling\n */\nclass BackgroundTaskManager {\n  private static instance: BackgroundTaskManager;\n  private isInitialized = false;\n  private taskConfigs: Map<string, BackgroundTaskConfig> = new Map();\n  private permissions: AndroidTaskPermissions = {\n    notifications: false,\n    exactAlarms: false,\n    backgroundActivity: false,\n    foregroundService: false,\n  };\n\n  private constructor() {}\n\n  /**\n   * Get singleton instance of BackgroundTaskManager\n   */\n  public static getInstance(): BackgroundTaskManager {\n    if (!BackgroundTaskManager.instance) {\n      BackgroundTaskManager.instance = new BackgroundTaskManager();\n    }\n    return BackgroundTaskManager.instance;\n  }\n\n  /**\n   * Initialize background task manager\n   */\n  public async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      console.log('[BackgroundTaskManager] Already initialized');\n      return;\n    }\n\n    try {\n      console.log('[BackgroundTaskManager] Initializing...');\n\n      // Check Android version and platform\n      if (Platform.OS !== 'android') {\n        console.log(\n          '[BackgroundTaskManager] Not on Android platform, skipping initialization'\n        );\n        return;\n      }\n\n      // Load saved task configurations\n      await this.loadTaskConfigurations();\n\n      // Check and request required permissions\n      await this.checkAndRequestPermissions();\n\n      // Set up device event listeners\n      this.setupDeviceEventListeners();\n\n      // Register background task handlers\n      await this.registerTaskHandlers();\n\n      // Initialize integration with BackgroundSyncService\n      await this.initializeBackgroundSyncIntegration();\n\n      this.isInitialized = true;\n      console.log('[BackgroundTaskManager] Initialized successfully');\n    } catch (error) {\n      console.error('[BackgroundTaskManager] Failed to initialize:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load task configurations from storage\n   */\n  private async loadTaskConfigurations(): Promise<void> {\n    try {\n      const savedConfigs = await AsyncStorage.getItem(\n        BACKGROUND_TASK_STORAGE_KEY\n      );\n      if (savedConfigs) {\n        const configs: BackgroundTaskConfig[] = JSON.parse(savedConfigs);\n        configs.forEach(config => {\n          this.taskConfigs.set(config.taskId, config);\n        });\n        console.log(\n          `[BackgroundTaskManager] Loaded ${configs.length} task configurations`\n        );\n      }\n    } catch (error) {\n      console.error(\n        '[BackgroundTaskManager] Failed to load task configurations:',\n        error\n      );\n    }\n  }\n\n  /**\n   * Save task configurations to storage\n   */\n  private async saveTaskConfigurations(): Promise<void> {\n    try {\n      const configs = Array.from(this.taskConfigs.values());\n      await AsyncStorage.setItem(\n        BACKGROUND_TASK_STORAGE_KEY,\n        JSON.stringify(configs)\n      );\n    } catch (error) {\n      console.error(\n        '[BackgroundTaskManager] Failed to save task configurations:',\n        error\n      );\n    }\n  }\n\n  /**\n   * Check and request required Android permissions\n   */\n  private async checkAndRequestPermissions(): Promise<void> {\n    try {\n      // Check notification permission (Android 13+)\n      if (Platform.Version >= 33) {\n        const notificationPermission = await PermissionsAndroid.check(\n          PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS\n        );\n\n        if (!notificationPermission) {\n          const granted = await PermissionsAndroid.request(\n            PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS,\n            {\n              title: 'Notification Permission',\n              message:\n                'Mobdeck needs notification permission to show sync status updates.',\n              buttonNeutral: 'Ask Me Later',\n              buttonNegative: 'Cancel',\n              buttonPositive: 'OK',\n            }\n          );\n          this.permissions.notifications =\n            granted === PermissionsAndroid.RESULTS.GRANTED;\n        } else {\n          this.permissions.notifications = true;\n        }\n      } else {\n        this.permissions.notifications = true; // Not required for older versions\n      }\n\n      // Check exact alarm permission (Android 12+)\n      if (Platform.Version >= 31) {\n        try {\n          // Use native module to check exact alarm permission\n          const hasExactAlarmPermission =\n            await this.checkExactAlarmPermission();\n          this.permissions.exactAlarms = hasExactAlarmPermission;\n\n          if (!hasExactAlarmPermission) {\n            console.warn(\n              '[BackgroundTaskManager] Exact alarm permission not granted, background sync may be less reliable'\n            );\n          }\n        } catch (error) {\n          console.warn(\n            '[BackgroundTaskManager] Could not check exact alarm permission:',\n            error\n          );\n          this.permissions.exactAlarms = false;\n        }\n      } else {\n        this.permissions.exactAlarms = true; // Not required for older versions\n      }\n\n      // Check background activity and foreground service permissions\n      this.permissions.backgroundActivity = true; // Handled by manifest permissions\n      this.permissions.foregroundService = true; // Handled by manifest permissions\n\n      console.log(\n        '[BackgroundTaskManager] Permission status:',\n        this.permissions\n      );\n    } catch (error) {\n      console.error(\n        '[BackgroundTaskManager] Failed to check permissions:',\n        error\n      );\n    }\n  }\n\n  /**\n   * Check exact alarm permission using native Android API\n   */\n  private async checkExactAlarmPermission(): Promise<boolean> {\n    try {\n      // This would typically require a native module implementation\n      // For now, we'll assume permission is granted and handle gracefully\n      return true;\n    } catch (error) {\n      console.warn(\n        '[BackgroundTaskManager] Could not check exact alarm permission:',\n        error\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Set up device event listeners for Android background task events\n   */\n  private setupDeviceEventListeners(): void {\n    // Listen for background task execution events\n    DeviceEventEmitter.addListener('BackgroundTaskExecuted', data => {\n      console.log('[BackgroundTaskManager] Background task executed:', data);\n      this.handleBackgroundTaskExecution(data);\n    });\n\n    // Listen for task scheduling events\n    DeviceEventEmitter.addListener('BackgroundTaskScheduled', data => {\n      console.log('[BackgroundTaskManager] Background task scheduled:', data);\n      this.handleBackgroundTaskScheduling(data);\n    });\n\n    // Listen for permission changes\n    DeviceEventEmitter.addListener('PermissionChanged', data => {\n      console.log('[BackgroundTaskManager] Permission changed:', data);\n      this.handlePermissionChange(data);\n    });\n  }\n\n  /**\n   * Register background task handlers with Android system\n   */\n  private async registerTaskHandlers(): Promise<void> {\n    try {\n      // Register sync task\n      const syncTaskConfig: BackgroundTaskConfig = {\n        taskId: 'mobdeck-sync-task',\n        enabled: true,\n        interval: 15, // 15 minutes default\n        networkRequirement: 'any',\n        requiresCharging: false,\n        requiresDeviceIdle: false,\n      };\n\n      this.taskConfigs.set(syncTaskConfig.taskId, syncTaskConfig);\n      await this.saveTaskConfigurations();\n\n      console.log('[BackgroundTaskManager] Task handlers registered');\n    } catch (error) {\n      console.error(\n        '[BackgroundTaskManager] Failed to register task handlers:',\n        error\n      );\n    }\n  }\n\n  /**\n   * Initialize integration with existing BackgroundSyncService\n   */\n  private async initializeBackgroundSyncIntegration(): Promise<void> {\n    try {\n      // Initialize the background sync service if not already done\n      await backgroundSyncService.initialize();\n\n      // Register this manager as a task execution handler\n      console.log(\n        '[BackgroundTaskManager] Background sync integration initialized'\n      );\n    } catch (error) {\n      console.error(\n        '[BackgroundTaskManager] Failed to initialize background sync integration:',\n        error\n      );\n    }\n  }\n\n  /**\n   * Handle background task execution events\n   */\n  private handleBackgroundTaskExecution(data: any): void {\n    const { taskId, success, error } = data;\n\n    if (taskId === 'mobdeck-sync-task') {\n      // Update task configuration with execution time\n      const config = this.taskConfigs.get(taskId);\n      if (config) {\n        config.lastExecuted = new Date().toISOString();\n        this.taskConfigs.set(taskId, config);\n        this.saveTaskConfigurations();\n      }\n\n      if (!success && error) {\n        // Dispatch error to Redux store\n        store.dispatch(\n          syncError({\n            error: error.message || 'Background task execution failed',\n            errorCode: 'BACKGROUND_TASK_FAILED',\n            retryable: true,\n          })\n        );\n      }\n    }\n  }\n\n  /**\n   * Handle background task scheduling events\n   */\n  private handleBackgroundTaskScheduling(data: any): void {\n    const { taskId, nextExecution } = data;\n\n    const config = this.taskConfigs.get(taskId);\n    if (config && nextExecution) {\n      config.nextScheduled = nextExecution;\n      this.taskConfigs.set(taskId, config);\n      this.saveTaskConfigurations();\n    }\n  }\n\n  /**\n   * Handle permission changes\n   */\n  private handlePermissionChange(data: any): void {\n    const { permission, granted } = data;\n\n    switch (permission) {\n      case 'POST_NOTIFICATIONS':\n        this.permissions.notifications = granted;\n        break;\n      case 'SCHEDULE_EXACT_ALARM':\n        this.permissions.exactAlarms = granted;\n        break;\n    }\n\n    console.log(\n      '[BackgroundTaskManager] Permission updated:',\n      permission,\n      granted\n    );\n  }\n\n  /**\n   * Schedule background sync task\n   */\n  public async scheduleBackgroundSync(\n    intervalMinutes: number,\n    networkRequirement: 'any' | 'wifi' = 'any'\n  ): Promise<void> {\n    try {\n      const config = this.taskConfigs.get('mobdeck-sync-task');\n      if (!config) {\n        throw new Error('Sync task configuration not found');\n      }\n\n      config.interval = intervalMinutes;\n      config.networkRequirement = networkRequirement;\n      config.enabled = true;\n      config.nextScheduled = new Date(\n        Date.now() + intervalMinutes * 60 * 1000\n      ).toISOString();\n\n      this.taskConfigs.set('mobdeck-sync-task', config);\n      await this.saveTaskConfigurations();\n\n      // Delegate to BackgroundSyncService for actual scheduling\n      await backgroundSyncService.scheduleSync();\n\n      console.log(\n        `[BackgroundTaskManager] Background sync scheduled for ${intervalMinutes} minutes`\n      );\n    } catch (error) {\n      console.error(\n        '[BackgroundTaskManager] Failed to schedule background sync:',\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Cancel background sync task\n   */\n  public async cancelBackgroundSync(): Promise<void> {\n    try {\n      const config = this.taskConfigs.get('mobdeck-sync-task');\n      if (config) {\n        config.enabled = false;\n        config.nextScheduled = undefined;\n        this.taskConfigs.set('mobdeck-sync-task', config);\n        await this.saveTaskConfigurations();\n      }\n\n      // Delegate to BackgroundSyncService for actual cancellation\n      await backgroundSyncService.cancelSync();\n\n      console.log('[BackgroundTaskManager] Background sync cancelled');\n    } catch (error) {\n      console.error(\n        '[BackgroundTaskManager] Failed to cancel background sync:',\n        error\n      );\n    }\n  }\n\n  /**\n   * Get current task status\n   */\n  public async getTaskStatus(): Promise<{\n    permissions: AndroidTaskPermissions;\n    tasks: BackgroundTaskConfig[];\n    isBackgroundSyncEnabled: boolean;\n  }> {\n    const backgroundSyncStatus = await backgroundSyncService.getStatus();\n\n    return {\n      permissions: this.permissions,\n      tasks: Array.from(this.taskConfigs.values()),\n      isBackgroundSyncEnabled: backgroundSyncStatus.isRunning,\n    };\n  }\n\n  /**\n   * Request user to enable exact alarm permission\n   */\n  public async requestExactAlarmPermission(): Promise<boolean> {\n    try {\n      if (Platform.Version < 31) {\n        return true; // Not required for older versions\n      }\n\n      // This would typically open Android settings for exact alarm permission\n      // For now, we'll log and return current status\n      console.log(\n        '[BackgroundTaskManager] Exact alarm permission should be requested through settings'\n      );\n      return this.permissions.exactAlarms;\n    } catch (error) {\n      console.error(\n        '[BackgroundTaskManager] Failed to request exact alarm permission:',\n        error\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Check if background tasks can run reliably\n   */\n  public canRunBackgroundTasks(): boolean {\n    if (Platform.OS !== 'android') {\n      return false;\n    }\n\n    // Check minimum required permissions\n    const hasRequiredPermissions =\n      this.permissions.backgroundActivity && this.permissions.foregroundService;\n\n    // On Android 13+, notification permission is also required\n    if (Platform.Version >= 33 && !this.permissions.notifications) {\n      return false;\n    }\n\n    return hasRequiredPermissions;\n  }\n\n  /**\n   * Get background task reliability score (0-100)\n   */\n  public getReliabilityScore(): number {\n    let score = 0;\n\n    // Base permissions (40 points)\n    if (this.permissions.backgroundActivity) score += 20;\n    if (this.permissions.foregroundService) score += 20;\n\n    // Notification permission (20 points on Android 13+)\n    if (Platform.Version >= 33) {\n      if (this.permissions.notifications) score += 20;\n    } else {\n      score += 20; // Full points for older versions\n    }\n\n    // Exact alarm permission (20 points on Android 12+)\n    if (Platform.Version >= 31) {\n      if (this.permissions.exactAlarms) score += 20;\n    } else {\n      score += 20; // Full points for older versions\n    }\n\n    // Battery optimization (20 points - assume optimized for now)\n    score += 20;\n\n    return Math.min(score, 100);\n  }\n\n  /**\n   * Cleanup resources\n   */\n  public cleanup(): void {\n    // Remove device event listeners\n    DeviceEventEmitter.removeAllListeners('BackgroundTaskExecuted');\n    DeviceEventEmitter.removeAllListeners('BackgroundTaskScheduled');\n    DeviceEventEmitter.removeAllListeners('PermissionChanged');\n\n    this.isInitialized = false;\n    console.log('[BackgroundTaskManager] Cleanup completed');\n  }\n}\n\n// Export singleton instance\nexport const backgroundTaskManager = BackgroundTaskManager.getInstance();\n\n// Export class for testing\nexport default BackgroundTaskManager;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/services/CacheService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":320,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":320,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8080,8083],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8080,8083],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":338,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":338,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8630,8633],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8630,8633],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":388,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":388,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9785,9788],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9785,9788],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":392,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":392,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9868,9871],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9868,9871],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * High-Performance Cache Service\n * \n * Features:\n * - In-memory caching with O(1) access time\n * - LRU (Least Recently Used) eviction policy\n * - Configurable TTL (Time To Live)\n * - Pre-serialization of data for fast retrieval\n * - Minimal overhead for cache hits (<0.1ms)\n * - Memory-efficient storage\n * - Thread-safe operations\n */\n\nimport { Article, Label } from '../types';\n\ninterface CacheEntry<T> {\n  data: T;\n  serialized?: string; // Pre-serialized data for faster access\n  expiresAt: number;\n  accessCount: number;\n  lastAccessed: number;\n  size: number;\n}\n\ninterface CacheOptions {\n  maxSize?: number; // Maximum number of entries\n  maxMemory?: number; // Maximum memory in bytes\n  ttl?: number; // Time to live in milliseconds\n  enableSerialization?: boolean; // Pre-serialize data for faster access\n}\n\ninterface CacheStats {\n  hits: number;\n  misses: number;\n  evictions: number;\n  size: number;\n  memoryUsage: number;\n  hitRate: number;\n  avgHitTime: number;\n  avgMissTime: number;\n}\n\n/**\n * Generic high-performance cache implementation\n * Optimized for sub-millisecond cache hits\n */\nexport class Cache<T> {\n  private cache: Map<string, CacheEntry<T>>;\n  private accessOrder: Map<string, number>;\n  private options: Required<CacheOptions>;\n  private stats: CacheStats;\n  private totalMemory: number;\n  private hitTimes: number[];\n  private missTimes: number[];\n\n  constructor(options: CacheOptions = {}) {\n    this.cache = new Map();\n    this.accessOrder = new Map();\n    this.options = {\n      maxSize: options.maxSize || 1000,\n      maxMemory: options.maxMemory || 50 * 1024 * 1024, // 50MB default\n      ttl: options.ttl || 5 * 60 * 1000, // 5 minutes default\n      enableSerialization: options.enableSerialization ?? true,\n    };\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      evictions: 0,\n      size: 0,\n      memoryUsage: 0,\n      hitRate: 0,\n      avgHitTime: 0,\n      avgMissTime: 0,\n    };\n    this.totalMemory = 0;\n    this.hitTimes = [];\n    this.missTimes = [];\n  }\n\n  /**\n   * Get item from cache with sub-millisecond performance\n   * Optimized for speed with minimal overhead\n   */\n  get(key: string): T | null {\n    const startTime = performance.now();\n    \n    // Direct map access - O(1)\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      const endTime = performance.now();\n      this.recordMiss(endTime - startTime);\n      return null;\n    }\n\n    // Fast expiration check using number comparison\n    const now = Date.now();\n    if (entry.expiresAt < now) {\n      this.cache.delete(key);\n      this.accessOrder.delete(key);\n      const endTime = performance.now();\n      this.recordMiss(endTime - startTime);\n      return null;\n    }\n\n    // Update access tracking\n    entry.lastAccessed = now;\n    entry.accessCount++;\n    this.accessOrder.set(key, now);\n    \n    const endTime = performance.now();\n    this.recordHit(endTime - startTime);\n    \n    // Return data directly - already in memory\n    return entry.data;\n  }\n\n  /**\n   * Set item in cache with optimal performance\n   */\n  set(key: string, value: T, ttl?: number): void {\n    const now = Date.now();\n    const expiresAt = now + (ttl || this.options.ttl);\n    \n    // Calculate entry size\n    const size = this.estimateSize(value);\n    \n    // Check if eviction is needed\n    if (this.cache.size >= this.options.maxSize || \n        this.totalMemory + size > this.options.maxMemory) {\n      this.evictLRU();\n    }\n\n    // Pre-serialize if enabled for faster retrieval\n    let serialized: string | undefined;\n    if (this.options.enableSerialization) {\n      try {\n        serialized = JSON.stringify(value);\n      } catch (e) {\n        // Fallback to non-serialized if serialization fails\n        serialized = undefined;\n      }\n    }\n\n    const entry: CacheEntry<T> = {\n      data: value,\n      serialized,\n      expiresAt,\n      accessCount: 1,\n      lastAccessed: now,\n      size,\n    };\n\n    // Update cache\n    const existingEntry = this.cache.get(key);\n    if (existingEntry) {\n      this.totalMemory -= existingEntry.size;\n    }\n    \n    this.cache.set(key, entry);\n    this.accessOrder.set(key, now);\n    this.totalMemory += size;\n    this.stats.size = this.cache.size;\n    this.stats.memoryUsage = this.totalMemory;\n  }\n\n  /**\n   * Check if key exists in cache\n   * Ultra-fast operation for quick lookups\n   */\n  has(key: string): boolean {\n    const entry = this.cache.get(key);\n    if (!entry) return false;\n    \n    // Quick expiration check\n    if (entry.expiresAt < Date.now()) {\n      this.cache.delete(key);\n      this.accessOrder.delete(key);\n      return false;\n    }\n    \n    return true;\n  }\n\n  /**\n   * Delete item from cache\n   */\n  delete(key: string): boolean {\n    const entry = this.cache.get(key);\n    if (entry) {\n      this.totalMemory -= entry.size;\n      this.stats.size = this.cache.size - 1;\n      this.stats.memoryUsage = this.totalMemory;\n    }\n    \n    this.accessOrder.delete(key);\n    return this.cache.delete(key);\n  }\n\n  /**\n   * Clear all cache entries\n   */\n  clear(): void {\n    this.cache.clear();\n    this.accessOrder.clear();\n    this.totalMemory = 0;\n    this.stats.size = 0;\n    this.stats.memoryUsage = 0;\n    this.hitTimes = [];\n    this.missTimes = [];\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): CacheStats {\n    return {\n      ...this.stats,\n      hitRate: this.stats.hits / (this.stats.hits + this.stats.misses) || 0,\n      avgHitTime: this.calculateAverage(this.hitTimes),\n      avgMissTime: this.calculateAverage(this.missTimes),\n    };\n  }\n\n  /**\n   * Evict least recently used entries\n   * Optimized for performance\n   */\n  private evictLRU(): void {\n    // Sort by last accessed time\n    const entries = Array.from(this.accessOrder.entries());\n    entries.sort((a, b) => a[1] - b[1]);\n    \n    // Evict 25% of entries or until memory is under limit\n    const toEvict = Math.max(1, Math.floor(this.cache.size * 0.25));\n    \n    for (let i = 0; i < toEvict && i < entries.length; i++) {\n      const [key] = entries[i];\n      const entry = this.cache.get(key);\n      if (entry) {\n        this.totalMemory -= entry.size;\n        this.cache.delete(key);\n        this.accessOrder.delete(key);\n        this.stats.evictions++;\n      }\n      \n      // Stop if memory is under limit\n      if (this.totalMemory < this.options.maxMemory * 0.9) {\n        break;\n      }\n    }\n    \n    this.stats.size = this.cache.size;\n    this.stats.memoryUsage = this.totalMemory;\n  }\n\n  /**\n   * Estimate size of value in bytes\n   */\n  private estimateSize(value: T): number {\n    // Fast estimation based on type\n    if (typeof value === 'string') {\n      return value.length * 2; // 2 bytes per character\n    } else if (typeof value === 'number') {\n      return 8; // 64-bit number\n    } else if (typeof value === 'boolean') {\n      return 1;\n    } else if (value === null || value === undefined) {\n      return 0;\n    } else {\n      // For objects, use JSON stringify length as approximation\n      try {\n        return JSON.stringify(value).length * 2;\n      } catch {\n        return 1024; // Default 1KB for unknown objects\n      }\n    }\n  }\n\n  /**\n   * Record cache hit time\n   */\n  private recordHit(time: number): void {\n    this.stats.hits++;\n    this.hitTimes.push(time);\n    // Keep only last 1000 times for performance\n    if (this.hitTimes.length > 1000) {\n      this.hitTimes.shift();\n    }\n  }\n\n  /**\n   * Record cache miss time\n   */\n  private recordMiss(time: number): void {\n    this.stats.misses++;\n    this.missTimes.push(time);\n    // Keep only last 1000 times for performance\n    if (this.missTimes.length > 1000) {\n      this.missTimes.shift();\n    }\n  }\n\n  /**\n   * Calculate average of array\n   */\n  private calculateAverage(arr: number[]): number {\n    if (arr.length === 0) return 0;\n    return arr.reduce((a, b) => a + b, 0) / arr.length;\n  }\n}\n\n/**\n * Singleton CacheService for managing application caches\n */\nclass CacheService {\n  private static instance: CacheService;\n  private articleCache: Cache<Article>;\n  private labelCache: Cache<Label>;\n  private genericCache: Cache<any>;\n\n  private constructor() {\n    // Initialize caches with optimized settings\n    this.articleCache = new Cache<Article>({\n      maxSize: 500,\n      maxMemory: 20 * 1024 * 1024, // 20MB for articles\n      ttl: 10 * 60 * 1000, // 10 minutes\n      enableSerialization: false, // Articles are already objects\n    });\n\n    this.labelCache = new Cache<Label>({\n      maxSize: 200,\n      maxMemory: 5 * 1024 * 1024, // 5MB for labels\n      ttl: 30 * 60 * 1000, // 30 minutes\n      enableSerialization: false,\n    });\n\n    this.genericCache = new Cache<any>({\n      maxSize: 1000,\n      maxMemory: 10 * 1024 * 1024, // 10MB for generic data\n      ttl: 5 * 60 * 1000, // 5 minutes\n      enableSerialization: true,\n    });\n  }\n\n  static getInstance(): CacheService {\n    if (!CacheService.instance) {\n      CacheService.instance = new CacheService();\n    }\n    return CacheService.instance;\n  }\n\n  // Article cache operations\n  getArticle(id: string): Article | null {\n    return this.articleCache.get(id);\n  }\n\n  setArticle(id: string, article: Article, ttl?: number): void {\n    this.articleCache.set(id, article, ttl);\n  }\n\n  hasArticle(id: string): boolean {\n    return this.articleCache.has(id);\n  }\n\n  deleteArticle(id: string): boolean {\n    return this.articleCache.delete(id);\n  }\n\n  // Label cache operations\n  getLabel(id: string): Label | null {\n    return this.labelCache.get(id);\n  }\n\n  setLabel(id: string, label: Label, ttl?: number): void {\n    this.labelCache.set(id, label, ttl);\n  }\n\n  hasLabel(id: string): boolean {\n    return this.labelCache.has(id);\n  }\n\n  deleteLabel(id: string): boolean {\n    return this.labelCache.delete(id);\n  }\n\n  // Generic cache operations\n  get(key: string): any | null {\n    return this.genericCache.get(key);\n  }\n\n  set(key: string, value: any, ttl?: number): void {\n    this.genericCache.set(key, value, ttl);\n  }\n\n  has(key: string): boolean {\n    return this.genericCache.has(key);\n  }\n\n  delete(key: string): boolean {\n    return this.genericCache.delete(key);\n  }\n\n  // Clear operations\n  clearArticles(): void {\n    this.articleCache.clear();\n  }\n\n  clearLabels(): void {\n    this.labelCache.clear();\n  }\n\n  clearAll(): void {\n    this.articleCache.clear();\n    this.labelCache.clear();\n    this.genericCache.clear();\n  }\n\n  // Statistics\n  getStats() {\n    return {\n      articles: this.articleCache.getStats(),\n      labels: this.labelCache.getStats(),\n      generic: this.genericCache.getStats(),\n    };\n  }\n}\n\n// Export singleton instance\nexport const cacheService = CacheService.getInstance();\n\n// Export Cache class for custom cache instances\nexport { Cache };\n\n// Export types\nexport type { CacheOptions, CacheStats, CacheEntry };","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/services/DatabaseService.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":82,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":82,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2013,2071],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":93,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":93,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2419,2484],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":95,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":95,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[2517,2600],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":96,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":96,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2609,2685],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":106,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":106,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2877,2944],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":113,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":113,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[3130,3197],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":213,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":213,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[7221,7291],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":231,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":231,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7623,7689],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":271,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":271,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8965,9028],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":274,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":274,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9133,9231],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":301,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":301,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9770,9830],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":319,"column":7,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":319,"endColumn":15,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[10222,10223],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":323,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":323,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10374,10377],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10374,10377],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":346,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":346,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[11141,11202],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":357,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":357,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[11460,11522],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":483,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":483,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14839,14842],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14839,14842],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":602,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":602,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[18290,18383],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":665,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":665,"endColumn":31},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":755,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":755,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22646,22649],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22646,22649],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":947,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":947,"endColumn":31},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1129,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1129,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[33294,33363],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1134,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1134,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[33441,33509],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1169,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1169,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[34431,34504],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1189,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1189,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[35005,35127],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1198,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1198,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35391,35394],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35391,35394],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1198,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1198,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35406,35409],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35406,35409],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1199,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1199,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35458,35461],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35458,35461],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1228,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1228,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36200,36203],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36200,36203],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1253,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1253,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36798,36801],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36798,36801],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1254,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1254,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36822,36825],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36822,36825],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1257,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1257,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36900,36903],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36900,36903],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1296,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1296,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37944,37947],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37944,37947],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1298,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1298,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37982,37985],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37982,37985],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'image_url' is not in camel case.","line":1352,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":1352,"endColumn":16},{"ruleId":"camelcase","severity":2,"message":"Identifier 'read_time' is not in camel case.","line":1353,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":1353,"endColumn":16},{"ruleId":"camelcase","severity":2,"message":"Identifier 'source_url' is not in camel case.","line":1354,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":1354,"endColumn":17},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_archived' is not in camel case.","line":1355,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":1355,"endColumn":18},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_favorite' is not in camel case.","line":1356,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":1356,"endColumn":18},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_read' is not in camel case.","line":1357,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":1357,"endColumn":14},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_modified' is not in camel case.","line":1358,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":1358,"endColumn":18},{"ruleId":"camelcase","severity":2,"message":"Identifier 'created_at' is not in camel case.","line":1359,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":1359,"endColumn":17},{"ruleId":"camelcase","severity":2,"message":"Identifier 'updated_at' is not in camel case.","line":1360,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":1360,"endColumn":17},{"ruleId":"camelcase","severity":2,"message":"Identifier 'synced_at' is not in camel case.","line":1361,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":1361,"endColumn":16},{"ruleId":"camelcase","severity":2,"message":"Identifier 'deleted_at' is not in camel case.","line":1364,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":1364,"endColumn":17},{"ruleId":"camelcase","severity":2,"message":"Identifier 'created_at' is not in camel case.","line":1384,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":1384,"endColumn":17},{"ruleId":"camelcase","severity":2,"message":"Identifier 'updated_at' is not in camel case.","line":1385,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":1385,"endColumn":17},{"ruleId":"camelcase","severity":2,"message":"Identifier 'synced_at' is not in camel case.","line":1386,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":1386,"endColumn":16}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":33,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * DatabaseService - Comprehensive SQLite Database Service for Mobdeck\n *\n * Features:\n * - Singleton pattern for connection management\n * - Connection pooling and lifecycle management\n * - Transaction support with rollback capabilities\n * - Comprehensive error handling and logging\n * - CRUD operations for all schema tables\n * - Full-text search support\n * - Migration support for schema updates\n * - Performance optimization with prepared statements\n */\n\nimport SQLite from 'react-native-sqlite-storage';\nimport {\n  DatabaseServiceInterface,\n  DatabaseConfig,\n  DatabaseTransaction,\n  DatabaseResult,\n  DatabaseOperationResult,\n  DatabaseError,\n  DatabaseErrorCode,\n  TransactionContext,\n  DBArticle,\n  DBLabel,\n  DBSyncMetadata,\n  ArticleFilters,\n  LabelFilters,\n  SyncMetadataFilters,\n  PaginatedResult,\n  DatabaseStats,\n  Migration,\n  Article,\n  Label,\n  DatabaseUtils,\n} from '../types/database';\n\n// Enable debugging in development\nif (typeof __DEV__ !== 'undefined' && __DEV__) {\n  SQLite.DEBUG(true);\n  SQLite.enablePromise(true);\n}\n\nclass DatabaseService implements DatabaseServiceInterface {\n  private static instance: DatabaseService;\n  private db: SQLite.SQLiteDatabase | null = null;\n  private isInitialized = false;\n  private connectionPool: SQLite.SQLiteDatabase[] = [];\n  private readonly maxConnections = 5;\n  private readonly config: DatabaseConfig;\n\n  private constructor() {\n    this.config = {\n      name: 'mobdeck.db',\n      version: '1.0',\n      displayName: 'Mobdeck Database',\n      size: 10 * 1024 * 1024, // 10MB\n      location: 'default',\n    };\n  }\n\n  /**\n   * Get singleton instance of DatabaseService\n   */\n  public static getInstance(): DatabaseService {\n    if (!DatabaseService.instance) {\n      DatabaseService.instance = new DatabaseService();\n    }\n    return DatabaseService.instance;\n  }\n\n  /**\n   * Initialize database connection and run migrations\n   */\n  public async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    try {\n      console.log('[DatabaseService] Initializing database...');\n\n      this.db = await SQLite.openDatabase({\n        name: this.config.name,\n        location: this.config.location,\n        createFromLocation: undefined,\n      });\n\n      // Enable foreign key constraints (optional - some SQLite versions might not support this)\n      try {\n        await this.db.executeSql('PRAGMA foreign_keys = ON;');\n        console.log('[DatabaseService] Foreign key constraints enabled');\n      } catch (error) {\n        console.warn('[DatabaseService] Could not enable foreign key constraints:', error);\n        console.log('[DatabaseService] Continuing without foreign key constraints');\n      }\n\n      // Initialize schema\n      await this.initializeSchema();\n\n      // Run any pending migrations\n      await this.runPendingMigrations();\n\n      this.isInitialized = true;\n      console.log('[DatabaseService] Database initialized successfully');\n    } catch (error) {\n      const dbError = this.createDatabaseError(\n        DatabaseErrorCode.CONNECTION_FAILED,\n        'Failed to initialize database',\n        error\n      );\n      console.error('[DatabaseService] Initialization failed:', dbError);\n      throw dbError;\n    }\n  }\n\n  /**\n   * Initialize database schema from schema.sql\n   */\n  private async initializeSchema(): Promise<void> {\n    if (!this.db) {\n      throw new Error('Database not connected');\n    }\n\n    const schemaQueries = [\n      // Articles table\n      `CREATE TABLE IF NOT EXISTS articles (\n                id TEXT PRIMARY KEY NOT NULL,\n                title TEXT NOT NULL,\n                summary TEXT,\n                content TEXT,\n                url TEXT NOT NULL,\n                image_url TEXT,\n                read_time INTEGER,\n                is_archived INTEGER NOT NULL DEFAULT 0,\n                is_favorite INTEGER NOT NULL DEFAULT 0,\n                is_read INTEGER NOT NULL DEFAULT 0,\n                source_url TEXT,\n                created_at INTEGER NOT NULL,\n                updated_at INTEGER NOT NULL,\n                synced_at INTEGER,\n                is_modified INTEGER NOT NULL DEFAULT 0,\n                deleted_at INTEGER\n            );`,\n\n      // Labels table\n      `CREATE TABLE IF NOT EXISTS labels (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL UNIQUE,\n                color TEXT,\n                created_at INTEGER NOT NULL,\n                updated_at INTEGER NOT NULL,\n                synced_at INTEGER\n            );`,\n\n      // Article-Label junction table\n      `CREATE TABLE IF NOT EXISTS article_labels (\n                article_id TEXT NOT NULL,\n                label_id INTEGER NOT NULL,\n                created_at INTEGER NOT NULL,\n                PRIMARY KEY (article_id, label_id),\n                FOREIGN KEY (article_id) REFERENCES articles(id) ON DELETE CASCADE,\n                FOREIGN KEY (label_id) REFERENCES labels(id) ON DELETE CASCADE\n            );`,\n\n      // Sync metadata table\n      `CREATE TABLE IF NOT EXISTS sync_metadata (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                entity_type TEXT NOT NULL,\n                entity_id TEXT NOT NULL,\n                operation TEXT NOT NULL,\n                local_timestamp INTEGER NOT NULL,\n                server_timestamp INTEGER,\n                sync_status TEXT NOT NULL DEFAULT 'pending',\n                conflict_resolution TEXT,\n                retry_count INTEGER DEFAULT 0,\n                error_message TEXT,\n                created_at INTEGER NOT NULL,\n                updated_at INTEGER NOT NULL\n            );`,\n\n      // Schema version table\n      `CREATE TABLE IF NOT EXISTS schema_version (\n                version INTEGER PRIMARY KEY,\n                applied_at INTEGER NOT NULL,\n                description TEXT\n            );`,\n\n      // Performance indexes\n      'CREATE INDEX IF NOT EXISTS idx_articles_is_archived ON articles(is_archived);',\n      'CREATE INDEX IF NOT EXISTS idx_articles_is_favorite ON articles(is_favorite);',\n      'CREATE INDEX IF NOT EXISTS idx_articles_is_read ON articles(is_read);',\n      'CREATE INDEX IF NOT EXISTS idx_articles_created_at ON articles(created_at DESC);',\n      'CREATE INDEX IF NOT EXISTS idx_articles_updated_at ON articles(updated_at DESC);',\n      'CREATE INDEX IF NOT EXISTS idx_articles_is_modified ON articles(is_modified);',\n      'CREATE INDEX IF NOT EXISTS idx_articles_deleted_at ON articles(deleted_at);',\n      'CREATE INDEX IF NOT EXISTS idx_articles_synced_at ON articles(synced_at);',\n      'CREATE INDEX IF NOT EXISTS idx_sync_metadata_entity ON sync_metadata(entity_type, entity_id);',\n      'CREATE INDEX IF NOT EXISTS idx_sync_metadata_status ON sync_metadata(sync_status);',\n      'CREATE INDEX IF NOT EXISTS idx_sync_metadata_timestamp ON sync_metadata(local_timestamp DESC);',\n\n\n      // Initial schema version\n      `INSERT OR IGNORE INTO schema_version (version, applied_at, description) \n            VALUES (1, strftime('%s', 'now'), 'Initial database schema with articles, labels, and sync metadata');`,\n    ];\n\n    for (const query of schemaQueries) {\n      try {\n        await this.db.executeSql(query);\n      } catch (error) {\n        console.error('[DatabaseService] Schema query failed:', query, error);\n        throw error;\n      }\n    }\n\n    // Try to initialize FTS5 features (optional - won't fail if not supported)\n    await this.initializeFTS5();\n  }\n\n  /**\n   * Initialize FTS5 full-text search features (optional)\n   */\n  private async initializeFTS5(): Promise<void> {\n    if (!this.db) {\n      return;\n    }\n\n    try {\n      console.log('[DatabaseService] Attempting to initialize FTS5...');\n      \n      const ftsQueries = [\n        // Full-text search table using FTS5\n        `CREATE VIRTUAL TABLE IF NOT EXISTS articles_fts USING fts5(\n                  id UNINDEXED,\n                  title,\n                  summary,\n                  content,\n                  content=articles,\n                  content_rowid=rowid\n              );`,\n\n        // FTS triggers\n        `CREATE TRIGGER IF NOT EXISTS articles_fts_insert \n              AFTER INSERT ON articles \n              BEGIN\n                  INSERT INTO articles_fts(id, title, summary, content) \n                  VALUES (new.id, new.title, new.summary, new.content);\n              END;`,\n\n        `CREATE TRIGGER IF NOT EXISTS articles_fts_update \n              AFTER UPDATE ON articles \n              BEGIN\n                  UPDATE articles_fts \n                  SET title = new.title, summary = new.summary, content = new.content \n                  WHERE id = new.id;\n              END;`,\n\n        `CREATE TRIGGER IF NOT EXISTS articles_fts_delete \n              AFTER DELETE ON articles \n              BEGIN\n                  DELETE FROM articles_fts WHERE id = old.id;\n              END;`,\n      ];\n\n      for (const query of ftsQueries) {\n        await this.db.executeSql(query);\n      }\n\n      console.log('[DatabaseService] FTS5 initialized successfully');\n    } catch (error) {\n      // FTS5 is optional - log as debug instead of warning to reduce noise\n      console.log('[DatabaseService] FTS5 not available, continuing without full-text search features');\n      // Don't throw - FTS5 is optional\n    }\n  }\n\n  /**\n   * Check if database is connected\n   */\n  public isConnected(): boolean {\n    return this.db !== null && this.isInitialized;\n  }\n\n  /**\n   * Close database connection\n   */\n  public async close(): Promise<void> {\n    if (this.db) {\n      await this.db.close();\n      this.db = null;\n      this.isInitialized = false;\n\n      // Close all pooled connections\n      for (const conn of this.connectionPool) {\n        await conn.close();\n      }\n      this.connectionPool = [];\n\n      console.log('[DatabaseService] Database connection closed');\n    }\n  }\n\n  /**\n   * Execute operation within a transaction\n   */\n  public async executeInTransaction<T>(\n    operation: (ctx: TransactionContext) => Promise<T>\n  ): Promise<T> {\n    if (!this.db) {\n      throw this.createDatabaseError(\n        DatabaseErrorCode.CONNECTION_FAILED,\n        'Database not connected'\n      );\n    }\n\n    return new Promise((resolve, reject) => {\n      this.db!.transaction(\n        async tx => {\n          try {\n            const context: TransactionContext = {\n              executeSql: (sql: string, params?: any[]) => {\n                return new Promise<DatabaseResult>(\n                  (resolveQuery, rejectQuery) => {\n                    tx.executeSql(\n                      sql,\n                      params || [],\n                      (_, result) => resolveQuery(result as DatabaseResult),\n                      (_, error) => {\n                        rejectQuery(error);\n                        return false;\n                      }\n                    );\n                  }\n                );\n              },\n              rollback: () => {\n                throw new Error('Transaction rollback requested');\n              },\n            };\n\n            const result = await operation(context);\n            resolve(result);\n          } catch (error) {\n            console.error('[DatabaseService] Transaction error:', error);\n            reject(\n              this.createDatabaseError(\n                DatabaseErrorCode.TRANSACTION_FAILED,\n                'Transaction failed',\n                error\n              )\n            );\n          }\n        },\n        error => {\n          console.error('[DatabaseService] Transaction failed:', error);\n          reject(\n            this.createDatabaseError(\n              DatabaseErrorCode.TRANSACTION_FAILED,\n              'Transaction execution failed',\n              error\n            )\n          );\n        }\n      );\n    });\n  }\n\n  // Article Operations\n  public async createArticle(\n    article: Omit<DBArticle, 'created_at' | 'updated_at'>\n  ): Promise<DatabaseOperationResult<string>> {\n    try {\n      const now = this.createTimestamp();\n      const sql = `\n                INSERT INTO articles (\n                    id, title, summary, content, url, image_url, read_time,\n                    is_archived, is_favorite, is_read, source_url, created_at,\n                    updated_at, synced_at, is_modified, deleted_at\n                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n            `;\n\n      const params = [\n        article.id,\n        article.title,\n        article.summary || null,\n        article.content || null,\n        article.url,\n        article.image_url || null,\n        article.read_time || null,\n        article.is_archived || 0,\n        article.is_favorite || 0,\n        article.is_read || 0,\n        article.source_url || null,\n        now,\n        now,\n        article.synced_at || null,\n        article.is_modified || 0,\n        article.deleted_at || null,\n      ];\n\n      const result = await this.executeSql(sql, params);\n\n      return {\n        success: true,\n        data: article.id,\n        rowsAffected: result.rowsAffected,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to create article: ${error.message}`,\n      };\n    }\n  }\n\n  public async getArticle(\n    id: string\n  ): Promise<DatabaseOperationResult<DBArticle>> {\n    try {\n      const sql = 'SELECT * FROM articles WHERE id = ? AND deleted_at IS NULL';\n      const result = await this.executeSql(sql, [id]);\n\n      if (result.rows.length === 0) {\n        return {\n          success: false,\n          error: 'Article not found',\n        };\n      }\n\n      return {\n        success: true,\n        data: result.rows.item(0) as DBArticle,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to get article: ${error.message}`,\n      };\n    }\n  }\n\n  public async updateArticle(\n    id: string,\n    updates: Partial<DBArticle>\n  ): Promise<DatabaseOperationResult> {\n    try {\n      const updateFields = Object.keys(updates).filter(key => key !== 'id');\n      if (updateFields.length === 0) {\n        return { success: true, rowsAffected: 0 };\n      }\n\n      const setClause = updateFields.map(field => `${field} = ?`).join(', ');\n      const sql = `UPDATE articles SET ${setClause}, updated_at = ? WHERE id = ?`;\n\n      const params = [\n        ...updateFields.map(field => updates[field as keyof DBArticle]),\n        this.createTimestamp(),\n        id,\n      ];\n\n      const result = await this.executeSql(sql, params);\n\n      return {\n        success: true,\n        rowsAffected: result.rowsAffected,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to update article: ${error.message}`,\n      };\n    }\n  }\n\n  public async deleteArticle(\n    id: string,\n    softDelete: boolean = true\n  ): Promise<DatabaseOperationResult> {\n    try {\n      let sql: string;\n      let params: any[];\n\n      if (softDelete) {\n        sql = 'UPDATE articles SET deleted_at = ?, updated_at = ? WHERE id = ?';\n        params = [this.createTimestamp(), this.createTimestamp(), id];\n      } else {\n        sql = 'DELETE FROM articles WHERE id = ?';\n        params = [id];\n      }\n\n      const result = await this.executeSql(sql, params);\n\n      return {\n        success: true,\n        rowsAffected: result.rowsAffected,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to delete article: ${error.message}`,\n      };\n    }\n  }\n\n  public async getArticles(\n    filters?: ArticleFilters\n  ): Promise<DatabaseOperationResult<PaginatedResult<DBArticle>>> {\n    try {\n      const { whereClause, params, countParams } =\n        this.buildArticleQuery(filters);\n\n      // Get total count\n      const countSql = `SELECT COUNT(*) as count FROM articles ${whereClause}`;\n      const countResult = await this.executeSql(countSql, countParams);\n      const totalCount = countResult.rows.item(0).count;\n\n      // Get paginated results\n      const limit = filters?.limit || 50;\n      const offset = filters?.offset || 0;\n      const sortBy = filters?.sortBy || 'created_at';\n      const sortOrder = filters?.sortOrder || 'DESC';\n\n      const sql = `\n                SELECT * FROM articles \n                ${whereClause} \n                ORDER BY ${sortBy} ${sortOrder} \n                LIMIT ? OFFSET ?\n            `;\n\n      const result = await this.executeSql(sql, [...params, limit, offset]);\n      const items = [];\n\n      for (let i = 0; i < result.rows.length; i++) {\n        items.push(result.rows.item(i) as DBArticle);\n      }\n\n      return {\n        success: true,\n        data: {\n          items,\n          totalCount,\n          hasMore: offset + limit < totalCount,\n          limit,\n          offset,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to get articles: ${error.message}`,\n      };\n    }\n  }\n\n  public async searchArticles(\n    query: string,\n    filters?: ArticleFilters\n  ): Promise<DatabaseOperationResult<PaginatedResult<DBArticle>>> {\n    try {\n      const limit = filters?.limit || 50;\n      const offset = filters?.offset || 0;\n\n      // First try FTS5 search with BM25 ranking\n      try {\n        const sql = `\n                  SELECT a.* FROM articles a\n                  JOIN articles_fts fts ON a.id = fts.id\n                  WHERE fts MATCH ? AND a.deleted_at IS NULL\n                  ORDER BY bm25(fts) ASC\n                  LIMIT ? OFFSET ?\n              `;\n\n        const result = await this.executeSql(sql, [query, limit, offset]);\n        const items = [];\n\n        for (let i = 0; i < result.rows.length; i++) {\n          items.push(result.rows.item(i) as DBArticle);\n        }\n\n        // Get total count for search\n        const countSql = `\n                  SELECT COUNT(*) as count FROM articles a\n                  JOIN articles_fts fts ON a.id = fts.id\n                  WHERE fts MATCH ? AND a.deleted_at IS NULL\n              `;\n        const countResult = await this.executeSql(countSql, [query]);\n        const totalCount = countResult.rows.item(0).count;\n\n        return {\n          success: true,\n          data: {\n            items,\n            totalCount,\n            hasMore: offset + limit < totalCount,\n            limit,\n            offset,\n          },\n        };\n      } catch (ftsError) {\n        console.warn('[DatabaseService] FTS5 search failed, falling back to LIKE search:', ftsError);\n        \n        // Fallback to LIKE search if FTS is not available\n        const searchTerm = `%${query}%`;\n        const sql = `\n                  SELECT * FROM articles \n                  WHERE (title LIKE ? OR summary LIKE ? OR content LIKE ?) \n                  AND deleted_at IS NULL\n                  ORDER BY updated_at DESC\n                  LIMIT ? OFFSET ?\n              `;\n\n        const result = await this.executeSql(sql, [searchTerm, searchTerm, searchTerm, limit, offset]);\n        const items = [];\n\n        for (let i = 0; i < result.rows.length; i++) {\n          items.push(result.rows.item(i) as DBArticle);\n        }\n\n        // Get total count for fallback search\n        const countSql = `\n                  SELECT COUNT(*) as count FROM articles \n                  WHERE (title LIKE ? OR summary LIKE ? OR content LIKE ?) \n                  AND deleted_at IS NULL\n              `;\n        const countResult = await this.executeSql(countSql, [searchTerm, searchTerm, searchTerm]);\n        const totalCount = countResult.rows.item(0).count;\n\n        return {\n          success: true,\n          data: {\n            items,\n            totalCount,\n            hasMore: offset + limit < totalCount,\n            limit,\n            offset,\n          },\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to search articles: ${error.message}`,\n      };\n    }\n  }\n\n  // Label Operations\n  public async createLabel(\n    label: Omit<DBLabel, 'id' | 'created_at' | 'updated_at'>\n  ): Promise<DatabaseOperationResult<number>> {\n    try {\n      const now = this.createTimestamp();\n      const sql = `\n                INSERT INTO labels (name, color, created_at, updated_at, synced_at)\n                VALUES (?, ?, ?, ?, ?)\n            `;\n\n      const params = [label.name, label.color, now, now, label.synced_at];\n      const result = await this.executeSql(sql, params);\n\n      return {\n        success: true,\n        data: result.insertId!,\n        rowsAffected: result.rowsAffected,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to create label: ${error.message}`,\n      };\n    }\n  }\n\n  public async getLabel(id: number): Promise<DatabaseOperationResult<DBLabel>> {\n    try {\n      const sql = 'SELECT * FROM labels WHERE id = ?';\n      const result = await this.executeSql(sql, [id]);\n\n      if (result.rows.length === 0) {\n        return {\n          success: false,\n          error: 'Label not found',\n        };\n      }\n\n      return {\n        success: true,\n        data: result.rows.item(0) as DBLabel,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to get label: ${error.message}`,\n      };\n    }\n  }\n\n  public async updateLabel(\n    id: number,\n    updates: Partial<DBLabel>\n  ): Promise<DatabaseOperationResult> {\n    try {\n      const updateFields = Object.keys(updates).filter(key => key !== 'id');\n      if (updateFields.length === 0) {\n        return { success: true, rowsAffected: 0 };\n      }\n\n      const setClause = updateFields.map(field => `${field} = ?`).join(', ');\n      const sql = `UPDATE labels SET ${setClause}, updated_at = ? WHERE id = ?`;\n\n      const params = [\n        ...updateFields.map(field => updates[field as keyof DBLabel]),\n        this.createTimestamp(),\n        id,\n      ];\n\n      const result = await this.executeSql(sql, params);\n\n      return {\n        success: true,\n        rowsAffected: result.rowsAffected,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to update label: ${error.message}`,\n      };\n    }\n  }\n\n  public async deleteLabel(id: number): Promise<DatabaseOperationResult> {\n    try {\n      const sql = 'DELETE FROM labels WHERE id = ?';\n      const result = await this.executeSql(sql, [id]);\n\n      return {\n        success: true,\n        rowsAffected: result.rowsAffected,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to delete label: ${error.message}`,\n      };\n    }\n  }\n\n  public async getLabels(\n    filters?: LabelFilters\n  ): Promise<DatabaseOperationResult<PaginatedResult<DBLabel>>> {\n    try {\n      let whereClause = '';\n      const params: any[] = [];\n\n      if (filters?.searchQuery) {\n        whereClause = 'WHERE name LIKE ?';\n        params.push(`%${filters.searchQuery}%`);\n      }\n\n      // Get total count\n      const countSql = `SELECT COUNT(*) as count FROM labels ${whereClause}`;\n      const countResult = await this.executeSql(countSql, params);\n      const totalCount = countResult.rows.item(0).count;\n\n      // Get paginated results\n      const limit = filters?.limit || 50;\n      const offset = filters?.offset || 0;\n      const sortBy = filters?.sortBy || 'name';\n      const sortOrder = filters?.sortOrder || 'ASC';\n\n      const sql = `\n                SELECT * FROM labels \n                ${whereClause} \n                ORDER BY ${sortBy} ${sortOrder} \n                LIMIT ? OFFSET ?\n            `;\n\n      const result = await this.executeSql(sql, [...params, limit, offset]);\n      const items = [];\n\n      for (let i = 0; i < result.rows.length; i++) {\n        items.push(result.rows.item(i) as DBLabel);\n      }\n\n      return {\n        success: true,\n        data: {\n          items,\n          totalCount,\n          hasMore: offset + limit < totalCount,\n          limit,\n          offset,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to get labels: ${error.message}`,\n      };\n    }\n  }\n\n  // Article-Label Operations\n  public async addLabelToArticle(\n    articleId: string,\n    labelId: number\n  ): Promise<DatabaseOperationResult> {\n    try {\n      const sql = `\n                INSERT OR IGNORE INTO article_labels (article_id, label_id, created_at)\n                VALUES (?, ?, ?)\n            `;\n\n      const result = await this.executeSql(sql, [\n        articleId,\n        labelId,\n        this.createTimestamp(),\n      ]);\n\n      return {\n        success: true,\n        rowsAffected: result.rowsAffected,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to add label to article: ${error.message}`,\n      };\n    }\n  }\n\n  public async removeLabelFromArticle(\n    articleId: string,\n    labelId: number\n  ): Promise<DatabaseOperationResult> {\n    try {\n      const sql =\n        'DELETE FROM article_labels WHERE article_id = ? AND label_id = ?';\n      const result = await this.executeSql(sql, [articleId, labelId]);\n\n      return {\n        success: true,\n        rowsAffected: result.rowsAffected,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to remove label from article: ${error.message}`,\n      };\n    }\n  }\n\n  public async getArticleLabels(\n    articleId: string\n  ): Promise<DatabaseOperationResult<DBLabel[]>> {\n    try {\n      const sql = `\n                SELECT l.* FROM labels l\n                JOIN article_labels al ON l.id = al.label_id\n                WHERE al.article_id = ?\n                ORDER BY l.name ASC\n            `;\n\n      const result = await this.executeSql(sql, [articleId]);\n      const labels = [];\n\n      for (let i = 0; i < result.rows.length; i++) {\n        labels.push(result.rows.item(i) as DBLabel);\n      }\n\n      return {\n        success: true,\n        data: labels,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to get article labels: ${error.message}`,\n      };\n    }\n  }\n\n  public async getLabelArticles(\n    labelId: number\n  ): Promise<DatabaseOperationResult<DBArticle[]>> {\n    try {\n      const sql = `\n                SELECT a.* FROM articles a\n                JOIN article_labels al ON a.id = al.article_id\n                WHERE al.label_id = ? AND a.deleted_at IS NULL\n                ORDER BY a.created_at DESC\n            `;\n\n      const result = await this.executeSql(sql, [labelId]);\n      const articles = [];\n\n      for (let i = 0; i < result.rows.length; i++) {\n        articles.push(result.rows.item(i) as DBArticle);\n      }\n\n      return {\n        success: true,\n        data: articles,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to get label articles: ${error.message}`,\n      };\n    }\n  }\n\n  // Sync Metadata Operations\n  public async createSyncMetadata(\n    metadata: Omit<DBSyncMetadata, 'id' | 'created_at' | 'updated_at'>\n  ): Promise<DatabaseOperationResult<number>> {\n    try {\n      const now = this.createTimestamp();\n      const sql = `\n                INSERT INTO sync_metadata (\n                    entity_type, entity_id, operation, local_timestamp,\n                    server_timestamp, sync_status, conflict_resolution,\n                    retry_count, error_message, created_at, updated_at\n                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n            `;\n\n      const params = [\n        metadata.entity_type,\n        metadata.entity_id,\n        metadata.operation,\n        metadata.local_timestamp,\n        metadata.server_timestamp,\n        metadata.sync_status,\n        metadata.conflict_resolution,\n        metadata.retry_count,\n        metadata.error_message,\n        now,\n        now,\n      ];\n\n      const result = await this.executeSql(sql, params);\n\n      return {\n        success: true,\n        data: result.insertId!,\n        rowsAffected: result.rowsAffected,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to create sync metadata: ${error.message}`,\n      };\n    }\n  }\n\n  public async updateSyncMetadata(\n    id: number,\n    updates: Partial<DBSyncMetadata>\n  ): Promise<DatabaseOperationResult> {\n    try {\n      const updateFields = Object.keys(updates).filter(key => key !== 'id');\n      if (updateFields.length === 0) {\n        return { success: true, rowsAffected: 0 };\n      }\n\n      const setClause = updateFields.map(field => `${field} = ?`).join(', ');\n      const sql = `UPDATE sync_metadata SET ${setClause}, updated_at = ? WHERE id = ?`;\n\n      const params = [\n        ...updateFields.map(field => updates[field as keyof DBSyncMetadata]),\n        this.createTimestamp(),\n        id,\n      ];\n\n      const result = await this.executeSql(sql, params);\n\n      return {\n        success: true,\n        rowsAffected: result.rowsAffected,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to update sync metadata: ${error.message}`,\n      };\n    }\n  }\n\n  public async getSyncMetadata(\n    filters?: SyncMetadataFilters\n  ): Promise<DatabaseOperationResult<PaginatedResult<DBSyncMetadata>>> {\n    try {\n      const conditions = [];\n      const params = [];\n\n      if (filters?.entityType) {\n        conditions.push('entity_type = ?');\n        params.push(filters.entityType);\n      }\n\n      if (filters?.syncStatus) {\n        conditions.push('sync_status = ?');\n        params.push(filters.syncStatus);\n      }\n\n      if (filters?.operation) {\n        conditions.push('operation = ?');\n        params.push(filters.operation);\n      }\n\n      const whereClause =\n        conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      // Get total count\n      const countSql = `SELECT COUNT(*) as count FROM sync_metadata ${whereClause}`;\n      const countResult = await this.executeSql(countSql, params);\n      const totalCount = countResult.rows.item(0).count;\n\n      // Get paginated results\n      const limit = filters?.limit || 50;\n      const offset = filters?.offset || 0;\n\n      const sql = `\n                SELECT * FROM sync_metadata \n                ${whereClause} \n                ORDER BY created_at DESC \n                LIMIT ? OFFSET ?\n            `;\n\n      const result = await this.executeSql(sql, [...params, limit, offset]);\n      const items = [];\n\n      for (let i = 0; i < result.rows.length; i++) {\n        items.push(result.rows.item(i) as DBSyncMetadata);\n      }\n\n      return {\n        success: true,\n        data: {\n          items,\n          totalCount,\n          hasMore: offset + limit < totalCount,\n          limit,\n          offset,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to get sync metadata: ${error.message}`,\n      };\n    }\n  }\n\n  public async deleteSyncMetadata(\n    id: number\n  ): Promise<DatabaseOperationResult> {\n    try {\n      const sql = 'DELETE FROM sync_metadata WHERE id = ?';\n      const result = await this.executeSql(sql, [id]);\n\n      return {\n        success: true,\n        rowsAffected: result.rowsAffected,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to delete sync metadata: ${error.message}`,\n      };\n    }\n  }\n\n  // Utility Operations\n  public async getStats(): Promise<DatabaseOperationResult<DatabaseStats>> {\n    try {\n      const queries = [\n        'SELECT COUNT(*) as count FROM articles WHERE deleted_at IS NULL',\n        'SELECT COUNT(*) as count FROM articles WHERE is_archived = 1 AND deleted_at IS NULL',\n        'SELECT COUNT(*) as count FROM articles WHERE is_favorite = 1 AND deleted_at IS NULL',\n        'SELECT COUNT(*) as count FROM articles WHERE is_read = 0 AND deleted_at IS NULL',\n        'SELECT COUNT(*) as count FROM labels',\n        'SELECT COUNT(*) as count FROM sync_metadata WHERE sync_status = \"pending\"',\n        'SELECT MAX(synced_at) as last_sync FROM articles WHERE synced_at IS NOT NULL',\n      ];\n\n      const results = await Promise.all(\n        queries.map(query => this.executeSql(query))\n      );\n\n      const stats: DatabaseStats = {\n        totalArticles: results[0].rows.item(0).count,\n        archivedArticles: results[1].rows.item(0).count,\n        favoriteArticles: results[2].rows.item(0).count,\n        unreadArticles: results[3].rows.item(0).count,\n        totalLabels: results[4].rows.item(0).count,\n        pendingSyncItems: results[5].rows.item(0).count,\n        databaseSize: 0, // TODO: Implement database size calculation\n        lastSyncAt: results[6].rows.item(0).last_sync,\n      };\n\n      return {\n        success: true,\n        data: stats,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to get stats: ${error.message}`,\n      };\n    }\n  }\n\n  /**\n   * Clear all user data from the database (used during logout)\n   */\n  public async clearAllData(): Promise<DatabaseOperationResult> {\n    try {\n      await this.executeInTransaction(async (ctx) => {\n        // Clear all tables in correct order (respecting foreign key constraints)\n        await ctx.executeSql('DELETE FROM article_labels');\n        await ctx.executeSql('DELETE FROM articles_fts');\n        await ctx.executeSql('DELETE FROM articles');\n        await ctx.executeSql('DELETE FROM labels');\n        await ctx.executeSql('DELETE FROM sync_metadata');\n        \n        console.log('[DatabaseService] All user data cleared from database');\n      });\n      \n      return { success: true };\n    } catch (error) {\n      console.error('[DatabaseService] Failed to clear all data:', error);\n      return {\n        success: false,\n        error: `Failed to clear all data: ${error.message}`,\n      };\n    }\n  }\n\n  public async vacuum(): Promise<DatabaseOperationResult> {\n    try {\n      await this.executeSql('VACUUM;');\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to vacuum database: ${error.message}`,\n      };\n    }\n  }\n\n  public async backup(_path: string): Promise<DatabaseOperationResult> {\n    // TODO: Implement database backup functionality\n    return {\n      success: false,\n      error: 'Backup functionality not implemented yet',\n    };\n  }\n\n  // Migration Operations\n  public async getCurrentVersion(): Promise<number> {\n    try {\n      const sql = 'SELECT MAX(version) as version FROM schema_version';\n      const result = await this.executeSql(sql);\n      return result.rows.item(0).version || 0;\n    } catch (error) {\n      console.error('[DatabaseService] Failed to get current version:', error);\n      return 0;\n    }\n  }\n\n  public async runMigrations(\n    migrations: Migration[]\n  ): Promise<DatabaseOperationResult> {\n    try {\n      const currentVersion = await this.getCurrentVersion();\n      const pendingMigrations = migrations.filter(\n        m => m.version > currentVersion\n      );\n\n      if (pendingMigrations.length === 0) {\n        return { success: true };\n      }\n\n      await this.executeInTransaction(async ctx => {\n        for (const migration of pendingMigrations) {\n          console.log(\n            `[DatabaseService] Running migration ${migration.version}: ${migration.description}`\n          );\n\n          // Execute migration in a nested transaction context\n          await migration.up({\n            executeSql: (sql, params, success, error) => {\n              ctx\n                .executeSql(sql, params)\n                .then(result => success?.(null as any, result as any))\n                .catch(err => error?.(null as any, err));\n            },\n          } as DatabaseTransaction);\n\n          // Record migration completion\n          await ctx.executeSql(\n            'INSERT INTO schema_version (version, applied_at, description) VALUES (?, ?, ?)',\n            [migration.version, this.createTimestamp(), migration.description]\n          );\n        }\n      });\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Migration failed: ${error.message}`,\n      };\n    }\n  }\n\n  private async runPendingMigrations(): Promise<void> {\n    // No pending migrations for initial version\n    // Future migrations will be added here\n  }\n\n  // Helper Methods\n  private async executeSql(\n    sql: string,\n    params: any[] = []\n  ): Promise<DatabaseResult> {\n    if (!this.db) {\n      throw this.createDatabaseError(\n        DatabaseErrorCode.CONNECTION_FAILED,\n        'Database not connected'\n      );\n    }\n\n    try {\n      const [result] = await this.db.executeSql(sql, params);\n      return result as DatabaseResult;\n    } catch (error) {\n      throw this.createDatabaseError(\n        DatabaseErrorCode.QUERY_FAILED,\n        `SQL query failed: ${sql}`,\n        error,\n        sql,\n        params\n      );\n    }\n  }\n\n  private buildArticleQuery(filters?: ArticleFilters): {\n    whereClause: string;\n    params: any[];\n    countParams: any[];\n  } {\n    const conditions = ['deleted_at IS NULL'];\n    const params: any[] = [];\n\n    if (filters?.isArchived !== undefined) {\n      conditions.push('is_archived = ?');\n      params.push(filters.isArchived ? 1 : 0);\n    }\n\n    if (filters?.isFavorite !== undefined) {\n      conditions.push('is_favorite = ?');\n      params.push(filters.isFavorite ? 1 : 0);\n    }\n\n    if (filters?.isRead !== undefined) {\n      conditions.push('is_read = ?');\n      params.push(filters.isRead ? 1 : 0);\n    }\n\n    if (filters?.labelIds && filters.labelIds.length > 0) {\n      const placeholders = filters.labelIds.map(() => '?').join(',');\n      conditions.push(`id IN (\n                SELECT article_id FROM article_labels \n                WHERE label_id IN (${placeholders})\n            )`);\n      params.push(...filters.labelIds);\n    }\n\n    const whereClause =\n      conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n    return {\n      whereClause,\n      params,\n      countParams: [...params],\n    };\n  }\n\n  private createDatabaseError(\n    code: DatabaseErrorCode,\n    message: string,\n    originalError?: any,\n    query?: string,\n    params?: any[]\n  ): DatabaseError {\n    const error = new Error(message) as DatabaseError;\n    error.code = code;\n    error.details = originalError;\n    error.query = query;\n    error.params = params;\n    return error;\n  }\n\n  private createTimestamp(): number {\n    return Math.floor(Date.now() / 1000);\n  }\n}\n\n// Export singleton instance\nexport default DatabaseService.getInstance();\n\n// Export utility functions\nexport const DatabaseUtilityFunctions: DatabaseUtils = {\n  convertDBArticleToArticle(dbArticle: DBArticle): Article {\n    return {\n      id: dbArticle.id,\n      title: dbArticle.title,\n      summary: dbArticle.summary,\n      content: dbArticle.content,\n      url: dbArticle.url,\n      imageUrl: dbArticle.image_url,\n      readTime: dbArticle.read_time,\n      sourceUrl: dbArticle.source_url,\n      isArchived: Boolean(dbArticle.is_archived),\n      isFavorite: Boolean(dbArticle.is_favorite),\n      isRead: Boolean(dbArticle.is_read),\n      isModified: Boolean(dbArticle.is_modified),\n      createdAt: new Date(dbArticle.created_at * 1000).toISOString(),\n      updatedAt: new Date(dbArticle.updated_at * 1000).toISOString(),\n      syncedAt: dbArticle.synced_at\n        ? new Date(dbArticle.synced_at * 1000).toISOString()\n        : undefined,\n      deletedAt: dbArticle.deleted_at\n        ? new Date(dbArticle.deleted_at * 1000).toISOString()\n        : undefined,\n      tags: [], // Tags are loaded separately from article_labels table\n      contentUrl: undefined, // Not stored in database, comes from API\n    } as Article;\n  },\n\n  convertArticleToDBArticle(article: Article): DBArticle {\n    return {\n      id: article.id,\n      title: article.title,\n      summary: article.summary,\n      content: article.content,\n      url: article.url,\n      image_url: article.imageUrl,\n      read_time: article.readTime,\n      source_url: article.sourceUrl,\n      is_archived: article.isArchived ? 1 : 0,\n      is_favorite: article.isFavorite ? 1 : 0,\n      is_read: article.isRead ? 1 : 0,\n      is_modified: article.isModified ? 1 : 0,\n      created_at: Math.floor(new Date(article.createdAt).getTime() / 1000),\n      updated_at: Math.floor(new Date(article.updatedAt).getTime() / 1000),\n      synced_at: article.syncedAt\n        ? Math.floor(new Date(article.syncedAt).getTime() / 1000)\n        : null,\n      deleted_at: article.deletedAt\n        ? Math.floor(new Date(article.deletedAt).getTime() / 1000)\n        : null,\n    };\n  },\n\n  convertDBLabelToLabel(dbLabel: DBLabel): Label {\n    return {\n      ...dbLabel,\n      createdAt: new Date(dbLabel.created_at * 1000),\n      updatedAt: new Date(dbLabel.updated_at * 1000),\n      syncedAt: dbLabel.synced_at\n        ? new Date(dbLabel.synced_at * 1000)\n        : undefined,\n    };\n  },\n\n  convertLabelToDBLabel(label: Label): DBLabel {\n    return {\n      ...label,\n      created_at: Math.floor(label.createdAt.getTime() / 1000),\n      updated_at: Math.floor(label.updatedAt.getTime() / 1000),\n      synced_at: label.syncedAt\n        ? Math.floor(label.syncedAt.getTime() / 1000)\n        : null,\n    };\n  },\n\n  createTimestamp(): number {\n    return Math.floor(Date.now() / 1000);\n  },\n\n  formatTimestamp(timestamp: number): Date {\n    return new Date(timestamp * 1000);\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/services/LabelsApiService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ReadeckApiError' is defined but never used.","line":33,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":45},{"ruleId":"camelcase","severity":2,"message":"Identifier 'per_page' is not in camel case.","line":96,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":96,"endColumn":15},{"ruleId":"camelcase","severity":2,"message":"Identifier 'sort_by' is not in camel case.","line":97,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":97,"endColumn":14},{"ruleId":"camelcase","severity":2,"message":"Identifier 'sort_order' is not in camel case.","line":98,"column":7,"nodeType":"Identifier","messageId":"notCamelCase","endLine":98,"endColumn":17},{"ruleId":"camelcase","severity":2,"message":"Identifier 'sort_by' is not in camel case.","line":112,"column":15,"nodeType":"Identifier","messageId":"notCamelCase","endLine":112,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3242,3245],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3242,3245],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'sort_order' is not in camel case.","line":116,"column":15,"nodeType":"Identifier","messageId":"notCamelCase","endLine":116,"endColumn":25},{"ruleId":"camelcase","severity":2,"message":"Identifier 'include_empty' is not in camel case.","line":120,"column":15,"nodeType":"Identifier","messageId":"notCamelCase","endLine":120,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":131,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3578,3581],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3578,3581],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":136,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":136,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[3668,3732],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async method 'fetchLabels'.","line":240,"column":9,"nodeType":"FunctionExpression","messageId":"missingReturn","endLine":240,"endColumn":20},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":244,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":244,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6674,6745],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":265,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":265,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7434,7594],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async method 'createLabel'.","line":277,"column":9,"nodeType":"FunctionExpression","messageId":"missingReturn","endLine":277,"endColumn":20},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":279,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":279,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7827,7944],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":299,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":299,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8415,8487],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async method 'updateLabel'.","line":309,"column":9,"nodeType":"FunctionExpression","messageId":"missingReturn","endLine":309,"endColumn":20},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":311,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":311,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8714,8844],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":323,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":323,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9158,9230],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":335,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":335,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9457,9585],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":340,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":340,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9613,9616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9613,9616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'transfer_to' is not in camel case.","line":342,"column":22,"nodeType":"Identifier","messageId":"notCamelCase","endLine":342,"endColumn":33},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":348,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":348,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9841,9914],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":359,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":359,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10148,10291],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'article_id' is not in camel case.","line":365,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":365,"endColumn":19},{"ruleId":"camelcase","severity":2,"message":"Identifier 'label_id' is not in camel case.","line":366,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":366,"endColumn":17},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":374,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":374,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10584,10657],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":390,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":390,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10971,11115],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'article_id' is not in camel case.","line":396,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":396,"endColumn":19},{"ruleId":"camelcase","severity":2,"message":"Identifier 'label_id' is not in camel case.","line":397,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":397,"endColumn":17},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":405,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":405,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11408,11482],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async method 'getLabel'.","line":419,"column":9,"nodeType":"FunctionExpression","messageId":"missingReturn","endLine":419,"endColumn":17},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":424,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":424,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11863,11925],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":428,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":428,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11969,12023],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":436,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":436,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[12234,12306],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async method 'batchAssignLabels'.","line":446,"column":9,"nodeType":"FunctionExpression","messageId":"missingReturn","endLine":446,"endColumn":26},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":450,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":450,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[12594,12806],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'label_ids' is not in camel case.","line":460,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":460,"endColumn":18},{"ruleId":"camelcase","severity":2,"message":"Identifier 'article_ids' is not in camel case.","line":461,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":461,"endColumn":20},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":471,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":471,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[13250,13412],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async method 'getLabelStats'.","line":484,"column":9,"nodeType":"FunctionExpression","messageId":"missingReturn","endLine":484,"endColumn":22},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":486,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":486,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[13633,13693],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async method 'batchUpdateLabels'.","line":519,"column":9,"nodeType":"FunctionExpression","messageId":"missingReturn","endLine":519,"endColumn":26},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":523,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":523,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[14771,14844],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":531,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":531,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[15051,15159],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":549,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":549,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[15429,15498],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":556,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":556,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[15650,15755],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async method 'searchLabels'.","line":568,"column":9,"nodeType":"FunctionExpression","messageId":"missingReturn","endLine":568,"endColumn":21},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":570,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":570,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[15977,16036],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async method 'getLabelsForArticle'.","line":588,"column":9,"nodeType":"FunctionExpression","messageId":"missingReturn","endLine":588,"endColumn":28},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":590,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":590,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[16437,16511],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":601,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":601,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[16850,16964],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":620,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":620,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[17202,17256],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":23,"fatalErrorCount":0,"warningCount":30,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Labels API Service\n * Bridge between ReadeckApiService and Redux labels management\n * Handles CRUD operations for Readeck labels/tags with comprehensive error handling\n */\n\nimport { readeckApiService } from './ReadeckApiService';\nimport { PaginatedResponse } from '../types';\nimport {\n  Label,\n  ReadeckLabel,\n  ReadeckLabelList,\n  CreateLabelRequest,\n  UpdateLabelRequest,\n  LabelFilters,\n  ILabelsApiService,\n  FetchLabelsParams,\n  CreateLabelParams,\n  UpdateLabelParams,\n  DeleteLabelParams,\n  AssignLabelToArticleParams,\n  RemoveLabelFromArticleParams,\n  BatchAssignLabelsParams,\n  BatchLabelAssignmentResult,\n  LabelStats,\n  LabelApiError,\n  LabelErrorCode,\n  LabelCacheEntry,\n  AssignLabelRequest,\n  RemoveLabelRequest,\n  BatchLabelAssignmentRequest,\n} from '../types/labels';\nimport { ReadeckApiResponse, ReadeckApiError } from '../types/readeck';\n\n/**\n * LabelsApiService - Comprehensive labels management service\n *\n * Features:\n * - Full CRUD operations for labels (fetch, create, update, delete)\n * - Label assignment/removal operations with articles\n * - Type conversion between ReadeckLabel and Label formats\n * - Pagination response transformation\n * - Comprehensive error handling with proper error propagation\n * - Caching mechanisms for improved performance\n * - Batch operations for efficient bulk updates\n * - Statistics and analytics for label usage\n * - Consistent interface for Redux async thunks\n */\nclass LabelsApiService implements ILabelsApiService {\n  private labelCache = new Map<string, LabelCacheEntry>();\n  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n  private readonly MAX_CACHE_SIZE = 1000;\n\n  /**\n   * Convert ReadeckLabel (snake_case) to Label (camelCase)\n   * @private\n   */\n  private convertReadeckLabelToLabel(readeckLabel: ReadeckLabel): Label {\n    return {\n      id: readeckLabel.id,\n      name: readeckLabel.name,\n      color: readeckLabel.color,\n      description: readeckLabel.description,\n      articleCount: readeckLabel.article_count,\n      createdAt: readeckLabel.created_at,\n      updatedAt: readeckLabel.updated_at,\n    };\n  }\n\n  /**\n   * Convert Label (camelCase) to UpdateLabelRequest (snake_case)\n   * @private\n   */\n  private convertLabelToUpdateRequest(\n    updates: Partial<Label>\n  ): UpdateLabelRequest {\n    const request: UpdateLabelRequest = {};\n\n    if (updates.name !== undefined) request.name = updates.name;\n    if (updates.color !== undefined) request.color = updates.color;\n    if (updates.description !== undefined)\n      request.description = updates.description;\n\n    return request;\n  }\n\n  /**\n   * Convert filters to LabelFilters format\n   * @private\n   */\n  private convertFiltersToReadeckFilters(\n    params: FetchLabelsParams\n  ): LabelFilters {\n    const filters: LabelFilters = {\n      page: params.page || 1,\n      per_page: params.limit || 50,\n      sort_by: 'name',\n      sort_order: 'asc',\n    };\n\n    if (params.searchQuery) {\n      filters.search = params.searchQuery;\n    }\n\n    if (params.sortBy) {\n      const sortByMap: Record<string, string> = {\n        name: 'name',\n        createdAt: 'created_at',\n        updatedAt: 'updated_at',\n        articleCount: 'article_count',\n      };\n      filters.sort_by = sortByMap[params.sortBy] as any;\n    }\n\n    if (params.sortOrder) {\n      filters.sort_order = params.sortOrder;\n    }\n\n    if (params.includeEmpty !== undefined) {\n      filters.include_empty = params.includeEmpty;\n    }\n\n    return filters;\n  }\n\n  /**\n   * Handle API errors with proper error propagation\n   * @private\n   */\n  private handleApiError(\n    error: any,\n    operation: string,\n    labelId?: string,\n    articleId?: string\n  ): never {\n    console.error(`[LabelsApiService] ${operation} failed:`, error);\n\n    if (error.code && error.message) {\n      // ReadeckApiError - convert to LabelApiError\n      const labelError: LabelApiError = {\n        code: this.mapReadeckErrorToLabelError(error.code),\n        message: error.message,\n        labelId,\n        articleId,\n        statusCode: error.statusCode,\n        details: error.details,\n        retryable: error.retryable,\n        timestamp: new Date().toISOString(),\n      };\n      throw labelError;\n    } else {\n      // Unknown error - wrap in standard format\n      const labelError: LabelApiError = {\n        code: LabelErrorCode.UNKNOWN_LABEL_ERROR,\n        message: `${operation} failed: ${error.message || String(error)}`,\n        labelId,\n        articleId,\n        retryable: false,\n        timestamp: new Date().toISOString(),\n      };\n      throw labelError;\n    }\n  }\n\n  /**\n   * Map ReadeckErrorCode to LabelErrorCode\n   * @private\n   */\n  private mapReadeckErrorToLabelError(readeckCode: string): LabelErrorCode {\n    switch (readeckCode) {\n      case 'AUTHENTICATION_ERROR':\n      case 'AUTHORIZATION_ERROR':\n        return LabelErrorCode.UNKNOWN_LABEL_ERROR;\n      case 'NETWORK_ERROR':\n      case 'CONNECTION_ERROR':\n      case 'TIMEOUT_ERROR':\n        return LabelErrorCode.UNKNOWN_LABEL_ERROR;\n      case 'SERVER_ERROR':\n        return LabelErrorCode.UNKNOWN_LABEL_ERROR;\n      default:\n        return LabelErrorCode.UNKNOWN_LABEL_ERROR;\n    }\n  }\n\n  /**\n   * Cache management methods\n   * @private\n   */\n  private getCachedLabel(id: string): Label | null {\n    const entry = this.labelCache.get(id);\n    if (!entry) return null;\n\n    const now = Date.now();\n    if (entry.expiresAt && now > new Date(entry.expiresAt).getTime()) {\n      this.labelCache.delete(id);\n      return null;\n    }\n\n    entry.accessCount++;\n    entry.lastAccessed = new Date().toISOString();\n    return entry.label;\n  }\n\n  private cacheLabel(label: Label): void {\n    if (this.labelCache.size >= this.MAX_CACHE_SIZE) {\n      // Remove oldest entries\n      const entries = [...this.labelCache.entries()];\n      entries.sort(\n        (a, b) =>\n          new Date(a[1].lastAccessed).getTime() -\n          new Date(b[1].lastAccessed).getTime()\n      );\n\n      const toRemove = entries.slice(0, Math.floor(this.MAX_CACHE_SIZE / 4));\n      toRemove.forEach(([key]) => this.labelCache.delete(key));\n    }\n\n    const entry: LabelCacheEntry = {\n      label,\n      cachedAt: new Date().toISOString(),\n      expiresAt: new Date(Date.now() + this.CACHE_TTL).toISOString(),\n      accessCount: 1,\n      lastAccessed: new Date().toISOString(),\n    };\n\n    this.labelCache.set(label.id, entry);\n  }\n\n  private invalidateCache(id?: string): void {\n    if (id) {\n      this.labelCache.delete(id);\n    } else {\n      this.labelCache.clear();\n    }\n  }\n\n  /**\n   * Fetch labels with pagination and filtering\n   */\n  async fetchLabels(\n    params: FetchLabelsParams\n  ): Promise<PaginatedResponse<Label>> {\n    try {\n      console.log('[LabelsApiService] Fetching labels with params:', params);\n\n      const filters = this.convertFiltersToReadeckFilters(params);\n      const response: ReadeckApiResponse<ReadeckLabelList> =\n        await readeckApiService.getLabels(filters);\n\n      const labels = response.data.labels.map(readeckLabel => {\n        const label = this.convertReadeckLabelToLabel(readeckLabel);\n        if (!params.forceRefresh) {\n          this.cacheLabel(label);\n        }\n        return label;\n      });\n\n      const paginatedResponse: PaginatedResponse<Label> = {\n        items: labels,\n        page: response.data.pagination.page,\n        totalPages: response.data.pagination.total_pages,\n        totalItems: response.data.pagination.total_count,\n      };\n\n      console.log(\n        `[LabelsApiService] Successfully fetched ${labels.length} labels (page ${paginatedResponse.page}/${paginatedResponse.totalPages})`\n      );\n      return paginatedResponse;\n    } catch (error) {\n      this.handleApiError(error, 'Fetch labels');\n    }\n  }\n\n  /**\n   * Create a new label\n   */\n  async createLabel(params: CreateLabelParams): Promise<Label> {\n    try {\n      console.log('[LabelsApiService] Creating label:', {\n        name: params.name,\n        color: params.color,\n      });\n\n      const createRequest: CreateLabelRequest = {\n        name: params.name,\n        color: params.color,\n        description: params.description,\n      };\n\n      const response: ReadeckApiResponse<ReadeckLabel> =\n        await readeckApiService.createLabel(createRequest);\n\n      const label = this.convertReadeckLabelToLabel(response.data);\n      this.cacheLabel(label);\n\n      // Invalidate list cache since we added a new label\n      this.invalidateCache();\n\n      console.log('[LabelsApiService] Successfully created label:', label.id);\n      return label;\n    } catch (error) {\n      this.handleApiError(error, 'Create label');\n    }\n  }\n\n  /**\n   * Update an existing label\n   */\n  async updateLabel(params: UpdateLabelParams): Promise<Label> {\n    try {\n      console.log('[LabelsApiService] Updating label:', {\n        id: params.id,\n        updates: Object.keys(params.updates),\n      });\n\n      const updateRequest = this.convertLabelToUpdateRequest(params.updates);\n      const response: ReadeckApiResponse<ReadeckLabel> =\n        await readeckApiService.updateLabel(params.id, updateRequest);\n\n      const label = this.convertReadeckLabelToLabel(response.data);\n      this.cacheLabel(label);\n\n      console.log('[LabelsApiService] Successfully updated label:', label.id);\n      return label;\n    } catch (error) {\n      this.handleApiError(error, 'Update label', params.id);\n    }\n  }\n\n  /**\n   * Delete a label\n   */\n  async deleteLabel(params: DeleteLabelParams): Promise<void> {\n    try {\n      console.log('[LabelsApiService] Deleting label:', {\n        id: params.id,\n        transferTo: params.transferToLabel,\n      });\n\n      const deleteParams: any = {};\n      if (params.transferToLabel) {\n        deleteParams.transfer_to = params.transferToLabel;\n      }\n\n      await readeckApiService.deleteLabel(params.id, deleteParams);\n\n      this.invalidateCache(params.id);\n      console.log('[LabelsApiService] Successfully deleted label:', params.id);\n    } catch (error) {\n      this.handleApiError(error, 'Delete label', params.id);\n    }\n  }\n\n  /**\n   * Assign a label to an article\n   */\n  async assignToArticle(params: AssignLabelToArticleParams): Promise<void> {\n    try {\n      console.log('[LabelsApiService] Assigning label to article:', {\n        labelId: params.labelId,\n        articleId: params.articleId,\n      });\n\n      const assignRequest: AssignLabelRequest = {\n        article_id: params.articleId,\n        label_id: params.labelId,\n      };\n\n      await readeckApiService.assignLabel(assignRequest);\n\n      // Invalidate cache for the affected label\n      this.invalidateCache(params.labelId);\n\n      console.log('[LabelsApiService] Successfully assigned label to article');\n    } catch (error) {\n      this.handleApiError(\n        error,\n        'Assign label to article',\n        params.labelId,\n        params.articleId\n      );\n    }\n  }\n\n  /**\n   * Remove a label from an article\n   */\n  async removeFromArticle(params: RemoveLabelFromArticleParams): Promise<void> {\n    try {\n      console.log('[LabelsApiService] Removing label from article:', {\n        labelId: params.labelId,\n        articleId: params.articleId,\n      });\n\n      const removeRequest: RemoveLabelRequest = {\n        article_id: params.articleId,\n        label_id: params.labelId,\n      };\n\n      await readeckApiService.removeLabel(removeRequest);\n\n      // Invalidate cache for the affected label\n      this.invalidateCache(params.labelId);\n\n      console.log('[LabelsApiService] Successfully removed label from article');\n    } catch (error) {\n      this.handleApiError(\n        error,\n        'Remove label from article',\n        params.labelId,\n        params.articleId\n      );\n    }\n  }\n\n  /**\n   * Get a single label by ID\n   */\n  async getLabel(id: string): Promise<Label> {\n    try {\n      // Check cache first\n      const cachedLabel = this.getCachedLabel(id);\n      if (cachedLabel) {\n        console.log('[LabelsApiService] Returning cached label:', id);\n        return cachedLabel;\n      }\n\n      console.log('[LabelsApiService] Fetching label:', id);\n\n      const response: ReadeckApiResponse<ReadeckLabel> =\n        await readeckApiService.getLabel(id);\n\n      const label = this.convertReadeckLabelToLabel(response.data);\n      this.cacheLabel(label);\n\n      console.log('[LabelsApiService] Successfully fetched label:', label.id);\n      return label;\n    } catch (error) {\n      this.handleApiError(error, 'Get label', id);\n    }\n  }\n\n  /**\n   * Batch assign/remove labels to/from articles\n   */\n  async batchAssignLabels(\n    params: BatchAssignLabelsParams\n  ): Promise<BatchLabelAssignmentResult> {\n    try {\n      console.log(\n        '[LabelsApiService] Batch label operation:',\n        params.operation,\n        {\n          labelIds: params.labelIds.length,\n          articleIds: params.articleIds.length,\n        }\n      );\n\n      const batchRequest: BatchLabelAssignmentRequest = {\n        label_ids: params.labelIds,\n        article_ids: params.articleIds,\n        operation: params.operation,\n      };\n\n      const response: ReadeckApiResponse<BatchLabelAssignmentResult> =\n        await readeckApiService.batchLabels(batchRequest);\n\n      // Invalidate cache for all affected labels\n      params.labelIds.forEach(labelId => this.invalidateCache(labelId));\n\n      console.log(\n        `[LabelsApiService] Batch operation completed: ${response.data.successful.length} successful, ${response.data.failed.length} failed`\n      );\n\n      return response.data;\n    } catch (error) {\n      this.handleApiError(error, 'Batch assign labels');\n    }\n  }\n\n  /**\n   * Get label statistics\n   */\n  async getLabelStats(): Promise<LabelStats> {\n    try {\n      console.log('[LabelsApiService] Fetching label statistics');\n\n      const response: ReadeckApiResponse<{\n        total_labels: number;\n        total_assignments: number;\n        most_used: Array<{\n          label: ReadeckLabel;\n          article_count: number;\n        }>;\n        unused_count: number;\n        average_labels_per_article: number;\n      }> = await readeckApiService.getLabelStats();\n\n      const stats: LabelStats = {\n        totalLabels: response.data.total_labels,\n        totalAssignments: response.data.total_assignments,\n        mostUsedLabels: response.data.most_used.map(item => ({\n          label: this.convertReadeckLabelToLabel(item.label),\n          articleCount: item.article_count,\n        })),\n        unusedLabels: response.data.unused_count,\n        averageLabelsPerArticle: response.data.average_labels_per_article,\n      };\n\n      return stats;\n    } catch (error) {\n      this.handleApiError(error, 'Get label stats');\n    }\n  }\n\n  /**\n   * Batch update multiple labels\n   */\n  async batchUpdateLabels(\n    updates: Array<{ id: string; updates: Partial<Label> }>\n  ): Promise<Label[]> {\n    try {\n      console.log('[LabelsApiService] Batch updating labels:', updates.length);\n\n      const updatePromises = updates.map(({ id, updates: labelUpdates }) =>\n        this.updateLabel({ id, updates: labelUpdates })\n      );\n\n      const labels = await Promise.all(updatePromises);\n\n      console.log(\n        '[LabelsApiService] Successfully batch updated labels:',\n        labels.length\n      );\n      return labels;\n    } catch (error) {\n      this.handleApiError(error, 'Batch update labels');\n    }\n  }\n\n  /**\n   * Batch delete multiple labels\n   */\n  async batchDeleteLabels(\n    ids: string[],\n    transferToLabel?: string\n  ): Promise<void> {\n    try {\n      console.log('[LabelsApiService] Batch deleting labels:', ids.length);\n\n      const deletePromises = ids.map(id =>\n        this.deleteLabel({ id, transferToLabel })\n      );\n      await Promise.all(deletePromises);\n\n      console.log(\n        '[LabelsApiService] Successfully batch deleted labels:',\n        ids.length\n      );\n    } catch (error) {\n      this.handleApiError(error, 'Batch delete labels');\n    }\n  }\n\n  /**\n   * Search labels by name\n   */\n  async searchLabels(query: string, limit: number = 20): Promise<Label[]> {\n    try {\n      console.log('[LabelsApiService] Searching labels:', query);\n\n      const response = await this.fetchLabels({\n        searchQuery: query,\n        limit,\n        sortBy: 'name',\n        sortOrder: 'asc',\n      });\n\n      return response.items;\n    } catch (error) {\n      this.handleApiError(error, 'Search labels');\n    }\n  }\n\n  /**\n   * Get labels for a specific article\n   */\n  async getLabelsForArticle(articleId: string): Promise<Label[]> {\n    try {\n      console.log('[LabelsApiService] Fetching labels for article:', articleId);\n\n      const response: ReadeckApiResponse<{ labels: ReadeckLabel[] }> =\n        await readeckApiService.getArticleLabels(articleId);\n\n      const labels = response.data.labels.map(readeckLabel => {\n        const label = this.convertReadeckLabelToLabel(readeckLabel);\n        this.cacheLabel(label);\n        return label;\n      });\n\n      console.log(\n        '[LabelsApiService] Successfully fetched labels for article:',\n        labels.length\n      );\n      return labels;\n    } catch (error) {\n      this.handleApiError(\n        error,\n        'Get labels for article',\n        undefined,\n        articleId\n      );\n    }\n  }\n\n  /**\n   * Clear all caches\n   */\n  clearCache(): void {\n    console.log('[LabelsApiService] Clearing all caches');\n    this.invalidateCache();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): {\n    size: number;\n    maxSize: number;\n    hitRate: number;\n    entries: Array<{ id: string; accessCount: number; lastAccessed: string }>;\n  } {\n    const entries = [...this.labelCache.entries()].map(([id, entry]) => ({\n      id,\n      accessCount: entry.accessCount,\n      lastAccessed: entry.lastAccessed,\n    }));\n\n    const totalAccesses = entries.reduce(\n      (sum, entry) => sum + entry.accessCount,\n      0\n    );\n    const hitRate =\n      totalAccesses > 0 ? (entries.length / totalAccesses) * 100 : 0;\n\n    return {\n      size: this.labelCache.size,\n      maxSize: this.MAX_CACHE_SIZE,\n      hitRate,\n      entries,\n    };\n  }\n}\n\n// Export singleton instance for consistent usage across the app\nexport const labelsApiService = new LabelsApiService();\n\n// Export class for testing and custom instantiation\nexport default LabelsApiService;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/services/ReadeckApiService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'validateToken' is defined but never used.","line":17,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":16},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":81,"column":27,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":81,"endColumn":51},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":191,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":191,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6382,6385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6382,6385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":192,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6431,6434],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6431,6434],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'handledError' is assigned a value but never used.","line":217,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":217,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":230,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":230,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7701,7704],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7701,7704],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":241,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":241,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8079,8082],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8079,8082],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":252,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":252,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8435,8438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8435,8438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":325,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":325,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10690,10693],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10690,10693],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":352,"column":31,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":352,"endColumn":32,"suggestions":[{"messageId":"removeEscape","fix":{"range":[11556,11557],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[11556,11556],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":353,"column":20,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":353,"endColumn":21,"suggestions":[{"messageId":"removeEscape","fix":{"range":[11605,11606],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[11605,11605],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":353,"column":28,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":353,"endColumn":29,"suggestions":[{"messageId":"removeEscape","fix":{"range":[11613,11614],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[11613,11613],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":353,"column":38,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":353,"endColumn":39,"suggestions":[{"messageId":"removeEscape","fix":{"range":[11623,11624],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[11623,11623],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":356,"column":22,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":356,"endColumn":23,"suggestions":[{"messageId":"removeEscape","fix":{"range":[11795,11796],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[11795,11795],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":363,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":363,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11943,11946],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11943,11946],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":435,"column":11,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":435,"endColumn":21},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":510,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":531,"endColumn":6},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":511,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":511,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[16553,16620],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":519,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":519,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[16833,16900],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":520,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":520,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[16907,17150],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":563,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":613,"endColumn":6},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":564,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":564,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[18028,18110],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":565,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":565,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[18117,18191],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":594,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":594,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[19358,19429],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":607,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":607,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[19749,19847],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":646,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":646,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[21050,21132],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":649,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":649,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21200,21203],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21200,21203],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'updated_since' is not in camel case.","line":651,"column":15,"nodeType":"Identifier","messageId":"notCamelCase","endLine":651,"endColumn":28},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":657,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":676,"endColumn":6},{"ruleId":"camelcase","severity":2,"message":"Identifier 'last_updated' is not in camel case.","line":663,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":663,"endColumn":21},{"ruleId":"camelcase","severity":2,"message":"Identifier 'total_count' is not in camel case.","line":664,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":664,"endColumn":20},{"ruleId":"camelcase","severity":2,"message":"Identifier 'has_more' is not in camel case.","line":665,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":665,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":680,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":680,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22274,22277],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22274,22277],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":680,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":680,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22307,22310],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22307,22310],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":681,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":681,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22343,22346],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22343,22346],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":688,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":688,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22502,22505],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22502,22505],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":689,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":689,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22538,22541],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22538,22541],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":698,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":698,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22737,22740],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22737,22740],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":699,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":699,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22773,22776],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22773,22776],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":714,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":714,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23231,23234],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23231,23234],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":718,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":718,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23308,23311],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23308,23311],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":718,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":718,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23341,23344],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23341,23344],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":724,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":724,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23632,23635],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23632,23635],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":729,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":729,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23863,23866],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23863,23866],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":734,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":734,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24086,24089],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24086,24089],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":734,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":734,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24119,24122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24119,24122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":739,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":739,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24360,24363],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24360,24363],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":744,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":744,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24600,24603],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24600,24603],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":757,"column":24,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":757,"endColumn":48}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":35,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Readeck API Service with API token authentication\n * Comprehensive HTTP client with error handling, retry logic, and network resilience\n */\n\nimport axios, {\n  AxiosInstance,\n  AxiosRequestConfig,\n  AxiosResponse,\n  AxiosError,\n} from 'axios';\nimport { authStorageService } from './AuthStorageService';\nimport { errorHandler, ErrorCategory } from '../utils/errorHandler';\nimport { logger } from '../utils/logger';\nimport {\n  validateUrl,\n  validateToken,\n  getSecurityHeaders,\n  defaultRateLimiter,\n  maskSensitiveData,\n} from '../utils/security';\nimport {\n  IReadeckApiService,\n  ReadeckApiConfig,\n  ReadeckApiError,\n  ReadeckErrorCode,\n  ReadeckApiResponse,\n  ReadeckLoginRequest,\n  ReadeckLoginResponse,\n  ReadeckUser,\n  ReadeckArticleList,\n  ReadeckArticle,\n  CreateArticleRequest,\n  UpdateArticleRequest,\n  ArticleFilters,\n  ReadeckUserProfile,\n  ReadeckSystemInfo,\n  ReadeckSyncResponse,\n  SyncRequest,\n  RequestConfig,\n  NetworkState,\n  RetryConfig,\n  ApiRequestOptions,\n} from '../types/readeck';\n\n/**\n * ReadeckApiService - Production-ready API client for Readeck servers\n *\n * Features:\n * - API token authentication with automatic retrieval from secure storage\n * - Intelligent retry logic with exponential backoff\n * - Comprehensive error handling and categorization\n * - Network connectivity awareness\n * - Request/response logging for debugging\n * - Timeout management and cancellation support\n */\nclass ReadeckApiService implements IReadeckApiService {\n  private readonly client: AxiosInstance;\n  private config: ReadeckApiConfig;\n  private retryConfig: RetryConfig;\n  private networkState: NetworkState;\n  private certificatePins: Map<string, string[]> = new Map();\n\n  constructor(config: Partial<ReadeckApiConfig> = {}) {\n    // Default configuration with security enforcement\n    const isDevMode = typeof __DEV__ !== 'undefined' ? __DEV__ : false;\n    const defaultBaseUrl = isDevMode ? 'http://localhost:8000/api' : 'https://localhost:8000/api';\n    this.config = {\n      baseUrl: config.baseUrl || defaultBaseUrl,\n      timeout: 30000, // 30 seconds\n      retryAttempts: 3,\n      retryDelay: 1000, // 1 second base delay\n      ...config,\n    };\n\n    // Validate and sanitize base URL\n    const urlValidation = validateUrl(this.config.baseUrl);\n    if (!urlValidation.isValid) {\n      throw new Error(`Invalid API base URL: ${urlValidation.error}`);\n    }\n    this.config.baseUrl = urlValidation.sanitized!;\n\n    // Retry configuration\n    this.retryConfig = {\n      attempts: this.config.retryAttempts,\n      delay: this.config.retryDelay,\n      backoffMultiplier: 2,\n      maxDelay: 10000, // 10 seconds max\n      retryableStatusCodes: [408, 429, 500, 502, 503, 504],\n      retryableErrorCodes: [\n        ReadeckErrorCode.NETWORK_ERROR,\n        ReadeckErrorCode.TIMEOUT_ERROR,\n        ReadeckErrorCode.SERVER_ERROR,\n        ReadeckErrorCode.SERVICE_UNAVAILABLE,\n        ReadeckErrorCode.CONNECTION_ERROR,\n      ],\n    };\n\n    // Network state initialization\n    this.networkState = {\n      isConnected: true,\n      isWifiEnabled: false,\n      isCellularEnabled: false,\n      networkType: 'unknown',\n    };\n\n    // Create axios instance with security headers\n    this.client = axios.create({\n      baseURL: this.config.baseUrl,\n      timeout: this.config.timeout,\n      headers: {\n        'Content-Type': 'application/json',\n        Accept: 'application/json',\n        'User-Agent': 'Mobdeck-Mobile-Client/1.0.0',\n        ...getSecurityHeaders(),\n      },\n      // Additional security configurations\n      maxRedirects: 5,\n      validateStatus: (status) => status >= 200 && status < 300,\n      withCredentials: false, // Prevent CORS credential leaks\n    });\n\n    this.setupInterceptors();\n  }\n\n  /**\n   * Setup request and response interceptors\n   * @private\n   */\n  private setupInterceptors(): void {\n    // Request interceptor for API token injection and security checks\n    this.client.interceptors.request.use(\n      async config => {\n        // Rate limiting check\n        const endpoint = `${config.method}:${config.url}`;\n        if (!defaultRateLimiter.isAllowed(endpoint)) {\n          throw this.createApiError(\n            new Error('Rate limit exceeded'),\n            ReadeckErrorCode.RATE_LIMITED\n          );\n        }\n\n        // Skip auth for login endpoint\n        if (config.url?.includes('/auth')) {\n          return config;\n        }\n\n        try {\n          const token = await authStorageService.retrieveToken();\n          if (token) {\n            // Debug: Log token characteristics\n            logger.debug('Token retrieved for validation', { \n              length: token.length, \n              startsWithBearer: token.startsWith('Bearer'),\n              hasSpecialChars: /[^A-Za-z0-9-_.]/.test(token),\n              preview: `${token.substring(0, 10)  }...`\n            });\n            \n            // Temporarily bypass token validation for testing\n            // TODO: Implement proper token validation for Readeck API tokens\n            logger.debug('Token validation bypassed for testing');\n            config.headers.Authorization = `Bearer ${token}`;\n            logger.debug('API token attached to request', { \n              url: config.url,\n              tokenPreview: maskSensitiveData(token)\n            });\n          } else {\n            // Silently cancel requests without authentication\n            // Return a rejected promise to prevent the request from proceeding\n            return Promise.reject({\n              name: 'AuthenticationError',\n              message: 'No API token available',\n              silent: true, // Flag to indicate this should be handled silently\n            });\n          }\n        } catch (error) {\n          // Only handle actual errors, not authentication cancellations\n          if (error.name !== 'AuthenticationError') {\n            const handledError = errorHandler.handleError(error, {\n              category: ErrorCategory.AUTHENTICATION,\n              context: { actionType: 'token_retrieval', apiEndpoint: config.url },\n            });\n            logger.error('Failed to retrieve API token', { error: handledError });\n          }\n          return Promise.reject(error);\n        }\n\n        // Log request details and start performance timer\n        const operationId = `api_${config.method}_${config.url}`;\n        logger.startPerformanceTimer(operationId);\n        (config as any)._startTime = Date.now();\n        (config as any)._operationId = operationId;\n        \n        // Validate request URL\n        if (config.url) {\n          const fullUrl = config.url.startsWith('http') ? config.url : `${config.baseURL}${config.url}`;\n          const urlValidation = validateUrl(fullUrl);\n          if (!urlValidation.isValid) {\n            throw new Error(`Invalid request URL: ${urlValidation.error}`);\n          }\n        }\n\n        logger.debug('API Request initiated', {\n          method: config.method,\n          url: config.url,\n          hasAuth: !!config.headers.Authorization,\n        });\n\n        return config;\n      },\n      error => {\n        // Handle silent authentication errors without logging\n        if (error.silent && error.name === 'AuthenticationError') {\n          return Promise.reject(error);\n        }\n        \n        const handledError = errorHandler.handleError(error, {\n          category: ErrorCategory.NETWORK,\n          context: { actionType: 'request_interceptor' },\n        });\n        return Promise.reject(\n          this.createApiError(error, ReadeckErrorCode.UNKNOWN_ERROR)\n        );\n      }\n    );\n\n    // Response interceptor for error handling\n    this.client.interceptors.response.use(\n      response => {\n        const operationId = (response.config as any)._operationId;\n        if (operationId) {\n          logger.endPerformanceTimer(operationId, {\n            status: response.status,\n            url: response.config.url,\n          });\n        }\n        \n        logger.debug('API Response received', {\n          status: response.status,\n          url: response.config.url,\n          duration: Date.now() - (response.config as any)._startTime,\n        });\n        return response;\n      },\n      error => {\n        // Handle silent authentication errors without logging\n        if (error.silent && error.name === 'AuthenticationError') {\n          return Promise.reject(error);\n        }\n\n        // End performance timer for error cases\n        const operationId = (error.config as any)?._operationId;\n        if (operationId) {\n          logger.endPerformanceTimer(operationId, {\n            status: error.response?.status || 0,\n            url: error.config?.url,\n            error: true,\n          });\n        }\n        \n        const apiError = this.handleResponseError(error);\n        return Promise.reject(apiError);\n      }\n    );\n  }\n\n  /**\n   * Get error category for centralized error handling\n   * @private\n   */\n  private getErrorCategory(error: AxiosError): ErrorCategory {\n    if (!error.response) {\n      return ErrorCategory.NETWORK;\n    }\n    \n    const status = error.response.status;\n    if (status === 401) {\n      return ErrorCategory.AUTHENTICATION;\n    } else if (status >= 400 && status < 500) {\n      return ErrorCategory.VALIDATION;\n    } else if (status >= 500) {\n      return ErrorCategory.NETWORK;\n    }\n    \n    return ErrorCategory.UNKNOWN;\n  }\n\n  /**\n   * Handle response errors with proper categorization\n   * @private\n   */\n  private handleResponseError(error: AxiosError): ReadeckApiError {\n    if (!error.response) {\n      // Network or connection error\n      if (error.code === 'ECONNABORTED') {\n        return this.createApiError(error, ReadeckErrorCode.TIMEOUT_ERROR);\n      }\n      return this.createApiError(error, ReadeckErrorCode.CONNECTION_ERROR);\n    }\n\n    const { status } = error.response;\n\n    // Categorize by HTTP status code\n    if (status === 401) {\n      return this.createApiError(error, ReadeckErrorCode.AUTHENTICATION_ERROR);\n    } else if (status === 403) {\n      return this.createApiError(error, ReadeckErrorCode.AUTHORIZATION_ERROR);\n    } else if (status === 404) {\n      return this.createApiError(error, ReadeckErrorCode.NOT_FOUND);\n    } else if (status === 429) {\n      return this.createApiError(error, ReadeckErrorCode.RATE_LIMITED);\n    } else if (status >= 500) {\n      return this.createApiError(error, ReadeckErrorCode.SERVER_ERROR);\n    } else if (status === 503) {\n      return this.createApiError(error, ReadeckErrorCode.SERVICE_UNAVAILABLE);\n    } else {\n      return this.createApiError(error, ReadeckErrorCode.UNKNOWN_ERROR);\n    }\n  }\n\n  /**\n   * Create standardized API error with security considerations\n   * @private\n   */\n  private createApiError(error: any, code: ReadeckErrorCode): ReadeckApiError {\n    const message = this.getErrorMessage(error, code);\n    const statusCode = error.response?.status;\n    // Sanitize error details to prevent information leakage\n    const details = this.sanitizeErrorDetails(error.message || String(error));\n    const retryable =\n      this.retryConfig.retryableErrorCodes.includes(code) ||\n      (statusCode &&\n        this.retryConfig.retryableStatusCodes.includes(statusCode));\n\n    return {\n      code,\n      message,\n      statusCode,\n      details,\n      retryable,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Sanitize error details to prevent sensitive information leakage\n   * @private\n   */\n  private sanitizeErrorDetails(details: string): string {\n    // Remove potential sensitive information patterns\n    return details\n      .replace(/Bearer\\s+[\\w\\-\\.]+/gi, 'Bearer [REDACTED]')\n      .replace(/[\\w\\-]+@[\\w\\-]+(\\.[\\w\\-]+)+/g, '[EMAIL]')\n      .replace(/\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b/g, '[IP]')\n      .replace(/password[\\s=:]+[\\S]+/gi, 'password=[REDACTED]')\n      .replace(/api[_\\-]?key[\\s=:]+[\\S]+/gi, 'api_key=[REDACTED]');\n  }\n\n  /**\n   * Get user-friendly error message\n   * @private\n   */\n  private getErrorMessage(error: any, code: ReadeckErrorCode): string {\n    switch (code) {\n      case ReadeckErrorCode.NETWORK_ERROR:\n        return 'Network connection failed. Please check your internet connection.';\n      case ReadeckErrorCode.AUTHENTICATION_ERROR:\n        return 'Authentication failed. Please check your credentials.';\n      case ReadeckErrorCode.AUTHORIZATION_ERROR:\n        return 'Access denied. You may not have permission for this action.';\n      case ReadeckErrorCode.TIMEOUT_ERROR:\n        return 'Request timeout. The server took too long to respond.';\n      case ReadeckErrorCode.RATE_LIMITED:\n        return 'Too many requests. Please wait before trying again.';\n      case ReadeckErrorCode.SERVER_ERROR:\n        return 'Server error occurred. Please try again later.';\n      case ReadeckErrorCode.SERVICE_UNAVAILABLE:\n        return 'Service temporarily unavailable. Please try again later.';\n      case ReadeckErrorCode.CONNECTION_ERROR:\n        return 'Unable to connect to server. Please check your internet connection.';\n      default:\n        return (\n          error.response?.data?.message ||\n          error.message ||\n          'An unexpected error occurred.'\n        );\n    }\n  }\n\n  /**\n   * Execute request with retry logic\n   * @private\n   */\n  private async executeWithRetry<T>(\n    requestFn: () => Promise<AxiosResponse<T>>,\n    config?: RequestConfig\n  ): Promise<ReadeckApiResponse<T>> {\n    const attempts = config?.retryAttempts ?? this.retryConfig.attempts;\n    const skipRetry = config?.skipRetry ?? false;\n\n    let lastError: ReadeckApiError;\n\n    for (let attempt = 1; attempt <= attempts; attempt++) {\n      try {\n        const response = await requestFn();\n\n        return {\n          data: response.data,\n          status: response.status,\n          headers: response.headers as Record<string, string>,\n          timestamp: new Date().toISOString(),\n        };\n      } catch (error) {\n        lastError = error as ReadeckApiError;\n\n        // Don't retry if configured to skip, on last attempt, or if error is not retryable\n        if (skipRetry || attempt === attempts || !lastError.retryable) {\n          break;\n        }\n\n        const delay = Math.min(\n          this.retryConfig.delay *\n            Math.pow(this.retryConfig.backoffMultiplier, attempt - 1),\n          this.retryConfig.maxDelay\n        );\n\n        logger.info(\n          `API retry attempt ${attempt}/${attempts} after ${delay}ms`,\n          { error: maskSensitiveData(lastError.message) }\n        );\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n\n    throw lastError!;\n  }\n\n  /**\n   * Make HTTP request with proper error handling\n   * @private\n   */\n  private async makeRequest<T>(\n    options: ApiRequestOptions\n  ): Promise<ReadeckApiResponse<T>> {\n    const requestConfig: AxiosRequestConfig = {\n      method: options.method,\n      url: options.url,\n      data: options.data,\n      params: options.params,\n      headers: {\n        ...this.client.defaults.headers.common,\n        ...options.headers,\n        ...options.config?.headers,\n      },\n      timeout: options.config?.timeout,\n    };\n\n    return this.executeWithRetry(\n      () => this.client.request<T>(requestConfig),\n      options.config\n    );\n  }\n\n  // Authentication methods\n  async login(\n    credentials: ReadeckLoginRequest\n  ): Promise<ReadeckApiResponse<ReadeckLoginResponse>> {\n    // Map to Readeck API auth request format exactly as documented\n    const authRequest = {\n      application: 'Mobdeck Mobile App',\n      username: credentials.username,\n      password: credentials.password\n    };\n    \n    return this.makeRequest<ReadeckLoginResponse>({\n      method: 'POST',\n      url: '/auth',\n      data: authRequest,\n      config: { skipAuth: true },\n    });\n  }\n\n  async validateToken(timeout?: number): Promise<ReadeckApiResponse<ReadeckUser>> {\n    return this.makeRequest<ReadeckUser>({\n      method: 'GET',\n      url: '/profile',\n      config: {\n        timeout: timeout || this.config.timeout\n      }\n    });\n  }\n\n  // Note: Readeck API doesn't have token refresh endpoint\n  async refreshToken(): Promise<ReadeckApiResponse<ReadeckLoginResponse>> {\n    throw new Error('Token refresh not supported by Readeck API. Please re-authenticate.');\n  }\n\n  // Article methods\n  async getArticles(\n    filters?: ArticleFilters\n  ): Promise<ReadeckApiResponse<ReadeckArticleList>> {\n    return this.makeRequest<ReadeckArticleList>({\n      method: 'GET',\n      url: '/bookmarks',\n      params: filters,\n    });\n  }\n\n  async getArticle(id: string): Promise<ReadeckApiResponse<ReadeckArticle>> {\n    try {\n      console.log(`[ReadeckApiService] Fetching article with ID: ${id}`);\n      \n      // Get the article metadata from the bookmarks endpoint\n      const response = await this.makeRequest<ReadeckArticle>({\n        method: 'GET',\n        url: `/bookmarks/${id}`,\n      });\n      \n      console.log(`[ReadeckApiService] Article fetch successful: ${id}`);\n      console.log(`[ReadeckApiService] Response data structure:`, {\n        hasData: !!response.data,\n        dataKeys: response.data ? Object.keys(response.data) : [],\n        status: response.status,\n        timestamp: response.timestamp\n      });\n      \n      return response;\n    } catch (error) {\n      // Let the error handler manage logging\n      throw error;\n    }\n  }\n\n  async createArticle(\n    article: CreateArticleRequest\n  ): Promise<ReadeckApiResponse<ReadeckArticle>> {\n    return this.makeRequest<ReadeckArticle>({\n      method: 'POST',\n      url: '/bookmarks',\n      data: article,\n    });\n  }\n\n  async updateArticle(\n    id: string,\n    updates: UpdateArticleRequest\n  ): Promise<ReadeckApiResponse<ReadeckArticle>> {\n    return this.makeRequest<ReadeckArticle>({\n      method: 'PATCH',\n      url: `/bookmarks/${id}`,\n      data: updates,\n    });\n  }\n\n  async deleteArticle(id: string): Promise<ReadeckApiResponse<void>> {\n    return this.makeRequest<void>({\n      method: 'DELETE',\n      url: `/bookmarks/${id}`,\n    });\n  }\n\n  async getArticleContent(contentUrl: string): Promise<string> {\n    try {\n      console.log('[ReadeckApiService] Fetching article content from URL:', contentUrl);\n      console.log('[ReadeckApiService] Current base URL:', this.config.baseUrl);\n      \n      // Handle both absolute URLs and relative paths\n      let requestUrl = contentUrl;\n      \n      // If it's a full URL, we need to extract the path relative to our base URL\n      if (contentUrl.startsWith('http://') || contentUrl.startsWith('https://')) {\n        // Remove the base URL portion to get just the path\n        const baseUrlWithoutTrailingSlash = this.config.baseUrl.replace(/\\/$/, '');\n        \n        if (contentUrl.startsWith(baseUrlWithoutTrailingSlash)) {\n          // Extract the path after the base URL\n          requestUrl = contentUrl.substring(baseUrlWithoutTrailingSlash.length);\n          // Ensure it starts with /\n          if (!requestUrl.startsWith('/')) {\n            requestUrl = `/${  requestUrl}`;\n          }\n        } else {\n          // If URL doesn't match our base URL, try extracting path after /api/\n          const url = new URL(contentUrl);\n          const apiIndex = url.pathname.indexOf('/api/');\n          if (apiIndex !== -1) {\n            requestUrl = url.pathname.substring(apiIndex + 4); // Skip '/api'\n          } else {\n            requestUrl = url.pathname;\n          }\n        }\n      }\n      \n      console.log('[ReadeckApiService] Making request to path:', requestUrl);\n      \n      // Use the makeRequest method to ensure proper authentication and error handling\n      const response = await this.makeRequest<string>({\n        method: 'GET',\n        url: requestUrl,\n        config: {\n          headers: {\n            'Accept': 'text/html',\n          },\n        },\n      });\n      \n      console.log('[ReadeckApiService] Content response received, length:', response.data?.length || 0);\n      \n      return response.data;\n    } catch (error) {\n      // Let the error handler manage logging\n      throw error;\n    }\n  }\n\n  // User methods\n  async getUserProfile(): Promise<ReadeckApiResponse<ReadeckUserProfile>> {\n    return this.makeRequest<ReadeckUserProfile>({\n      method: 'GET',\n      url: '/profile',\n    });\n  }\n\n  async updateUserProfile(\n    updates: Partial<ReadeckUserProfile>\n  ): Promise<ReadeckApiResponse<ReadeckUserProfile>> {\n    // Note: Readeck API documentation doesn't show profile update endpoint\n    // This might not be supported, but keeping for backward compatibility\n    return this.makeRequest<ReadeckUserProfile>({\n      method: 'PATCH',\n      url: '/profile',\n      data: updates,\n    });\n  }\n\n  // System methods - Readeck API doesn't provide system info endpoint\n  async getSystemInfo(): Promise<ReadeckApiResponse<ReadeckSystemInfo>> {\n    throw new Error('System info endpoint not available in Readeck API');\n  }\n\n  // Sync methods - Readeck API doesn't have dedicated sync endpoints\n  // Use getArticles with updated_since parameter for syncing\n  async syncArticles(\n    request?: SyncRequest\n  ): Promise<ReadeckApiResponse<ReadeckSyncResponse>> {\n    console.log('[ReadeckApiService] Simulating sync using getArticles with filters');\n    \n    // Map sync request to article filters\n    const filters: any = {};\n    if (request?.since) {\n      filters.updated_since = request.since;\n    }\n    if (request?.limit) {\n      filters.limit = request.limit;\n    }\n    \n    try {\n      const response = await this.getArticles(filters);\n      \n      // Transform response to match expected sync response format\n      const syncResponse: ReadeckSyncResponse = {\n        articles: Array.isArray(response.data) ? response.data : response.data.articles || [],\n        last_updated: new Date().toISOString(),\n        total_count: Array.isArray(response.data) ? response.data.length : response.data.pagination?.total_count || 0,\n        has_more: Array.isArray(response.data) ? false : (response.data.pagination?.page || 1) < (response.data.pagination?.total_pages || 1)\n      };\n      \n      return {\n        data: syncResponse,\n        status: response.status,\n        headers: response.headers,\n        timestamp: response.timestamp\n      };\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  // Labels methods - Updated to match Readeck API documentation\n  async getLabels(filters?: any): Promise<ReadeckApiResponse<any>> {\n    return this.makeRequest<any>({\n      method: 'GET',\n      url: '/bookmarks/labels',\n      params: filters,\n    });\n  }\n\n  async getLabelInfo(name: string): Promise<ReadeckApiResponse<any>> {\n    return this.makeRequest<any>({\n      method: 'GET',\n      url: `/bookmarks/labels/${encodeURIComponent(name)}`,\n    });\n  }\n\n  async updateLabel(\n    currentName: string,\n    newName: string\n  ): Promise<ReadeckApiResponse<any>> {\n    return this.makeRequest<any>({\n      method: 'PATCH',\n      url: `/bookmarks/labels/${encodeURIComponent(currentName)}`,\n      data: { name: newName },\n    });\n  }\n\n  async deleteLabel(name: string): Promise<ReadeckApiResponse<void>> {\n    return this.makeRequest<void>({\n      method: 'DELETE',\n      url: `/bookmarks/labels/${encodeURIComponent(name)}`,\n    });\n  }\n\n  // Legacy method aliases for backward compatibility\n  async getLabel(name: string): Promise<ReadeckApiResponse<any>> {\n    return this.getLabelInfo(name);\n  }\n\n  async createLabel(_label: any): Promise<ReadeckApiResponse<any>> {\n    // Note: Readeck API doesn't have a direct create label endpoint\n    // Labels are created when assigned to bookmarks\n    throw new Error('Creating labels directly is not supported by Readeck API. Labels are created when assigned to bookmarks.');\n  }\n\n  async assignLabel(_data: any): Promise<ReadeckApiResponse<void>> {\n    // Note: Label assignment is done through bookmark update\n    throw new Error('Use updateArticle with labels/add_labels fields instead of assignLabel');\n  }\n\n  async removeLabel(_data: any): Promise<ReadeckApiResponse<void>> {\n    // Note: Label removal is done through bookmark update\n    throw new Error('Use updateArticle with remove_labels field instead of removeLabel');\n  }\n\n  async batchLabels(_data: any): Promise<ReadeckApiResponse<any>> {\n    // Note: Batch operations should be done through individual bookmark updates\n    throw new Error('Batch label operations not supported. Use individual bookmark updates.');\n  }\n\n  async getLabelStats(): Promise<ReadeckApiResponse<any>> {\n    // Note: Label stats are available through the labels list endpoint\n    throw new Error('Use getLabels() to get label information including counts');\n  }\n\n  async getArticleLabels(_articleId: string): Promise<ReadeckApiResponse<any>> {\n    // Note: Article labels are included in the bookmark details\n    throw new Error('Article labels are included in bookmark details from getArticle()');\n  }\n\n  // Configuration methods\n  updateConfig(config: Partial<ReadeckApiConfig>): void {\n    // Validate new base URL if provided\n    if (config.baseUrl) {\n      const urlValidation = validateUrl(config.baseUrl);\n      if (!urlValidation.isValid) {\n        throw new Error(`Invalid API base URL: ${urlValidation.error}`);\n      }\n      config.baseUrl = urlValidation.sanitized!;\n    }\n\n    this.config = { ...this.config, ...config };\n\n    // Update axios instance configuration\n    this.client.defaults.baseURL = this.config.baseUrl;\n    this.client.defaults.timeout = this.config.timeout;\n\n    // Update retry configuration\n    this.retryConfig.attempts = this.config.retryAttempts;\n    this.retryConfig.delay = this.config.retryDelay;\n\n    logger.info('API configuration updated', {\n      baseUrl: maskSensitiveData(this.config.baseUrl),\n      timeout: this.config.timeout,\n    });\n  }\n\n  getNetworkState(): NetworkState {\n    return { ...this.networkState };\n  }\n\n  /**\n   * Update network connectivity state\n   * Called by network monitoring service\n   */\n  updateNetworkState(state: Partial<NetworkState>): void {\n    this.networkState = { ...this.networkState, ...state };\n    logger.debug('Network state updated', this.networkState);\n  }\n\n  /**\n   * Check if device is online\n   */\n  isOnline(): boolean {\n    return this.networkState.isConnected;\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): ReadeckApiConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Set certificate pins for enhanced security\n   * @param hostname - The hostname to pin certificates for\n   * @param pins - Array of SHA256 certificate fingerprints\n   */\n  setCertificatePins(hostname: string, pins: string[]): void {\n    if (!hostname || !pins || pins.length === 0) {\n      throw new Error('Invalid certificate pinning configuration');\n    }\n    this.certificatePins.set(hostname, pins);\n    logger.info('Certificate pins configured', { hostname, pinCount: pins.length });\n  }\n\n  /**\n   * Clear all certificate pins\n   */\n  clearCertificatePins(): void {\n    this.certificatePins.clear();\n    logger.info('Certificate pins cleared');\n  }\n\n  /**\n   * Verify certificate pins (to be called by network security config)\n   * @param hostname - The hostname to verify\n   * @param certificateChain - The certificate chain to verify\n   */\n  verifyCertificatePins(hostname: string, certificateChain: string[]): boolean {\n    const pins = this.certificatePins.get(hostname);\n    if (!pins || pins.length === 0) {\n      return true; // No pins configured, allow connection\n    }\n\n    // Check if any certificate in the chain matches our pins\n    return certificateChain.some(cert => pins.includes(cert));\n  }\n}\n\n// Export singleton instance for consistent usage across the app\nexport const readeckApiService = new ReadeckApiService();\n\n// Export class for testing and custom instantiation\nexport default ReadeckApiService;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/services/ShareHandlerService.ts","messages":[{"ruleId":"no-duplicate-imports","severity":2,"message":"'../types' import is duplicated.","line":14,"column":1,"nodeType":"ImportDeclaration","messageId":"import","endLine":14,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AppError' is defined but never used.","line":14,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ErrorCode' is defined but never used.","line":14,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":38},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[834,837],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[834,837],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":124,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":124,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3191,3286],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":128,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":128,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[3310,3439],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":133,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":133,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[3476,3581],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":145,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":145,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3731,3791],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":156,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":156,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4058,4219],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":192,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":192,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5079,5180],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":203,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":203,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[5323,5434],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":277,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":277,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7460,7569],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":301,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":301,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8274,8412],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":314,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":314,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[8561,8671],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":341,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":341,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9246,9249],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9246,9249],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":349,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":349,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9384,9542],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":356,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":356,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9625,9734],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":364,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":364,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9829,9832],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9829,9832],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":367,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":367,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[9872,9994],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":384,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":384,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10389,10485],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":406,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":406,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[10895,10960],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":413,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":413,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[11109,11182],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":432,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":432,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11571,11628],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":434,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":434,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[11657,11731],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":461,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":461,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12452,12455],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12452,12455],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":483,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":483,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13004,13007],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13004,13007],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":521,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":521,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13913,13916],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13913,13916],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":541,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":541,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14285,14288],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14285,14288],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":561,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":561,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[14736,14795],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":586,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":586,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[15243,15310],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":618,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":618,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[16148,16251],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":28,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Share Handler Service\n * Processes shared URLs from Android share intents and adds them to Readeck\n */\n\nimport { articlesApiService, CreateArticleParams } from './ArticlesApiService';\nimport {\n  validateUrl,\n  extractUrlFromText,\n  isLikelyArticleUrl,\n  UrlValidationOptions,\n} from '../utils/urlValidation';\nimport { SharedData, ShareModuleInterface } from '../types';\nimport { Article, AppError, ErrorCode } from '../types';\nimport { NativeModules } from 'react-native';\n\nexport interface ShareProcessingResult {\n  success: boolean;\n  article?: Article;\n  error?: ShareHandlerError;\n  validationResult?: {\n    originalText: string;\n    extractedUrl?: string;\n    validationErrors: string[];\n    validationWarnings: string[];\n  };\n}\n\nexport interface ShareHandlerError {\n  code: ShareErrorCode;\n  message: string;\n  details?: any;\n  retryable: boolean;\n  timestamp: string;\n}\n\nexport enum ShareErrorCode {\n  NO_SHARED_DATA = 'NO_SHARED_DATA',\n  NO_URL_FOUND = 'NO_URL_FOUND',\n  INVALID_URL = 'INVALID_URL',\n  URL_VALIDATION_FAILED = 'URL_VALIDATION_FAILED',\n  NETWORK_ERROR = 'NETWORK_ERROR',\n  API_ERROR = 'API_ERROR',\n  DUPLICATE_ARTICLE = 'DUPLICATE_ARTICLE',\n  QUOTA_EXCEEDED = 'QUOTA_EXCEEDED',\n  SHARE_MODULE_ERROR = 'SHARE_MODULE_ERROR',\n  PROCESSING_ERROR = 'PROCESSING_ERROR',\n  UNKNOWN_ERROR = 'UNKNOWN_ERROR',\n}\n\nexport interface ShareHandlerConfig {\n  urlValidation: UrlValidationOptions;\n  autoProcessing: {\n    enabled: boolean;\n    requireHttps: boolean;\n    skipNonArticleUrls: boolean;\n  };\n  networking: {\n    timeout: number;\n    retryAttempts: number;\n    retryDelay: number;\n  };\n  processing: {\n    maxUrlLength: number;\n    extractUrlFromText: boolean;\n    validateArticleUrl: boolean;\n  };\n}\n\nconst DEFAULT_CONFIG: ShareHandlerConfig = {\n  urlValidation: {\n    allowedProtocols: ['http', 'https'],\n    requireHttps: false,\n    maxUrlLength: 2048,\n    validateDomain: true,\n    blockedDomains: [],\n    allowedDomains: [],\n  },\n  autoProcessing: {\n    enabled: true,\n    requireHttps: false,\n    skipNonArticleUrls: false,\n  },\n  networking: {\n    timeout: 30000,\n    retryAttempts: 3,\n    retryDelay: 1000,\n  },\n  processing: {\n    maxUrlLength: 2048,\n    extractUrlFromText: true,\n    validateArticleUrl: true,\n  },\n};\n\n/**\n * ShareHandlerService - Processes shared URLs and adds them to Readeck\n *\n * Features:\n * - URL extraction from shared text\n * - Comprehensive URL validation and security checks\n * - Integration with ArticlesApiService\n * - Error handling with detailed error reporting\n * - Retry logic for network failures\n * - Configuration options for different use cases\n */\nclass ShareHandlerService {\n  private config: ShareHandlerConfig;\n  private shareModule: ShareModuleInterface | null = null;\n\n  constructor(config: Partial<ShareHandlerConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.initializeShareModule();\n  }\n\n  /**\n   * Initialize the native share module\n   */\n  private initializeShareModule(): void {\n    try {\n      const { ShareModule } = NativeModules;\n      if (ShareModule && typeof ShareModule.getSharedData === 'function') {\n        this.shareModule = ShareModule as ShareModuleInterface;\n        console.log(\n          '[ShareHandlerService] Share module initialized successfully'\n        );\n      } else {\n        console.warn(\n          '[ShareHandlerService] Share module not available - running in simulator or module not linked'\n        );\n      }\n    } catch (error) {\n      console.error(\n        '[ShareHandlerService] Failed to initialize share module:',\n        error\n      );\n    }\n  }\n\n  /**\n   * Process shared data and add URL to Readeck\n   */\n  async processSharedData(): Promise<ShareProcessingResult> {\n    try {\n      console.log('[ShareHandlerService] Processing shared data');\n\n      // Get shared data from native module\n      const sharedData = await this.getSharedData();\n      if (!sharedData) {\n        return this.createErrorResult(\n          ShareErrorCode.NO_SHARED_DATA,\n          'No shared data available'\n        );\n      }\n\n      console.log('[ShareHandlerService] Received shared data:', {\n        textLength: sharedData.text?.length || 0,\n        timestamp: sharedData.timestamp,\n      });\n\n      // Extract and validate URL\n      const urlExtractionResult = await this.extractAndValidateUrl(\n        sharedData.text\n      );\n      if (!urlExtractionResult.success) {\n        return {\n          success: false,\n          error: urlExtractionResult.error,\n          validationResult: urlExtractionResult.validationResult,\n        };\n      }\n\n      const { url, validationResult } = urlExtractionResult;\n\n      // Create article in Readeck\n      const articleResult = await this.createArticleWithRetry({\n        url,\n        title: this.extractTitleFromSharedData(sharedData),\n      });\n\n      if (!articleResult.success) {\n        return {\n          success: false,\n          error: articleResult.error,\n          validationResult,\n        };\n      }\n\n      // Clear shared data after successful processing\n      await this.clearSharedData();\n\n      console.log(\n        '[ShareHandlerService] Successfully processed shared URL:',\n        url\n      );\n\n      return {\n        success: true,\n        article: articleResult.article,\n        validationResult,\n      };\n    } catch (error) {\n      console.error(\n        '[ShareHandlerService] Unexpected error processing shared data:',\n        error\n      );\n      return this.createErrorResult(\n        ShareErrorCode.PROCESSING_ERROR,\n        'Unexpected error occurred while processing shared data',\n        error\n      );\n    }\n  }\n\n  /**\n   * Extract and validate URL from shared text\n   */\n  private async extractAndValidateUrl(text: string): Promise<{\n    success: boolean;\n    url?: string;\n    error?: ShareHandlerError;\n    validationResult?: {\n      originalText: string;\n      extractedUrl?: string;\n      validationErrors: string[];\n      validationWarnings: string[];\n    };\n  }> {\n    const validationResult = {\n      originalText: text,\n      extractedUrl: undefined as string | undefined,\n      validationErrors: [] as string[],\n      validationWarnings: [] as string[],\n    };\n\n    try {\n      // Extract URL from text if needed\n      let url = text;\n      if (this.config.processing.extractUrlFromText) {\n        const extractedUrl = extractUrlFromText(text);\n        if (extractedUrl) {\n          url = extractedUrl;\n          validationResult.extractedUrl = extractedUrl;\n        } else if (!text.match(/^https?:\\/\\//i)) {\n          validationResult.validationErrors.push(\n            'No valid URL found in shared text'\n          );\n          return {\n            success: false,\n            error: this.createError(\n              ShareErrorCode.NO_URL_FOUND,\n              'No valid URL found in shared text'\n            ),\n            validationResult,\n          };\n        }\n      }\n\n      if (!url || !url.trim()) {\n        validationResult.validationErrors.push('Empty URL provided');\n        return {\n          success: false,\n          error: this.createError(\n            ShareErrorCode.INVALID_URL,\n            'Empty URL provided'\n          ),\n          validationResult,\n        };\n      }\n\n      // Validate URL\n      const validation = validateUrl(url, this.config.urlValidation);\n      validationResult.validationErrors = validation.errors;\n      validationResult.validationWarnings = validation.warnings;\n\n      if (!validation.isValid) {\n        console.log(\n          '[ShareHandlerService] URL validation failed:',\n          validation.errors\n        );\n        return {\n          success: false,\n          error: this.createError(\n            ShareErrorCode.URL_VALIDATION_FAILED,\n            `URL validation failed: ${validation.errors.join(', ')}`,\n            { validationErrors: validation.errors, url }\n          ),\n          validationResult,\n        };\n      }\n\n      const normalizedUrl = validation.normalizedUrl || url;\n\n      // Check if URL looks like an article (if enabled)\n      if (\n        this.config.processing.validateArticleUrl &&\n        this.config.autoProcessing.skipNonArticleUrls\n      ) {\n        if (!isLikelyArticleUrl(normalizedUrl)) {\n          validationResult.validationWarnings.push('URL may not be an article');\n          console.log(\n            '[ShareHandlerService] URL may not be an article, but processing anyway:',\n            normalizedUrl\n          );\n        }\n      }\n\n      return {\n        success: true,\n        url: normalizedUrl,\n        validationResult,\n      };\n    } catch (error) {\n      console.error(\n        '[ShareHandlerService] Error during URL extraction/validation:',\n        error\n      );\n      validationResult.validationErrors.push(\n        'Unexpected error during URL processing'\n      );\n      return {\n        success: false,\n        error: this.createError(\n          ShareErrorCode.PROCESSING_ERROR,\n          'Unexpected error during URL processing',\n          error\n        ),\n        validationResult,\n      };\n    }\n  }\n\n  /**\n   * Create article with retry logic\n   */\n  private async createArticleWithRetry(params: CreateArticleParams): Promise<{\n    success: boolean;\n    article?: Article;\n    error?: ShareHandlerError;\n  }> {\n    let lastError: any;\n\n    for (\n      let attempt = 1;\n      attempt <= this.config.networking.retryAttempts;\n      attempt++\n    ) {\n      try {\n        console.log(\n          `[ShareHandlerService] Creating article (attempt ${attempt}/${this.config.networking.retryAttempts}):`,\n          params.url\n        );\n\n        const article = await articlesApiService.createArticle(params);\n\n        console.log(\n          '[ShareHandlerService] Article created successfully:',\n          article.id\n        );\n        return {\n          success: true,\n          article,\n        };\n      } catch (error: any) {\n        lastError = error;\n\n        console.error(\n          `[ShareHandlerService] Article creation failed (attempt ${attempt}):`,\n          error\n        );\n\n        // Check if error is retryable\n        if (\n          !this.isRetryableError(error) ||\n          attempt === this.config.networking.retryAttempts\n        ) {\n          break;\n        }\n\n        // Wait before retry\n        if (attempt < this.config.networking.retryAttempts) {\n          const delay =\n            this.config.networking.retryDelay * Math.pow(2, attempt - 1);\n          console.log(\n            `[ShareHandlerService] Waiting ${delay}ms before retry...`\n          );\n          await this.delay(delay);\n        }\n      }\n    }\n\n    // Convert API error to ShareHandlerError\n    const shareError = this.convertApiErrorToShareError(lastError);\n    return {\n      success: false,\n      error: shareError,\n    };\n  }\n\n  /**\n   * Get shared data from native module\n   */\n  private async getSharedData(): Promise<SharedData | null> {\n    try {\n      if (!this.shareModule) {\n        console.warn('[ShareHandlerService] Share module not available');\n        return null;\n      }\n\n      const sharedData = await this.shareModule.getSharedData();\n      return sharedData;\n    } catch (error) {\n      console.error('[ShareHandlerService] Error getting shared data:', error);\n      throw this.createError(\n        ShareErrorCode.SHARE_MODULE_ERROR,\n        'Failed to get shared data from native module',\n        error\n      );\n    }\n  }\n\n  /**\n   * Clear shared data from native module\n   */\n  private async clearSharedData(): Promise<void> {\n    try {\n      if (!this.shareModule) {\n        return;\n      }\n\n      await this.shareModule.clearSharedData();\n      console.log('[ShareHandlerService] Shared data cleared');\n    } catch (error) {\n      console.error('[ShareHandlerService] Error clearing shared data:', error);\n      // Don't throw here as it's not critical to the main flow\n    }\n  }\n\n  /**\n   * Extract title from shared data\n   */\n  private extractTitleFromSharedData(sharedData: SharedData): string {\n    // Use subject if available, otherwise try to extract from URL\n    if (sharedData.subject && sharedData.subject.trim()) {\n      return sharedData.subject.trim();\n    }\n\n    // Extract domain name as fallback title\n    try {\n      const url = extractUrlFromText(sharedData.text) || sharedData.text;\n      const parsedUrl = new URL(url);\n      return `Article from ${parsedUrl.hostname}`;\n    } catch {\n      return 'Shared Article';\n    }\n  }\n\n  /**\n   * Check if error is retryable\n   */\n  private isRetryableError(error: any): boolean {\n    // Network errors are typically retryable\n    if (error.code === 'NETWORK_ERROR' || error.code === 'TIMEOUT_ERROR') {\n      return true;\n    }\n\n    // Server errors (5xx) are retryable\n    if (error.statusCode && error.statusCode >= 500) {\n      return true;\n    }\n\n    // Rate limiting is retryable with backoff\n    if (error.statusCode === 429 || error.code === 'RATE_LIMITED') {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Convert API error to ShareHandlerError\n   */\n  private convertApiErrorToShareError(error: any): ShareHandlerError {\n    if (error.message && error.message.includes('duplicate')) {\n      return this.createError(\n        ShareErrorCode.DUPLICATE_ARTICLE,\n        'Article already exists in Readeck',\n        error\n      );\n    }\n\n    if (error.statusCode === 429 || error.message?.includes('quota')) {\n      return this.createError(\n        ShareErrorCode.QUOTA_EXCEEDED,\n        'API quota exceeded',\n        error\n      );\n    }\n\n    if (error.code === 'NETWORK_ERROR' || error.message?.includes('network')) {\n      return this.createError(\n        ShareErrorCode.NETWORK_ERROR,\n        'Network error occurred',\n        error\n      );\n    }\n\n    return this.createError(\n      ShareErrorCode.API_ERROR,\n      error.message || 'API error occurred',\n      error\n    );\n  }\n\n  /**\n   * Create ShareHandlerError\n   */\n  private createError(\n    code: ShareErrorCode,\n    message: string,\n    details?: any\n  ): ShareHandlerError {\n    return {\n      code,\n      message,\n      details,\n      retryable: this.isRetryableError({\n        code,\n        statusCode: details?.statusCode,\n      }),\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Create error result\n   */\n  private createErrorResult(\n    code: ShareErrorCode,\n    message: string,\n    details?: any\n  ): ShareProcessingResult {\n    return {\n      success: false,\n      error: this.createError(code, message, details),\n    };\n  }\n\n  /**\n   * Delay utility for retry logic\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Update service configuration\n   */\n  updateConfig(config: Partial<ShareHandlerConfig>): void {\n    this.config = { ...this.config, ...config };\n    console.log('[ShareHandlerService] Configuration updated');\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): ShareHandlerConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Check if share module is available\n   */\n  isShareModuleAvailable(): boolean {\n    return this.shareModule !== null;\n  }\n\n  /**\n   * Process URL directly (useful for testing or manual URL processing)\n   */\n  async processUrl(\n    url: string,\n    title?: string\n  ): Promise<ShareProcessingResult> {\n    try {\n      console.log('[ShareHandlerService] Processing URL directly:', url);\n\n      const urlExtractionResult = await this.extractAndValidateUrl(url);\n      if (!urlExtractionResult.success) {\n        return {\n          success: false,\n          error: urlExtractionResult.error,\n          validationResult: urlExtractionResult.validationResult,\n        };\n      }\n\n      const { url: validatedUrl, validationResult } = urlExtractionResult;\n\n      const articleResult = await this.createArticleWithRetry({\n        url: validatedUrl,\n        title: title || this.extractTitleFromUrl(validatedUrl),\n      });\n\n      if (!articleResult.success) {\n        return {\n          success: false,\n          error: articleResult.error,\n          validationResult,\n        };\n      }\n\n      return {\n        success: true,\n        article: articleResult.article,\n        validationResult,\n      };\n    } catch (error) {\n      console.error(\n        '[ShareHandlerService] Unexpected error processing URL:',\n        error\n      );\n      return this.createErrorResult(\n        ShareErrorCode.PROCESSING_ERROR,\n        'Unexpected error occurred while processing URL',\n        error\n      );\n    }\n  }\n\n  /**\n   * Extract title from URL as fallback\n   */\n  private extractTitleFromUrl(url: string): string {\n    try {\n      const parsedUrl = new URL(url);\n      return `Article from ${parsedUrl.hostname}`;\n    } catch {\n      return 'Shared Article';\n    }\n  }\n}\n\n// Export singleton instance for consistent usage across the app\nexport const shareHandlerService = new ShareHandlerService();\n\n// Export class for testing and custom instantiation\nexport default ShareHandlerService;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/services/ShareService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DBSyncMetadata' is defined but never used.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":24},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":15,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":15,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[461,698],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":22,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":22,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[885,979],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":26,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":26,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1016,1091],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":29,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":29,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1166,1234],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":32,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":32,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1268,1326],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":40,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":40,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1473,1527],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":43,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":43,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[1575,1640],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":61,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":61,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[2127,2179],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":74,"column":52,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":74,"endColumn":53,"suggestions":[{"messageId":"removeEscape","fix":{"range":[2547,2548],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[2547,2547],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'entity_type' is not in camel case.","line":139,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":139,"endColumn":20},{"ruleId":"camelcase","severity":2,"message":"Identifier 'entity_id' is not in camel case.","line":140,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":140,"endColumn":18},{"ruleId":"camelcase","severity":2,"message":"Identifier 'local_timestamp' is not in camel case.","line":142,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":142,"endColumn":24},{"ruleId":"camelcase","severity":2,"message":"Identifier 'server_timestamp' is not in camel case.","line":143,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":143,"endColumn":25},{"ruleId":"camelcase","severity":2,"message":"Identifier 'sync_status' is not in camel case.","line":144,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":144,"endColumn":20},{"ruleId":"camelcase","severity":2,"message":"Identifier 'conflict_resolution' is not in camel case.","line":145,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":145,"endColumn":28},{"ruleId":"camelcase","severity":2,"message":"Identifier 'retry_count' is not in camel case.","line":146,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":146,"endColumn":20},{"ruleId":"camelcase","severity":2,"message":"Identifier 'error_message' is not in camel case.","line":147,"column":9,"nodeType":"Identifier","messageId":"notCamelCase","endLine":147,"endColumn":22},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":151,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":151,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4691,4771],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":157,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":157,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[4858,4922],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":190,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":190,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[5838,5903],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":203,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":203,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[6226,6299],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":228,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":228,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[7072,7137],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NativeModules } from 'react-native';\nimport { SharedData } from '../types';\nimport DatabaseService from './DatabaseService';\nimport { DBSyncMetadata } from '../types/database';\n\nconst { MobdeckShareModule } = NativeModules;\n\nexport class ShareService {\n  /**\n   * Gets shared data from Android intent if available\n   * @returns Promise resolving to shared data or null\n   */\n  static async getSharedData(): Promise<SharedData | null> {\n    try {\n      console.log('ShareService: Checking for MobdeckShareModule...', {\n        hasMobdeckShareModule: !!MobdeckShareModule,\n        hasGetSharedDataMethod: MobdeckShareModule && typeof MobdeckShareModule.getSharedData === 'function'\n      });\n\n      if (!MobdeckShareModule || typeof MobdeckShareModule.getSharedData !== 'function') {\n        // MobdeckShareModule is only available when app is launched via share intent\n        console.log('ShareService: MobdeckShareModule not available or missing getSharedData method');\n        return null;\n      }\n\n      console.log('ShareService: Calling MobdeckShareModule.getSharedData()...');\n      const data = await MobdeckShareModule.getSharedData();\n      \n      console.log('ShareService: Raw response from native module:', data);\n      \n      if (data) {\n        console.log('ShareService: Retrieved shared data:', data);\n        return {\n          text: data.text,\n          subject: data.subject,\n          timestamp: data.timestamp,\n        };\n      }\n      \n      console.log('ShareService: No shared data available');\n      return null;\n    } catch (error) {\n      console.error('ShareService: Error getting shared data:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Clears any pending shared data\n   * @returns Promise resolving to success status\n   */\n  static async clearSharedData(): Promise<boolean> {\n    try {\n      if (!MobdeckShareModule || typeof MobdeckShareModule.clearSharedData !== 'function') {\n        // MobdeckShareModule is only available when app is launched via share intent\n        return false;\n      }\n\n      return await MobdeckShareModule.clearSharedData();\n    } catch (error) {\n      console.error('Error clearing shared data:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Extracts URL from shared text content\n   * @param text The shared text content\n   * @returns Extracted URL or null if no valid URL found\n   */\n  static extractUrl(text: string): string | null {\n    // Enhanced URL regex that handles various URL formats\n    const urlRegex =\n      /https?:\\/\\/(?:[-\\w.])+(?:[:\\d]+)?(?:\\/(?:[\\w\\/_.])*(?:\\?(?:[\\w&=%.])*)?(?:#(?:[\\w.])*)?)?/gi;\n    const matches = text.match(urlRegex);\n\n    if (matches && matches.length > 0) {\n      return matches[0]; // Return the first found URL\n    }\n\n    return null;\n  }\n\n  /**\n   * Validates if the shared content contains a valid URL\n   * @param sharedData The shared data object\n   * @returns True if contains valid URL, false otherwise\n   */\n  static isValidUrlShare(sharedData: SharedData): boolean {\n    if (!sharedData.text) {\n      return false;\n    }\n\n    const url = this.extractUrl(sharedData.text);\n    return url !== null;\n  }\n\n  /**\n   * Formats shared data for article creation\n   * @param sharedData The shared data object\n   * @returns Formatted data for article creation\n   */\n  static formatForArticle(\n    sharedData: SharedData\n  ): { url: string; title?: string } | null {\n    const url = this.extractUrl(sharedData.text);\n\n    if (!url) {\n      return null;\n    }\n\n    return {\n      url,\n      title: sharedData.subject || 'Shared Article',\n    };\n  }\n\n  /**\n   * Queues shared URL for offline processing\n   * @param sharedData The shared data object\n   * @returns Promise resolving to queue ID or null if failed\n   */\n  static async queueSharedUrl(sharedData: SharedData): Promise<string | null> {\n    try {\n      const articleData = this.formatForArticle(sharedData);\n      if (!articleData) {\n        return null;\n      }\n\n      const db = DatabaseService;\n      \n      // Ensure database is initialized before attempting to queue\n      await db.initialize();\n      \n      const queueId = `shared_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      // Store in sync_metadata table for offline processing\n      const result = await db.createSyncMetadata({\n        entity_type: 'shared_url',\n        entity_id: queueId,\n        operation: 'create',\n        local_timestamp: Date.now(),\n        server_timestamp: null,\n        sync_status: 'pending',\n        conflict_resolution: null,\n        retry_count: 0,\n        error_message: JSON.stringify(articleData), // Store article data in error_message field\n      });\n\n      if (result.success) {\n        console.log('ShareService: Shared URL queued for offline processing:', queueId);\n        return queueId;\n      }\n      \n      return null;\n    } catch (error) {\n      console.error('ShareService: Error queuing shared URL:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Gets pending shared URLs from offline queue\n   * @returns Promise resolving to array of pending shared URLs\n   */\n  static async getPendingSharedUrls(): Promise<Array<{\n    id: string;\n    url: string;\n    title: string;\n    timestamp: number;\n  }>> {\n    try {\n      const db = DatabaseService;\n      const result = await db.getSyncMetadata({\n        entityType: 'shared_url',\n        syncStatus: 'pending',\n      });\n\n      if (result.success && result.data && result.data.items) {\n        return result.data.items.map(item => {\n          try {\n            const articleData = JSON.parse(item.error_message || '{}');\n            return {\n              id: item.entity_id,\n              url: articleData.url || '',\n              title: articleData.title || 'Shared Article',\n              timestamp: item.local_timestamp,\n            };\n          } catch (e) {\n            console.error('ShareService: Error parsing queued URL data:', e);\n            return {\n              id: item.entity_id,\n              url: '',\n              title: 'Invalid Share Data',\n              timestamp: item.local_timestamp,\n            };\n          }\n        }).filter(item => item.url); // Filter out invalid entries\n      }\n      \n      return [];\n    } catch (error) {\n      console.error('ShareService: Error getting pending shared URLs:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Removes processed shared URL from queue\n   * @param queueId The queue ID to remove\n   * @returns Promise resolving to success status\n   */\n  static async removeFromQueue(queueId: string): Promise<boolean> {\n    try {\n      const db = DatabaseService;\n      // Get the item by entity_id using a direct SQL query\n      const sql = 'SELECT * FROM sync_metadata WHERE entity_type = ? AND entity_id = ?';\n      const queryResult = await db.executeSql(sql, ['shared_url', queueId]);\n\n      if (queryResult.rows.length > 0) {\n        const item = queryResult.rows.item(0);\n        const deleteResult = await db.deleteSyncMetadata(item.id);\n        return deleteResult.success;\n      }\n      \n      return false;\n    } catch (error) {\n      console.error('ShareService: Error removing from queue:', error);\n      return false;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/services/SyncService.ts","messages":[{"ruleId":"no-duplicate-imports","severity":2,"message":"'./DatabaseService' import is duplicated.","line":38,"column":1,"nodeType":"ImportDeclaration","messageId":"import","endLine":38,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'RetryManager' is defined but never used.","line":41,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":41,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1520,1523],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1520,1523],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1540,1543],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1540,1543],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":120,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":120,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3259,3317],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":132,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":132,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3651,3718],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":134,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":134,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[3747,3807],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":144,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":144,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4013,4076],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":163,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":163,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4493,4547],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":165,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":165,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4630,4700],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":167,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":167,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4767,4829],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":178,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":178,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5132,5183],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":218,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":218,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6061,6127],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":357,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":357,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9813,9880],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":386,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":386,"endColumn":60,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[10644,10645],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":387,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":387,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10659,10763],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":421,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":421,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11732,11860],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":426,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":426,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[11910,11964],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":442,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":442,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[12314,12383],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":461,"column":35,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":461,"endColumn":55,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[12896,12897],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":462,"column":22,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":462,"endColumn":42,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[12949,12950],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":465,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":465,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[13002,13093],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":472,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":472,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[13243,13343],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":519,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":519,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[14669,14799],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":547,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":547,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15468,15471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15468,15471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'updateResult' is assigned a value but never used.","line":573,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":573,"endColumn":29},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_modified' is not in camel case.","line":586,"column":13,"nodeType":"Identifier","messageId":"notCamelCase","endLine":586,"endColumn":24},{"ruleId":"camelcase","severity":2,"message":"Identifier 'synced_at' is not in camel case.","line":587,"column":13,"nodeType":"Identifier","messageId":"notCamelCase","endLine":587,"endColumn":22},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":596,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":596,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[16967,17041],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":607,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":607,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[17431,17515],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":635,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":635,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[19147,19253],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_modified' is not in camel case.","line":639,"column":17,"nodeType":"Identifier","messageId":"notCamelCase","endLine":639,"endColumn":28},{"ruleId":"camelcase","severity":2,"message":"Identifier 'synced_at' is not in camel case.","line":640,"column":17,"nodeType":"Identifier","messageId":"notCamelCase","endLine":640,"endColumn":26},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":650,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":650,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[19737,19847],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":675,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":675,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[20337,20414],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":698,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":698,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[21510,21639],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":702,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":702,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[21683,21768],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":705,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":705,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[21816,21908],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'synced_at' is not in camel case.","line":740,"column":19,"nodeType":"Identifier","messageId":"notCamelCase","endLine":740,"endColumn":28},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_modified' is not in camel case.","line":741,"column":19,"nodeType":"Identifier","messageId":"notCamelCase","endLine":741,"endColumn":30},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":754,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":754,"endColumn":33},{"ruleId":"camelcase","severity":2,"message":"Identifier 'synced_at' is not in camel case.","line":769,"column":25,"nodeType":"Identifier","messageId":"notCamelCase","endLine":769,"endColumn":34},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_modified' is not in camel case.","line":770,"column":25,"nodeType":"Identifier","messageId":"notCamelCase","endLine":770,"endColumn":36},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":824,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":824,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[25471,25562],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":854,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":854,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[26458,26588],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'synced_at' is not in camel case.","line":878,"column":17,"nodeType":"Identifier","messageId":"notCamelCase","endLine":878,"endColumn":26},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_modified' is not in camel case.","line":879,"column":17,"nodeType":"Identifier","messageId":"notCamelCase","endLine":879,"endColumn":28},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":896,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":896,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[27670,27791],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":904,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":904,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[27870,27991],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'remoteArticle' is defined but never used. Allowed unused args must match /^_/u.","line":917,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":917,"endColumn":18},{"ruleId":"camelcase","severity":2,"message":"Identifier 'synced_at' is not in camel case.","line":924,"column":11,"nodeType":"Identifier","messageId":"notCamelCase","endLine":924,"endColumn":20},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_modified' is not in camel case.","line":925,"column":11,"nodeType":"Identifier","messageId":"notCamelCase","endLine":925,"endColumn":22},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":938,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":938,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[28778,28894],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":946,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":946,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[28973,29094],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"camelcase","severity":2,"message":"Identifier 'synced_at' is not in camel case.","line":965,"column":17,"nodeType":"Identifier","messageId":"notCamelCase","endLine":965,"endColumn":26},{"ruleId":"camelcase","severity":2,"message":"Identifier 'is_modified' is not in camel case.","line":966,"column":17,"nodeType":"Identifier","messageId":"notCamelCase","endLine":966,"endColumn":28},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":982,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":982,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[29935,30052],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":990,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":990,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[30131,30252],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1005,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1005,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[30471,30543],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1025,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1025,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[31051,31181],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":1037,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":1052,"endColumn":6},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1082,"column":36,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1082,"endColumn":55,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[32554,32555],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1083,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1083,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[32584,32699],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1084,"column":34,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1084,"endColumn":53,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[32648,32649],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1094,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1094,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[32989,33094],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1134,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1134,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[33959,34022],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1138,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1138,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[34060,34142],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1142,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1142,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[34219,34299],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1151,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1151,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[34567,34657],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1158,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1158,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[34878,34955],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1160,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1160,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[34987,35089],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1163,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1163,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[35138,35221],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1170,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1170,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[35409,35485],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1180,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1180,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[35692,35779],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1182,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1182,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[35808,35883],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1193,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1193,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[36107,36177],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1201,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1201,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36346,36349],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36346,36349],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1216,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1216,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[36842,36888],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1227,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1227,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[37128,37188],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-dupe-class-members","severity":2,"message":"Duplicate name 'isRunning'.","line":1233,"column":3,"nodeType":"MethodDefinition","messageId":"unexpected","endLine":1235,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1240,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1240,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37375,37378],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37375,37378],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":20,"fatalErrorCount":0,"warningCount":61,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SyncService - Comprehensive Bidirectional Synchronization Service\n *\n * Features:\n * - Two-way sync between local SQLite and Readeck server\n * - Last-Write-Wins conflict resolution strategy\n * - Network-aware sync with retry logic\n * - Batch processing for efficient data transfer\n * - Comprehensive error handling and recovery\n * - Integration with Redux sync slice for state management\n * - Progress tracking and status reporting\n */\n\nimport DatabaseService from './DatabaseService';\nimport { readeckApiService } from './ReadeckApiService';\nimport { articlesApiService } from './ArticlesApiService';\nimport { ShareService } from './ShareService';\nimport { store } from '../store';\nimport { errorHandler, ErrorCategory } from '../utils/errorHandler';\nimport {\n  startSync,\n  syncProgress,\n  syncSuccess,\n  syncError,\n  addConflict,\n  resolveConflict,\n  updateSyncStats,\n  updateNetworkStatus,\n} from '../store/slices/syncSlice';\nimport {\n  SyncConfiguration,\n  SyncPhase,\n  ConflictType,\n  ConflictResolutionStrategy,\n  NetworkType,\n} from '../types/sync';\nimport { Article } from '../types';\nimport { DatabaseUtilityFunctions } from './DatabaseService';\nimport { resolveConflict as resolveArticleConflict } from '../utils/conflictResolution';\nimport { connectivityManager, ConnectivityStatus } from '../utils/connectivityManager';\nimport { RetryManager } from '../utils/retryManager';\n\ninterface SyncOperation {\n  id: string;\n  type: 'create' | 'update' | 'delete';\n  entity: 'article' | 'label';\n  localData?: any;\n  remoteData?: any;\n  timestamp: number;\n  status: 'pending' | 'processing' | 'completed' | 'failed';\n  error?: string;\n  retryCount: number;\n}\n\ninterface SyncBatch {\n  operations: SyncOperation[];\n  batchId: string;\n  startTime: number;\n  endTime?: number;\n  totalOperations: number;\n  completedOperations: number;\n  failedOperations: number;\n}\n\ninterface SyncResult {\n  success: boolean;\n  syncedCount: number;\n  conflictCount: number;\n  errorCount: number;\n  duration: number;\n  phase: SyncPhase;\n  errors: Array<{\n    operation: string;\n    error: string;\n    retryable: boolean;\n  }>;\n}\n\n/**\n * SyncService - Manages bidirectional synchronization between local and remote data\n */\nclass SyncService {\n  private static instance: SyncService;\n  private isRunning = false;\n  private currentBatch: SyncBatch | null = null;\n  private syncQueue: SyncOperation[] = [];\n  private retryQueue: SyncOperation[] = [];\n  private config: SyncConfiguration;\n  private abortController: AbortController | null = null;\n\n  private constructor() {\n    // Initialize with default configuration\n    this.config = {\n      backgroundSyncEnabled: true,\n      syncInterval: 15,\n      syncOnWifiOnly: false,\n      syncOnCellular: true,\n      downloadImages: true,\n      fullTextSync: true,\n      conflictResolutionStrategy: ConflictResolutionStrategy.LAST_WRITE_WINS,\n      batchSize: 50,\n    };\n  }\n\n  /**\n   * Get singleton instance of SyncService\n   */\n  public static getInstance(): SyncService {\n    if (!SyncService.instance) {\n      SyncService.instance = new SyncService();\n    }\n    return SyncService.instance;\n  }\n\n  /**\n   * Initialize sync service and set up background tasks\n   */\n  public async initialize(): Promise<void> {\n    try {\n      console.log('[SyncService] Initializing sync service...');\n\n      // Get current sync configuration from Redux store\n      const state = store.getState();\n      this.config = { ...this.config, ...state.sync.config };\n\n      // Set up network monitoring\n      this.setupNetworkMonitoring();\n\n      // Process any pending sync operations\n      await this.processPendingSyncOperations();\n\n      console.log('[SyncService] Sync service initialized successfully');\n    } catch (error) {\n      console.error('[SyncService] Failed to initialize:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update sync configuration\n   */\n  public updateConfiguration(newConfig: Partial<SyncConfiguration>): void {\n    this.config = { ...this.config, ...newConfig };\n    console.log('[SyncService] Configuration updated:', newConfig);\n  }\n\n  /**\n   * Get current sync configuration\n   */\n  public getConfiguration(): SyncConfiguration {\n    return { ...this.config };\n  }\n\n  /**\n   * Start full bidirectional synchronization\n   */\n  public async startFullSync(forceSync = false): Promise<SyncResult> {\n    if (this.isRunning && !forceSync) {\n      throw new Error('Sync already in progress');\n    }\n\n    // Check connectivity before starting sync\n    console.log('[SyncService] Checking connectivity...');\n    const connectivityStatus = await connectivityManager.checkConnectivity();\n    console.log('[SyncService] Connectivity status:', connectivityStatus);\n    if (connectivityStatus !== ConnectivityStatus.ONLINE) {\n      console.log('[SyncService] Cannot sync - server unreachable');\n      store.dispatch(\n        syncError({\n          error: 'Server is unreachable. Please check your connection.',\n          phase: SyncPhase.CHECKING_CONNECTION,\n          isRetryable: true,\n        })\n      );\n      throw new Error('Server is unreachable. Please check your connection.');\n    }\n\n    console.log('[SyncService] Starting full sync...');\n\n    this.isRunning = true;\n    this.abortController = new AbortController();\n\n    const startTime = Date.now();\n\n    // Dispatch sync start action\n    store.dispatch(\n      startSync({\n        fullSync: true,\n        forceSync,\n        syncOptions: this.config,\n      })\n    );\n\n    try {\n      const result = await this.executeFullSync();\n\n      const duration = Date.now() - startTime;\n\n      // Dispatch sync success\n      store.dispatch(\n        syncSuccess({\n          syncDuration: duration,\n          itemsProcessed: result.syncedCount,\n          conflictsDetected: result.conflictCount,\n          syncTime: new Date().toISOString(),\n        })\n      );\n\n      // Update sync statistics\n      store.dispatch(\n        updateSyncStats({\n          articlesCreated: result.syncedCount,\n          articlesUpdated: 0,\n          articlesDeleted: 0,\n        })\n      );\n\n      console.log(`[SyncService] Full sync completed in ${duration}ms`);\n\n      return {\n        ...result,\n        duration,\n        success: true,\n      };\n    } catch (error) {\n      const duration = Date.now() - startTime;\n\n      // Use centralized error handling\n      const handledError = errorHandler.handleError(error, {\n        category: ErrorCategory.SYNC_OPERATION,\n        context: { \n          actionType: 'full_sync',\n          syncPhase: SyncPhase.FINALIZING,\n        },\n      });\n\n      // Dispatch sync error\n      store.dispatch(\n        syncError({\n          error: handledError.message,\n          errorCode: 'SYNC_FAILED',\n          phase: SyncPhase.FINALIZING,\n          retryable: this.isRetryableError(error),\n        })\n      );\n\n      return {\n        success: false,\n        syncedCount: 0,\n        conflictCount: 0,\n        errorCount: 1,\n        duration,\n        phase: SyncPhase.FINALIZING,\n        errors: [\n          {\n            operation: 'full_sync',\n            error: error.message,\n            retryable: this.isRetryableError(error),\n          },\n        ],\n      };\n    } finally {\n      this.isRunning = false;\n      this.abortController = null;\n    }\n  }\n\n  /**\n   * Execute the complete synchronization process\n   */\n  private async executeFullSync(): Promise<SyncResult> {\n    const syncResult: SyncResult = {\n      success: true,\n      syncedCount: 0,\n      conflictCount: 0,\n      errorCount: 0,\n      duration: 0,\n      phase: SyncPhase.INITIALIZING,\n      errors: [],\n    };\n\n    try {\n      // Phase 1: Upload local changes\n      store.dispatch(\n        syncProgress({\n          phase: SyncPhase.UPLOADING_CHANGES,\n          totalItems: 0,\n          processedItems: 0,\n          currentItem: 'Detecting local changes...',\n        })\n      );\n\n      const uploadResult = await this.syncUp();\n      syncResult.syncedCount += uploadResult.syncedCount;\n      syncResult.conflictCount += uploadResult.conflictCount;\n      syncResult.errorCount += uploadResult.errorCount;\n      syncResult.errors.push(...uploadResult.errors);\n\n      // Phase 2: Download remote changes\n      store.dispatch(\n        syncProgress({\n          phase: SyncPhase.DOWNLOADING_UPDATES,\n          totalItems: 0,\n          processedItems: 0,\n          currentItem: 'Fetching remote updates...',\n        })\n      );\n\n      const downloadResult = await this.syncDown();\n      syncResult.syncedCount += downloadResult.syncedCount;\n      syncResult.conflictCount += downloadResult.conflictCount;\n      syncResult.errorCount += downloadResult.errorCount;\n      syncResult.errors.push(...downloadResult.errors);\n\n      // Phase 3: Resolve any pending conflicts\n      if (syncResult.conflictCount > 0) {\n        store.dispatch(\n          syncProgress({\n            phase: SyncPhase.RESOLVING_CONFLICTS,\n            totalItems: syncResult.conflictCount,\n            processedItems: 0,\n            currentItem: 'Resolving conflicts...',\n          })\n        );\n\n        await this.resolveAllConflicts();\n      }\n\n      // Phase 4: Finalize sync\n      store.dispatch(\n        syncProgress({\n          phase: SyncPhase.FINALIZING,\n          totalItems: syncResult.syncedCount,\n          processedItems: syncResult.syncedCount,\n          currentItem: 'Finalizing sync...',\n        })\n      );\n\n      syncResult.phase = SyncPhase.FINALIZING;\n      return syncResult;\n    } catch (error) {\n      syncResult.success = false;\n      syncResult.errorCount++;\n      syncResult.errors.push({\n        operation: 'execute_full_sync',\n        error: error.message,\n        retryable: this.isRetryableError(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Sync Up: Upload local changes to server\n   */\n  public async syncUp(): Promise<SyncResult> {\n    console.log('[SyncService] Starting sync up (local -> remote)...');\n\n    const result: SyncResult = {\n      success: true,\n      syncedCount: 0,\n      conflictCount: 0,\n      errorCount: 0,\n      duration: 0,\n      phase: SyncPhase.UPLOADING_CHANGES,\n      errors: [],\n    };\n\n    try {\n      // Ensure database is initialized before sync operations\n      await this.ensureDatabaseInitialized();\n\n      // Get all locally modified articles\n      const modifiedArticlesResult = await DatabaseService.getArticles({\n        isModified: true,\n        sortBy: 'updated_at',\n        sortOrder: 'ASC',\n      });\n\n      if (!modifiedArticlesResult.success) {\n        throw new Error(\n          `Failed to get modified articles: ${modifiedArticlesResult.error}`\n        );\n      }\n\n      const modifiedArticles = modifiedArticlesResult.data!.items;\n      console.log(\n        `[SyncService] Found ${modifiedArticles.length} locally modified articles`\n      );\n\n      // Process articles in batches\n      const batches = this.createBatches(\n        modifiedArticles,\n        this.config.batchSize\n      );\n\n      for (let i = 0; i < batches.length; i++) {\n        const batch = batches[i];\n\n        store.dispatch(\n          syncProgress({\n            phase: SyncPhase.UPLOADING_CHANGES,\n            totalItems: modifiedArticles.length,\n            processedItems: i * this.config.batchSize,\n            currentItem: `Processing batch ${i + 1}/${batches.length}`,\n          })\n        );\n\n        const batchResult = await this.uploadBatch(batch);\n        result.syncedCount += batchResult.syncedCount;\n        result.conflictCount += batchResult.conflictCount;\n        result.errorCount += batchResult.errorCount;\n        result.errors.push(...batchResult.errors);\n\n        // Check for abort signal\n        if (this.abortController?.signal.aborted) {\n          throw new Error('Sync aborted by user');\n        }\n      }\n\n      console.log(\n        `[SyncService] Sync up completed: ${result.syncedCount} synced, ${result.conflictCount} conflicts`\n      );\n      return result;\n    } catch (error) {\n      console.error('[SyncService] Sync up failed:', error);\n      result.success = false;\n      result.errorCount++;\n      result.errors.push({\n        operation: 'sync_up',\n        error: error.message,\n        retryable: this.isRetryableError(error),\n      });\n      return result;\n    }\n  }\n\n  /**\n   * Sync Down: Download remote changes to local\n   */\n  public async syncDown(): Promise<SyncResult> {\n    console.log('[SyncService] Starting sync down (remote -> local)...');\n\n    const result: SyncResult = {\n      success: true,\n      syncedCount: 0,\n      conflictCount: 0,\n      errorCount: 0,\n      duration: 0,\n      phase: SyncPhase.DOWNLOADING_UPDATES,\n      errors: [],\n    };\n\n    try {\n      // Ensure database is initialized before sync operations\n      await this.ensureDatabaseInitialized();\n\n      // Get last sync timestamp\n      const lastSyncResult = await DatabaseService.getStats();\n      const lastSyncTimestamp =\n        lastSyncResult.success && lastSyncResult.data!.lastSyncAt\n          ? new Date(lastSyncResult.data!.lastSyncAt * 1000)\n          : new Date(0);\n\n      console.log(\n        `[SyncService] Last sync: ${lastSyncTimestamp.toISOString()}`\n      );\n\n      // Fetch articles modified since last sync\n      const remoteArticles =\n        await this.fetchRemoteArticlesSince(lastSyncTimestamp);\n      console.log(\n        `[SyncService] Found ${remoteArticles.length} remote articles to sync`\n      );\n\n      // Process remote articles\n      for (let i = 0; i < remoteArticles.length; i++) {\n        const remoteArticle = remoteArticles[i];\n\n        store.dispatch(\n          syncProgress({\n            phase: SyncPhase.DOWNLOADING_UPDATES,\n            totalItems: remoteArticles.length,\n            processedItems: i,\n            currentItem: `Syncing: ${remoteArticle.title}`,\n          })\n        );\n\n        try {\n          const syncResult = await this.syncRemoteArticle(remoteArticle);\n\n          if (syncResult.success) {\n            result.syncedCount++;\n          } else if (syncResult.conflict) {\n            result.conflictCount++;\n          } else {\n            result.errorCount++;\n            result.errors.push({\n              operation: `sync_article_${remoteArticle.id}`,\n              error: syncResult.error || 'Unknown error',\n              retryable: true,\n            });\n          }\n        } catch (error) {\n          result.errorCount++;\n          result.errors.push({\n            operation: `sync_article_${remoteArticle.id}`,\n            error: error.message,\n            retryable: this.isRetryableError(error),\n          });\n        }\n\n        // Check for abort signal\n        if (this.abortController?.signal.aborted) {\n          throw new Error('Sync aborted by user');\n        }\n      }\n\n      console.log(\n        `[SyncService] Sync down completed: ${result.syncedCount} synced, ${result.conflictCount} conflicts`\n      );\n      return result;\n    } catch (error) {\n      // Use centralized error handling\n      const handledError = errorHandler.handleError(error, {\n        category: ErrorCategory.SYNC_OPERATION,\n        context: { \n          actionType: 'sync_down',\n          syncPhase: SyncPhase.FETCHING_REMOTE_DATA,\n        },\n      });\n      \n      result.success = false;\n      result.errorCount++;\n      result.errors.push({\n        operation: 'sync_down',\n        error: handledError.message,\n        retryable: this.isRetryableError(error),\n      });\n      return result;\n    }\n  }\n\n  /**\n   * Upload a batch of articles to the server\n   */\n  private async uploadBatch(articles: any[]): Promise<SyncResult> {\n    const result: SyncResult = {\n      success: true,\n      syncedCount: 0,\n      conflictCount: 0,\n      errorCount: 0,\n      duration: 0,\n      phase: SyncPhase.UPLOADING_CHANGES,\n      errors: [],\n    };\n\n    // Ensure database is initialized\n    await this.ensureDatabaseInitialized();\n\n    for (const dbArticle of articles) {\n      try {\n        const article =\n          DatabaseUtilityFunctions.convertDBArticleToArticle(dbArticle);\n\n        // Check if article exists on server\n        const existsOnServer = await this.checkArticleExistsOnServer(\n          article.id\n        );\n\n        if (existsOnServer) {\n          // Update existing article\n          const updateResult = await articlesApiService.updateArticle({\n            id: article.id,\n            updates: {\n              title: article.title,\n              isArchived: article.isArchived,\n              isFavorite: article.isFavorite,\n              isRead: article.isRead,\n              tags: article.tags || [],\n            },\n          });\n\n          // Mark as synced in local database\n          await DatabaseService.updateArticle(article.id, {\n            is_modified: 0,\n            synced_at: Math.floor(Date.now() / 1000),\n          });\n\n          result.syncedCount++;\n        } else {\n          // Check if this is a locally created article (has local ID)\n          const isLocallyCreated = article.id.startsWith('local_');\n          \n          // Create new article on server\n          console.log(`[SyncService] Creating article on server: ${article.title}`);\n          const createResult = await articlesApiService.createArticle({\n            title: article.title,\n            url: article.url,\n            summary: article.summary,\n            content: article.content,\n            tags: article.tags || [],\n          });\n\n          if (createResult.success && createResult.data) {\n            const serverArticle = createResult.data;\n            console.log(`[SyncService] Article created on server with ID: ${serverArticle.id}`);\n            \n            if (isLocallyCreated) {\n              // For locally created articles, we need to replace the local record with the server record\n              const oldLocalId = article.id;\n              \n              // Delete the old local record\n              await DatabaseService.deleteArticle(oldLocalId);\n              \n              // Create new record with server ID\n              await DatabaseService.createArticle({\n                id: serverArticle.id,\n                title: serverArticle.title || article.title,\n                url: serverArticle.url || article.url,\n                summary: serverArticle.summary || article.summary,\n                content: serverArticle.content || article.content,\n                imageUrl: serverArticle.image_url || article.imageUrl || '',\n                readTime: serverArticle.read_time || article.readTime,\n                sourceUrl: serverArticle.source_url || article.sourceUrl || article.url,\n                isArchived: serverArticle.is_archived || article.isArchived,\n                isFavorite: serverArticle.is_favorite || article.isFavorite,\n                isRead: serverArticle.is_read || article.isRead,\n                isModified: false, // Mark as synced\n                createdAt: serverArticle.created_at ? Math.floor(new Date(serverArticle.created_at).getTime() / 1000) : article.createdAt,\n                updatedAt: serverArticle.updated_at ? Math.floor(new Date(serverArticle.updated_at).getTime() / 1000) : Math.floor(Date.now() / 1000),\n                syncedAt: Math.floor(Date.now() / 1000),\n              });\n              \n              console.log(`[SyncService] Replaced local article ${oldLocalId} with server article ${serverArticle.id}`);\n            } else {\n              // For articles with server IDs, just mark as synced\n              await DatabaseService.updateArticle(article.id, {\n                is_modified: 0,\n                synced_at: Math.floor(Date.now() / 1000),\n              });\n            }\n            \n            result.syncedCount++;\n          } else {\n            throw new Error(createResult.error || 'Failed to create article on server');\n          }\n        }\n      } catch (error) {\n        console.error(\n          `[SyncService] Failed to upload article ${dbArticle.id}:`,\n          error\n        );\n        result.errorCount++;\n        result.errors.push({\n          operation: `upload_article_${dbArticle.id}`,\n          error: error.message,\n          retryable: this.isRetryableError(error),\n        });\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Fetch full article content if fullTextSync is enabled\n   */\n  private async fetchFullArticleContent(articleId: string): Promise<Article | null> {\n    try {\n      if (!this.config.fullTextSync) {\n        return null;\n      }\n\n      console.log(`[SyncService] Fetching full content for article: ${articleId}`);\n      const response = await readeckApiService.getArticle(articleId);\n      \n      if (response.success && response.data) {\n        // Convert ReadeckArticle to Article format manually\n        const readeckArticle = response.data;\n        const fullArticle: Article = {\n          id: readeckArticle.id,\n          title: readeckArticle.title || '',\n          summary: readeckArticle.summary || '',\n          content: readeckArticle.content || '',\n          url: readeckArticle.url || '',\n          imageUrl: readeckArticle.image_url || '',\n          readTime: readeckArticle.read_time || 0,\n          isArchived: readeckArticle.is_archived || false,\n          isFavorite: readeckArticle.is_favorite || false,\n          isRead: readeckArticle.is_read || false,\n          tags: readeckArticle.tags || [],\n          sourceUrl: readeckArticle.source_url || readeckArticle.url || '',\n          createdAt: readeckArticle.created_at || new Date().toISOString(),\n          updatedAt: readeckArticle.updated_at || new Date().toISOString(),\n          syncedAt: new Date().toISOString(),\n        };\n        console.log(`[SyncService] Full content fetched for article: ${articleId}, content length: ${fullArticle.content?.length || 0}`);\n        return fullArticle;\n      }\n\n      console.warn(`[SyncService] Failed to fetch full content for article: ${articleId}`);\n      return null;\n    } catch (error) {\n      console.error(`[SyncService] Error fetching full content for article: ${articleId}`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Sync a remote article to local database\n   */\n  private async syncRemoteArticle(remoteArticle: Article): Promise<{\n    success: boolean;\n    conflict: boolean;\n    error?: string;\n  }> {\n    try {\n      // Ensure database is initialized\n      await this.ensureDatabaseInitialized();\n\n      // Fetch full content if fullTextSync is enabled and content is missing\n      let articleToSync = remoteArticle;\n      if (this.config.fullTextSync && (!remoteArticle.content || remoteArticle.content.trim() === '')) {\n        const fullArticle = await this.fetchFullArticleContent(remoteArticle.id);\n        if (fullArticle) {\n          articleToSync = fullArticle;\n        }\n      }\n\n      // Check if article exists locally\n      const localArticleResult = await DatabaseService.getArticle(\n        articleToSync.id\n      );\n\n      if (!localArticleResult.success) {\n        // Article doesn't exist locally, create it\n        const dbArticle =\n          DatabaseUtilityFunctions.convertArticleToDBArticle(articleToSync);\n        dbArticle.synced_at = Math.floor(Date.now() / 1000);\n        dbArticle.is_modified = 0;\n\n        const createResult = await DatabaseService.createArticle(dbArticle);\n\n        return {\n          success: createResult.success,\n          conflict: false,\n          error: createResult.error,\n        };\n      }\n\n      // Article exists locally, check for conflicts\n      const localArticle = DatabaseUtilityFunctions.convertDBArticleToArticle(\n        localArticleResult.data!\n      );\n\n      if (this.hasConflict(localArticle, articleToSync)) {\n        // Handle conflict based on strategy\n        const resolved = await this.handleConflict(localArticle, articleToSync);\n\n        return {\n          success: resolved,\n          conflict: !resolved,\n        };\n      } else {\n        // No conflict, update local article\n        const remoteDbArticle =\n          DatabaseUtilityFunctions.convertArticleToDBArticle(articleToSync);\n        remoteDbArticle.synced_at = Math.floor(Date.now() / 1000);\n        remoteDbArticle.is_modified = 0;\n\n        const updateResult = await DatabaseService.updateArticle(\n          articleToSync.id,\n          remoteDbArticle\n        );\n\n        return {\n          success: updateResult.success,\n          conflict: false,\n          error: updateResult.error,\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        conflict: false,\n        error: error.message,\n      };\n    }\n  }\n\n  /**\n   * Check if there's a conflict between local and remote articles\n   */\n  private hasConflict(localArticle: Article, remoteArticle: Article): boolean {\n    // Check if both articles have been modified since last sync\n    const localModified = localArticle.isModified || false;\n    const remoteModified =\n      new Date(remoteArticle.updatedAt) >\n      (localArticle.syncedAt || new Date(0));\n\n    if (!localModified || !remoteModified) {\n      return false;\n    }\n\n    // Check for actual differences in content\n    return (\n      localArticle.title !== remoteArticle.title ||\n      localArticle.isArchived !== remoteArticle.isArchived ||\n      localArticle.isFavorite !== remoteArticle.isFavorite ||\n      localArticle.isRead !== remoteArticle.isRead ||\n      JSON.stringify(localArticle.tags || []) !==\n        JSON.stringify(remoteArticle.tags || [])\n    );\n  }\n\n  /**\n   * Handle conflict between local and remote articles\n   */\n  private async handleConflict(\n    localArticle: Article,\n    remoteArticle: Article\n  ): Promise<boolean> {\n    console.log(\n      `[SyncService] Conflict detected for article: ${localArticle.id}`\n    );\n\n    // Add conflict to Redux state\n    store.dispatch(\n      addConflict({\n        articleId: localArticle.id,\n        type: ConflictType.CONTENT_MODIFIED,\n        localVersion: localArticle,\n        remoteVersion: remoteArticle,\n      })\n    );\n\n    // Apply conflict resolution strategy\n    switch (this.config.conflictResolutionStrategy) {\n      case ConflictResolutionStrategy.LAST_WRITE_WINS:\n        return await this.resolveLastWriteWins(localArticle, remoteArticle);\n\n      case ConflictResolutionStrategy.LOCAL_WINS:\n        return await this.resolveLocalWins(localArticle, remoteArticle);\n\n      case ConflictResolutionStrategy.REMOTE_WINS:\n        return await this.resolveRemoteWins(localArticle, remoteArticle);\n\n      case ConflictResolutionStrategy.MANUAL:\n        // For manual resolution, we'll store the conflict and return false\n        return false;\n\n      default:\n        console.warn(\n          `[SyncService] Unknown conflict resolution strategy: ${this.config.conflictResolutionStrategy}`\n        );\n        return false;\n    }\n  }\n\n  /**\n   * Resolve conflict using Last-Write-Wins strategy\n   */\n  private async resolveLastWriteWins(\n    localArticle: Article,\n    remoteArticle: Article\n  ): Promise<boolean> {\n    try {\n      const resolvedArticle = resolveArticleConflict(\n        localArticle,\n        remoteArticle,\n        ConflictResolutionStrategy.LAST_WRITE_WINS\n      );\n\n      // Update local database with resolved article\n      const dbArticle =\n        DatabaseUtilityFunctions.convertArticleToDBArticle(resolvedArticle);\n      dbArticle.synced_at = Math.floor(Date.now() / 1000);\n      dbArticle.is_modified = 0;\n\n      const updateResult = await DatabaseService.updateArticle(\n        resolvedArticle.id,\n        dbArticle\n      );\n\n      if (updateResult.success) {\n        // Mark conflict as resolved\n        store.dispatch(\n          resolveConflict({\n            conflictId: `${localArticle.id}_${Date.now()}`,\n            resolution: ConflictResolutionStrategy.LAST_WRITE_WINS,\n            resolvedVersion: resolvedArticle,\n          })\n        );\n\n        console.log(\n          `[SyncService] Conflict resolved for article: ${localArticle.id} using Last-Write-Wins`\n        );\n        return true;\n      }\n\n      return false;\n    } catch (error) {\n      console.error(\n        `[SyncService] Failed to resolve conflict for article: ${localArticle.id}`,\n        error\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Resolve conflict using Local-Wins strategy\n   */\n  private async resolveLocalWins(\n    localArticle: Article,\n    remoteArticle: Article\n  ): Promise<boolean> {\n    try {\n      // Keep local version, but update sync timestamp\n      const updateResult = await DatabaseService.updateArticle(\n        localArticle.id,\n        {\n          synced_at: Math.floor(Date.now() / 1000),\n          is_modified: 1, // Keep as modified to upload later\n        }\n      );\n\n      if (updateResult.success) {\n        store.dispatch(\n          resolveConflict({\n            conflictId: `${localArticle.id}_${Date.now()}`,\n            resolution: ConflictResolutionStrategy.LOCAL_WINS,\n            resolvedVersion: localArticle,\n          })\n        );\n\n        console.log(\n          `[SyncService] Conflict resolved for article: ${localArticle.id} using Local-Wins`\n        );\n        return true;\n      }\n\n      return false;\n    } catch (error) {\n      console.error(\n        `[SyncService] Failed to resolve conflict for article: ${localArticle.id}`,\n        error\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Resolve conflict using Remote-Wins strategy\n   */\n  private async resolveRemoteWins(\n    localArticle: Article,\n    remoteArticle: Article\n  ): Promise<boolean> {\n    try {\n      // Use remote version\n      const dbArticle =\n        DatabaseUtilityFunctions.convertArticleToDBArticle(remoteArticle);\n      dbArticle.synced_at = Math.floor(Date.now() / 1000);\n      dbArticle.is_modified = 0;\n\n      const updateResult = await DatabaseService.updateArticle(\n        remoteArticle.id,\n        dbArticle\n      );\n\n      if (updateResult.success) {\n        store.dispatch(\n          resolveConflict({\n            conflictId: `${localArticle.id}_${Date.now()}`,\n            resolution: ConflictResolutionStrategy.REMOTE_WINS,\n            resolvedVersion: remoteArticle,\n          })\n        );\n\n        console.log(\n          `[SyncService] Conflict resolved for article: ${localArticle.id} using Remote-Wins`\n        );\n        return true;\n      }\n\n      return false;\n    } catch (error) {\n      console.error(\n        `[SyncService] Failed to resolve conflict for article: ${localArticle.id}`,\n        error\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Resolve all pending conflicts\n   */\n  private async resolveAllConflicts(): Promise<void> {\n    const state = store.getState();\n    const conflicts = state.sync.conflicts;\n\n    console.log(`[SyncService] Resolving ${conflicts.length} conflicts...`);\n\n    for (let i = 0; i < conflicts.length; i++) {\n      const conflict = conflicts[i];\n\n      store.dispatch(\n        syncProgress({\n          phase: SyncPhase.RESOLVING_CONFLICTS,\n          totalItems: conflicts.length,\n          processedItems: i,\n          currentItem: `Resolving conflict for article: ${conflict.articleId}`,\n        })\n      );\n\n      try {\n        await this.handleConflict(\n          conflict.localVersion,\n          conflict.remoteVersion\n        );\n      } catch (error) {\n        console.error(\n          `[SyncService] Failed to resolve conflict for article: ${conflict.articleId}`,\n          error\n        );\n      }\n    }\n  }\n\n  /**\n   * Fetch remote articles modified since a specific timestamp\n   */\n  private async fetchRemoteArticlesSince(since: Date): Promise<Article[]> {\n    try {\n      // Use the existing ArticlesApiService to fetch articles\n      const response = await articlesApiService.fetchArticles({\n        page: 1,\n        limit: 1000, // Fetch a large batch for sync\n        forceRefresh: true,\n      });\n\n      // Filter articles modified since the timestamp\n      return response.items.filter(\n        article => new Date(article.updatedAt) > since\n      );\n    } catch (error) {\n      // Let the error handler manage logging\n      throw error;\n    }\n  }\n\n  /**\n   * Check if an article exists on the server\n   */\n  private async checkArticleExistsOnServer(\n    articleId: string\n  ): Promise<boolean> {\n    try {\n      await articlesApiService.getArticle(articleId);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Process any pending sync operations from previous sessions\n   */\n  private async processPendingSyncOperations(): Promise<void> {\n    try {\n      // Ensure database is initialized\n      await this.ensureDatabaseInitialized();\n\n      const pendingResult = await DatabaseService.getSyncMetadata({\n        syncStatus: 'pending',\n        limit: 100,\n      });\n\n      if (pendingResult.success && pendingResult.data!.items.length > 0) {\n        console.log(\n          `[SyncService] Found ${pendingResult.data!.items.length} pending sync operations`\n        );\n        \n        // Skip processing old shared URL queue - we now save articles directly offline-first\n        // await this.processPendingSharedUrls();\n        \n        // Process other pending operations\n        await this.processPendingOperations();\n      }\n    } catch (error) {\n      console.error(\n        '[SyncService] Failed to process pending sync operations:',\n        error\n      );\n    }\n  }\n\n  /**\n   * Set up network monitoring\n   */\n  private setupNetworkMonitoring(): void {\n    // TODO: Implement network monitoring using NetInfo\n    // For now, assume we're online\n    store.dispatch(\n      updateNetworkStatus({\n        isOnline: true,\n        networkType: NetworkType.WIFI,\n      })\n    );\n  }\n\n  /**\n   * Create batches from an array\n   */\n  private createBatches<T>(items: T[], batchSize: number): T[][] {\n    const batches: T[][] = [];\n    for (let i = 0; i < items.length; i += batchSize) {\n      batches.push(items.slice(i, i + batchSize));\n    }\n    return batches;\n  }\n\n  /**\n   * Process pending shared URLs when coming back online\n   */\n  private async processPendingSharedUrls(): Promise<void> {\n    try {\n      const pendingUrls = await ShareService.getPendingSharedUrls();\n      \n      if (pendingUrls.length === 0) {\n        console.log('[SyncService] No pending shared URLs to process');\n        return;\n      }\n      \n      console.log(`[SyncService] Processing ${pendingUrls.length} pending shared URLs`);\n      \n      for (const sharedUrl of pendingUrls) {\n        try {\n          console.log(`[SyncService] Creating article from shared URL: ${sharedUrl.url}`);\n          \n          // Create article using ArticlesApiService\n          const result = await articlesApiService.createArticle({\n            url: sharedUrl.url,\n            title: sharedUrl.title,\n          });\n          \n          if (result.success) {\n            console.log(`[SyncService] Successfully created article for shared URL: ${sharedUrl.id}`);\n            \n            // Remove from queue\n            await ShareService.removeFromQueue(sharedUrl.id);\n            \n            // Show success notification\n            // TODO: Add notification service\n            console.log(`[SyncService] Article \"${sharedUrl.title}\" added successfully`);\n          } else {\n            console.error(`[SyncService] Failed to create article for shared URL: ${sharedUrl.id}`, result.error);\n          }\n        } catch (error) {\n          console.error(`[SyncService] Error processing shared URL ${sharedUrl.id}:`, error);\n          \n          // For now, we'll keep the URL in the queue for retry\n          // TODO: Implement retry logic with exponential backoff\n        }\n      }\n    } catch (error) {\n      console.error('[SyncService] Error processing pending shared URLs:', error);\n    }\n  }\n\n  /**\n   * Process other pending sync operations\n   */\n  private async processPendingOperations(): Promise<void> {\n    try {\n      // TODO: Implement processing of other pending operations\n      console.log('[SyncService] Processing other pending operations - not implemented yet');\n    } catch (error) {\n      console.error('[SyncService] Error processing pending operations:', error);\n    }\n  }\n\n  /**\n   * Ensure database is initialized before sync operations\n   */\n  private async ensureDatabaseInitialized(): Promise<void> {\n    try {\n      await DatabaseService.initialize();\n    } catch (error) {\n      console.error('[SyncService] Database initialization failed:', error);\n      throw new Error(`Database initialization failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Check if an error is retryable\n   */\n  private isRetryableError(error: any): boolean {\n    // Network errors, timeouts, and server errors are retryable\n    if (error.code === 'NETWORK_ERROR' || error.code === 'TIMEOUT') return true;\n    if (error.status >= 500 && error.status < 600) return true;\n    if (error.message.includes('network') || error.message.includes('timeout'))\n      return true;\n\n    return false;\n  }\n\n  /**\n   * Stop sync if currently running\n   */\n  public async stopSync(): Promise<void> {\n    if (this.isRunning && this.abortController) {\n      console.log('[SyncService] Stopping sync...');\n      this.abortController.abort();\n      this.isRunning = false;\n    }\n  }\n\n  /**\n   * Update sync configuration\n   */\n  public updateConfig(config: Partial<SyncConfiguration>): void {\n    this.config = { ...this.config, ...config };\n    console.log('[SyncService] Configuration updated:', config);\n  }\n\n  /**\n   * Get current sync status\n   */\n  public isRunning(): boolean {\n    return this.isRunning;\n  }\n\n  /**\n   * Get sync statistics\n   */\n  public async getSyncStats(): Promise<any> {\n    const state = store.getState();\n    return state.sync.stats;\n  }\n}\n\n// Export singleton instance\nexport const syncService = SyncService.getInstance();\n\n// Export class for testing\nexport default SyncService;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/services/api.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":8,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":8,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[255,312],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":9,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":9,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[317,431],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":20,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":20,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[743,812],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":21,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":21,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[817,874],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":22,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":22,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[879,929],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":40,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":40,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[1472,1530],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":43,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":43,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[1579,2012],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":88,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":88,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[3528,3577],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":105,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":105,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[4048,4110],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\n\n// Function to validate API token against Readeck server\nexport const validateApiToken = async (serverUrl: string, apiToken: string) => {\n  const cleanUrl = serverUrl.replace(/\\/$/, ''); // Remove trailing slash\n  \n  try {\n    console.log('[API] Attempting to connect to:', cleanUrl);\n    console.log('[API] Using token:', `${apiToken.substring(0, 10)  }...${  apiToken.length > 10 ? '(hidden)' : ''}`);\n    \n    // Use correct Readeck API endpoint for profile validation\n    const response = await axios.get(`${cleanUrl}/api/profile`, {\n      headers: {\n        'Authorization': `Bearer ${apiToken}`,\n        'Content-Type': 'application/json',\n      },\n      timeout: 10000, // 10 second timeout\n    });\n    \n    console.log('[API] Connection successful! Status:', response.status);\n    console.log('[API] Response headers:', response.headers);\n    console.log('[API] Profile data:', response.data);\n    \n    // Extract user info from profile response\n    const profileData = response.data;\n    return {\n      isValid: true,\n      user: {\n        id: profileData.user?.id || 'readeck-user',\n        username: profileData.user?.username || 'Readeck User',\n        email: profileData.user?.email || 'user@readeck.local',\n        serverUrl: cleanUrl,\n        lastLoginAt: new Date().toISOString(),\n        tokenExpiresAt: new Date(\n          Date.now() + 30 * 24 * 60 * 60 * 1000\n        ).toISOString(),\n      },\n    };\n  } catch (error) {\n    console.error('[API] Error validating API token:', error);\n    \n    if (axios.isAxiosError(error)) {\n      console.error('[API] Axios error details:', {\n        code: error.code,\n        message: error.message,\n        response: error.response ? {\n          status: error.response.status,\n          statusText: error.response.statusText,\n          data: error.response.data,\n          headers: error.response.headers,\n        } : 'No response',\n        request: error.request ? 'Request made but no response' : 'Request not made',\n      });\n      \n      if (error.response?.status === 401) {\n        throw new Error('Invalid API token. Please check your credentials.');\n      } else if (error.response?.status === 403) {\n        throw new Error('Access denied. Please check your API token permissions.');\n      } else if (error.code === 'ECONNREFUSED') {\n        throw new Error(`Cannot connect to server at ${cleanUrl}. Is the server running?`);\n      } else if (error.code === 'ENOTFOUND') {\n        throw new Error(`Server not found at ${cleanUrl}. Please check the URL.`);\n      } else if (error.code === 'ECONNABORTED') {\n        throw new Error('Connection timeout. Please check your network connection.');\n      } else if (error.response && error.response.status >= 500) {\n        throw new Error(`Server error (${error.response.status}). Please try again later.`);\n      } else if (error.code === 'ERR_NETWORK') {\n        throw new Error('Network error. Please check your internet connection and server URL.');\n      }\n    }\n    \n    throw new Error('Failed to validate API token. Please check your credentials and server URL.');\n  }\n};\n\n// Function to fetch articles\nexport const fetchArticles = async (serverUrl: string, apiToken: string) => {\n  try {\n    const cleanUrl = serverUrl.replace(/\\/$/, '');\n    const response = await axios.get(`${cleanUrl}/api/bookmarks`, {\n      headers: {\n        'Authorization': `Bearer ${apiToken}`,\n        'Content-Type': 'application/json',\n      },\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error fetching articles:', error);\n    throw error;\n  }\n};\n\n// Function to fetch a single article by ID\nexport const fetchArticleById = async (serverUrl: string, apiToken: string, id: string) => {\n  try {\n    const cleanUrl = serverUrl.replace(/\\/$/, '');\n    const response = await axios.get(`${cleanUrl}/api/bookmarks/${id}`, {\n      headers: {\n        'Authorization': `Bearer ${apiToken}`,\n        'Content-Type': 'application/json',\n      },\n    });\n    return response.data;\n  } catch (error) {\n    console.error(`Error fetching article with ID ${id}:`, error);\n    throw error;\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/services/database.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":17,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":17,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[384,428],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":21,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":21,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[479,528],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":32,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":32,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[821,872],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":35,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":35,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[907,963],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":47,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":47,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1238,1283],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":50,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":50,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[1318,1368],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1436,1439],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1436,1439],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-shadow","severity":2,"message":"'tx' is already declared in the upper scope on line 57 column 18.","line":61,"column":8,"nodeType":"Identifier","messageId":"noShadow","endLine":61,"endColumn":10},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1592,1595],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1592,1595],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":69,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":69,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[1779,1829],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":79,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":79,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1933,1977],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":82,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":82,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[2012,2061],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import SQLite from 'react-native-sqlite-storage';\n\nconst databaseName = 'Readeck.db';\nconst databaseVersion = '1.0';\nconst databaseDisplayName = 'Readeck Database';\nconst databaseSize = 200000;\n\nlet db: SQLite.SQLiteDatabase;\n\nconst initDatabase = () => {\n  db = SQLite.openDatabase(\n    databaseName,\n    databaseVersion,\n    databaseDisplayName,\n    databaseSize,\n    () => {\n      console.log('Database opened successfully');\n      createTables();\n    },\n    error => {\n      console.error('Error opening database: ', error);\n    }\n  );\n};\n\nconst createTables = () => {\n  db.transaction(tx => {\n    tx.executeSql(\n      'CREATE TABLE IF NOT EXISTS articles (id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT, summary TEXT, content TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)',\n      [],\n      () => {\n        console.log('Articles table created successfully');\n      },\n      error => {\n        console.error('Error creating articles table: ', error);\n      }\n    );\n  });\n};\n\nconst insertArticle = (title: string, summary: string, content: string) => {\n  db.transaction(tx => {\n    tx.executeSql(\n      'INSERT INTO articles (title, summary, content) VALUES (?, ?, ?)',\n      [title, summary, content],\n      () => {\n        console.log('Article inserted successfully');\n      },\n      error => {\n        console.error('Error inserting article: ', error);\n      }\n    );\n  });\n};\n\nconst getArticles = (callback: (articles: any[]) => void) => {\n  db.transaction(tx => {\n    tx.executeSql(\n      'SELECT * FROM articles',\n      [],\n      (tx, results) => {\n        const articles: any[] = [];\n        for (let i = 0; i < results.rows.length; i++) {\n          articles.push(results.rows.item(i));\n        }\n        callback(articles);\n      },\n      error => {\n        console.error('Error fetching articles: ', error);\n      }\n    );\n  });\n};\n\nconst closeDatabase = () => {\n  if (db) {\n    db.close(\n      () => {\n        console.log('Database closed successfully');\n      },\n      error => {\n        console.error('Error closing database: ', error);\n      }\n    );\n  }\n};\n\nexport { initDatabase, insertArticle, getArticles, closeDatabase };\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/services/sync.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":13,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":13,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[432,482],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":15,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":15,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[507,561],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":21,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":21,"endColumn":15,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[664,761],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":25,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":25,"endColumn":15,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[798,891],"text":""},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Legacy sync.ts - DEPRECATED\n// This file is deprecated in favor of BackgroundSyncService.ts\n// which provides more comprehensive background sync functionality\n// using react-native-background-actions\n\nimport { fetchArticles } from './api';\nimport { saveArticlesToDatabase } from './database';\n\nconst syncArticles = async () => {\n  try {\n    const articles = await fetchArticles();\n    await saveArticlesToDatabase(articles);\n    console.log('Articles synchronized successfully');\n  } catch (error) {\n    console.error('Error synchronizing articles:', error);\n  }\n};\n\n// Deprecated functions - use BackgroundSyncService instead\nconst scheduleSyncJob = () => {\n  console.warn('scheduleSyncJob is deprecated. Use BackgroundSyncService.scheduleSync() instead.');\n};\n\nconst cancelSyncJob = () => {\n  console.warn('cancelSyncJob is deprecated. Use BackgroundSyncService.cancelSync() instead.');\n};\n\nexport { syncArticles, scheduleSyncJob, cancelSyncJob };\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/store/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/store/middleware.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":11,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":11,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[320,361],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":12,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":12,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[368,408],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":14,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":14,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[457,499],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":18,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":18,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[555,599],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":34,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":34,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[937,977],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":35,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":35,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[984,1017],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":36,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":36,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[1024,1066],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'store' is defined but never used. Allowed unused args must match /^_/u.","line":48,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":8},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":56,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":56,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[1606,1725],"text":""},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Middleware, AnyAction } from '@reduxjs/toolkit';\nimport { RootState } from './index';\n\n/**\n * Development logging middleware\n * Logs actions and state changes in development mode\n */\nexport const loggerMiddleware: Middleware<{}, RootState> =\n  store => next => (action: AnyAction) => {\n    if (__DEV__) {\n      console.log(`🔥 Action: ${action.type}`);\n      console.log('Payload:', action.payload);\n      const prevState = store.getState();\n      console.log('Previous State:', prevState);\n      \n      const result = next(action);\n      \n      console.log('New State:', store.getState());\n      return result;\n    }\n\n    return next(action);\n  };\n\n/**\n * Error handling middleware\n * Catches and logs any errors that occur during action processing\n */\nexport const errorHandlerMiddleware: Middleware<{}, RootState> =\n  store => next => (action: AnyAction) => {\n    try {\n      return next(action);\n    } catch (error) {\n      console.error('🚨 Redux Error:', error);\n      console.error('Action:', action);\n      console.error('State:', store.getState());\n\n      // Re-throw the error so it can be handled elsewhere if needed\n      throw error;\n    }\n  };\n\n/**\n * Performance monitoring middleware\n * Tracks action processing time in development\n */\nexport const performanceMiddleware: Middleware<{}, RootState> =\n  store => next => (action: AnyAction) => {\n    if (__DEV__) {\n      const startTime = performance.now();\n      const result = next(action);\n      const endTime = performance.now();\n\n      // Only warn for truly slow actions (>100ms)\n      if (endTime - startTime > 100) {\n        console.warn(\n          `⚠️ Slow action detected: ${action.type} took ${(endTime - startTime).toFixed(2)}ms`\n        );\n      }\n\n      return result;\n    }\n\n    return next(action);\n  };\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/store/selectors/articlesSelectors.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'selectArticleById' is defined but never used.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":20}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createSelector } from '@reduxjs/toolkit';\nimport { RootState } from '../index';\nimport { Article } from '../../types';\nimport {\n  selectAllArticles,\n  selectArticleById,\n  selectArticleEntities,\n} from '../slices/articlesSlice';\n\n// Base selectors for articles state\nexport const selectArticlesState = (state: RootState) => state.articles;\n\n// Loading state selectors\nexport const selectArticlesLoading = createSelector(\n  [selectArticlesState],\n  articlesState => articlesState.loading\n);\n\nexport const selectIsFetchingArticles = createSelector(\n  [selectArticlesLoading],\n  loading => loading.fetch\n);\n\nexport const selectIsCreatingArticle = createSelector(\n  [selectArticlesLoading],\n  loading => loading.create\n);\n\nexport const selectIsUpdatingArticle = createSelector(\n  [selectArticlesLoading],\n  loading => loading.update\n);\n\nexport const selectIsDeletingArticle = createSelector(\n  [selectArticlesLoading],\n  loading => loading.delete\n);\n\nexport const selectIsSyncingArticles = createSelector(\n  [selectArticlesLoading],\n  loading => loading.sync\n);\n\nexport const selectAnyArticleLoading = createSelector(\n  [selectArticlesLoading],\n  loading => Object.values(loading).some(isLoading => isLoading)\n);\n\n// Error state selectors\nexport const selectArticlesErrors = createSelector(\n  [selectArticlesState],\n  articlesState => articlesState.error\n);\n\nexport const selectArticlesFetchError = createSelector(\n  [selectArticlesErrors],\n  errors => errors.fetch\n);\n\nexport const selectArticlesCreateError = createSelector(\n  [selectArticlesErrors],\n  errors => errors.create\n);\n\nexport const selectArticlesUpdateError = createSelector(\n  [selectArticlesErrors],\n  errors => errors.update\n);\n\nexport const selectArticlesDeleteError = createSelector(\n  [selectArticlesErrors],\n  errors => errors.delete\n);\n\nexport const selectArticlesSyncError = createSelector(\n  [selectArticlesErrors],\n  errors => errors.sync\n);\n\nexport const selectAnyArticleError = createSelector(\n  [selectArticlesErrors],\n  errors => Object.values(errors).find(error => error !== null) || null\n);\n\n// Pagination selectors\nexport const selectArticlesPagination = createSelector(\n  [selectArticlesState],\n  articlesState => articlesState.pagination\n);\n\nexport const selectCurrentPage = createSelector(\n  [selectArticlesPagination],\n  pagination => pagination.page\n);\n\nexport const selectPageSize = createSelector(\n  [selectArticlesPagination],\n  pagination => pagination.limit\n);\n\nexport const selectTotalPages = createSelector(\n  [selectArticlesPagination],\n  pagination => pagination.totalPages\n);\n\nexport const selectTotalArticles = createSelector(\n  [selectArticlesPagination],\n  pagination => pagination.totalItems\n);\n\nexport const selectHasMoreArticles = createSelector(\n  [selectArticlesPagination],\n  pagination => pagination.hasMore\n);\n\nexport const selectPaginationInfo = createSelector(\n  [selectArticlesPagination],\n  pagination => ({\n    currentPage: pagination.page,\n    totalPages: pagination.totalPages,\n    totalItems: pagination.totalItems,\n    pageSize: pagination.limit,\n    hasMore: pagination.hasMore,\n    hasPrevious: pagination.page > 1,\n    isFirstPage: pagination.page === 1,\n    isLastPage: pagination.page >= pagination.totalPages,\n  })\n);\n\n// Filter selectors\nexport const selectArticlesFilters = createSelector(\n  [selectArticlesState],\n  articlesState => articlesState.filters\n);\n\nexport const selectSearchQuery = createSelector(\n  [selectArticlesFilters],\n  filters => filters.searchQuery\n);\n\nexport const selectArchivedFilter = createSelector(\n  [selectArticlesFilters],\n  filters => filters.isArchived\n);\n\nexport const selectFavoriteFilter = createSelector(\n  [selectArticlesFilters],\n  filters => filters.isFavorite\n);\n\nexport const selectReadFilter = createSelector(\n  [selectArticlesFilters],\n  filters => filters.isRead\n);\n\nexport const selectTagsFilter = createSelector(\n  [selectArticlesFilters],\n  filters => filters.tags\n);\n\nexport const selectHasActiveFilters = createSelector(\n  [selectArticlesFilters],\n  filters => {\n    return (\n      filters.searchQuery.length > 0 ||\n      filters.isArchived !== undefined ||\n      filters.isFavorite !== undefined ||\n      filters.isRead !== undefined ||\n      (filters.tags && filters.tags.length > 0)\n    );\n  }\n);\n\n// Sync state selectors\nexport const selectArticlesSync = createSelector(\n  [selectArticlesState],\n  articlesState => articlesState.sync\n);\n\nexport const selectLastSyncTime = createSelector(\n  [selectArticlesSync],\n  sync => sync.lastSyncTime\n);\n\nexport const selectIsSyncing = createSelector(\n  [selectArticlesSync],\n  sync => sync.isSyncing\n);\n\nexport const selectPendingChanges = createSelector(\n  [selectArticlesSync],\n  sync => sync.pendingChanges\n);\n\nexport const selectSyncConflicts = createSelector(\n  [selectArticlesSync],\n  sync => sync.conflicts\n);\n\nexport const selectSyncError = createSelector(\n  [selectArticlesSync],\n  sync => sync.syncError\n);\n\nexport const selectHasPendingChanges = createSelector(\n  [selectPendingChanges],\n  pendingChanges => pendingChanges.length > 0\n);\n\nexport const selectHasSyncConflicts = createSelector(\n  [selectSyncConflicts],\n  conflicts => conflicts.length > 0\n);\n\nexport const selectSyncStatus = createSelector(\n  [\n    selectIsSyncing,\n    selectLastSyncTime,\n    selectHasPendingChanges,\n    selectHasSyncConflicts,\n    selectSyncError,\n  ],\n  (\n    isSyncing,\n    lastSyncTime,\n    hasPendingChanges,\n    hasSyncConflicts,\n    syncError\n  ) => ({\n    isSyncing,\n    lastSyncTime,\n    hasPendingChanges,\n    hasSyncConflicts,\n    hasError: syncError !== null,\n    syncError,\n    status: isSyncing\n      ? 'syncing'\n      : syncError\n        ? 'error'\n        : hasSyncConflicts\n          ? 'conflicts'\n          : hasPendingChanges\n            ? 'pending'\n            : 'synced',\n  })\n);\n\n// Selection selectors\nexport const selectSelectedArticleId = createSelector(\n  [selectArticlesState],\n  articlesState => articlesState.selectedArticleId\n);\n\nexport const selectSelectedArticle = createSelector(\n  [selectSelectedArticleId, selectArticleEntities],\n  (selectedId, articles) => (selectedId ? articles[selectedId] || null : null)\n);\n\nexport const selectMultiSelectMode = createSelector(\n  [selectArticlesState],\n  articlesState => articlesState.multiSelectMode\n);\n\nexport const selectSelectedArticleIds = createSelector(\n  [selectArticlesState],\n  articlesState => articlesState.selectedArticleIds\n);\n\nexport const selectSelectedArticles = createSelector(\n  [selectSelectedArticleIds, selectArticleEntities],\n  (selectedIds, articles) =>\n    selectedIds.map(id => articles[id]).filter(Boolean) as Article[]\n);\n\nexport const selectSelectedArticlesCount = createSelector(\n  [selectSelectedArticleIds],\n  selectedIds => selectedIds.length\n);\n\nexport const selectHasSelectedArticles = createSelector(\n  [selectSelectedArticlesCount],\n  count => count > 0\n);\n\n// Filtered and sorted articles selectors\nexport const selectFilteredArticles = createSelector(\n  [selectAllArticles, selectArticlesFilters],\n  (articles, filters) => {\n    return articles.filter(article => {\n      // Search query filter\n      if (filters.searchQuery) {\n        const query = filters.searchQuery.toLowerCase();\n        const searchableText = [\n          article.title,\n          article.summary,\n          article.content,\n          ...(article.tags || []),\n        ]\n          .join(' ')\n          .toLowerCase();\n\n        if (!searchableText.includes(query)) {\n          return false;\n        }\n      }\n\n      // Archive filter\n      if (\n        filters.isArchived !== undefined &&\n        article.isArchived !== filters.isArchived\n      ) {\n        return false;\n      }\n\n      // Favorite filter\n      if (\n        filters.isFavorite !== undefined &&\n        article.isFavorite !== filters.isFavorite\n      ) {\n        return false;\n      }\n\n      // Read filter\n      if (filters.isRead !== undefined && article.isRead !== filters.isRead) {\n        return false;\n      }\n\n      // Tags filter\n      if (filters.tags && filters.tags.length > 0) {\n        const articleTags = article.tags || [];\n        const hasMatchingTag = filters.tags.some(tag =>\n          articleTags.includes(tag)\n        );\n        if (!hasMatchingTag) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n);\n\n// Category-specific selectors\nexport const selectUnreadArticles = createSelector(\n  [selectAllArticles],\n  articles => articles.filter(article => !article.isRead && !article.isArchived)\n);\n\nexport const selectFavoriteArticles = createSelector(\n  [selectAllArticles],\n  articles =>\n    articles.filter(article => article.isFavorite && !article.isArchived)\n);\n\nexport const selectArchivedArticles = createSelector(\n  [selectAllArticles],\n  articles => articles.filter(article => article.isArchived)\n);\n\nexport const selectRecentArticles = createSelector(\n  [selectAllArticles],\n  articles => {\n    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();\n    return articles.filter(\n      article => article.createdAt > oneDayAgo && !article.isArchived\n    );\n  }\n);\n\n// Statistics selectors\nexport const selectArticlesStats = createSelector(\n  [selectAllArticles],\n  articles => {\n    const stats = {\n      total: articles.length,\n      unread: 0,\n      favorites: 0,\n      archived: 0,\n      read: 0,\n      recent: 0, // Last 24 hours\n    };\n\n    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();\n\n    articles.forEach(article => {\n      if (!article.isRead && !article.isArchived) stats.unread++;\n      if (article.isFavorite) stats.favorites++;\n      if (article.isArchived) stats.archived++;\n      if (article.isRead) stats.read++;\n      if (article.createdAt > oneDayAgo && !article.isArchived) stats.recent++;\n    });\n\n    return stats;\n  }\n);\n\n// Utility selectors\nexport const selectArticlesByIds = createSelector(\n  [selectArticleEntities, (_: RootState, articleIds: string[]) => articleIds],\n  (articles, articleIds) =>\n    articleIds.map(id => articles[id]).filter(Boolean) as Article[]\n);\n\nexport const selectArticlesByTag = createSelector(\n  [selectAllArticles, (_: RootState, tag: string) => tag],\n  (articles, tag) => articles.filter(article => article.tags?.includes(tag))\n);\n\nexport const selectArticleConflictStatus = createSelector(\n  [\n    selectSyncConflicts,\n    selectPendingChanges,\n    (_: RootState, articleId: string) => articleId,\n  ],\n  (conflicts, pendingChanges, articleId) => ({\n    hasConflict: conflicts.includes(articleId),\n    hasPendingChanges: pendingChanges.includes(articleId),\n    needsSync:\n      conflicts.includes(articleId) || pendingChanges.includes(articleId),\n  })\n);\n\n// Performance-optimized selectors for large lists\nexport const selectArticlesCount = createSelector(\n  [selectAllArticles],\n  articles => articles.length\n);\n\nexport const selectFilteredArticlesCount = createSelector(\n  [selectFilteredArticles],\n  articles => articles.length\n);\n\nexport const selectArticleExists = createSelector(\n  [selectArticleEntities, (_: RootState, articleId: string) => articleId],\n  (articles, articleId) => Boolean(articles[articleId])\n);\n\n// Complex computed selectors\nexport const selectArticlesWithSyncStatus = createSelector(\n  [selectAllArticles, selectPendingChanges, selectSyncConflicts],\n  (articles, pendingChanges, conflicts) => {\n    return articles.map(article => ({\n      ...article,\n      syncStatus: {\n        hasConflict: conflicts.includes(article.id),\n        hasPendingChanges: pendingChanges.includes(article.id),\n        needsSync:\n          conflicts.includes(article.id) || pendingChanges.includes(article.id),\n      },\n    }));\n  }\n);\n\nexport const selectArticleNavigationInfo = createSelector(\n  [selectFilteredArticles, selectSelectedArticleId],\n  (articles, selectedId) => {\n    if (!selectedId || articles.length === 0) {\n      return null;\n    }\n\n    const currentIndex = articles.findIndex(\n      article => article.id === selectedId\n    );\n    if (currentIndex === -1) {\n      return null;\n    }\n\n    return {\n      currentIndex,\n      totalCount: articles.length,\n      hasNext: currentIndex < articles.length - 1,\n      hasPrevious: currentIndex > 0,\n      nextArticleId:\n        currentIndex < articles.length - 1\n          ? articles[currentIndex + 1].id\n          : null,\n      previousArticleId:\n        currentIndex > 0 ? articles[currentIndex - 1].id : null,\n    };\n  }\n);\n\n// Export all selectors for easy importing\nexport {\n  selectAllArticles,\n  selectArticleById,\n  selectArticleEntities,\n} from '../slices/articlesSlice';\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/store/selectors/authSelectors.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AuthenticatedUser' is defined but never used.","line":3,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":38}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createSelector } from '@reduxjs/toolkit';\nimport { RootState } from '../index';\nimport { AuthState, AuthenticatedUser } from '../../types/auth';\n\nexport const selectAuth = (state: RootState): AuthState => state.auth;\n\nexport const selectIsAuthenticated = createSelector(\n  selectAuth,\n  auth => auth.isAuthenticated\n);\n\nexport const selectCurrentUser = createSelector(selectAuth, auth => auth.user);\n\nexport const selectAuthToken = createSelector(selectAuth, auth => auth.token);\n\nexport const selectAuthLoading = createSelector(\n  selectAuth,\n  auth => auth.loading\n);\n\nexport const selectAuthError = createSelector(selectAuth, auth => auth.error);\n\nexport const selectLastTokenRefresh = createSelector(\n  selectAuth,\n  auth => auth.lastTokenRefresh\n);\n\nexport const selectIsUserAuthenticated = createSelector(\n  [selectIsAuthenticated, selectCurrentUser],\n  (isAuthenticated, user) => isAuthenticated && user !== null\n);\n\nexport const selectUserServerUrl = createSelector(\n  selectCurrentUser,\n  user => user?.serverUrl || null\n);\n\nexport const selectUserUsername = createSelector(\n  selectCurrentUser,\n  user => user?.username || null\n);\n\nexport const selectUserEmail = createSelector(\n  selectCurrentUser,\n  user => user?.email || null\n);\n\nexport const selectIsTokenExpired = createSelector(selectCurrentUser, user => {\n  if (!user || !user.tokenExpiresAt) return true;\n  return new Date(user.tokenExpiresAt) <= new Date();\n});\n\nexport const selectTokenExpirationTime = createSelector(\n  selectCurrentUser,\n  user => {\n    if (!user || !user.tokenExpiresAt) return null;\n    const expirationTime = new Date(user.tokenExpiresAt);\n    const currentTime = new Date();\n    const msUntilExpiration = expirationTime.getTime() - currentTime.getTime();\n    return msUntilExpiration > 0 ? Math.floor(msUntilExpiration / 1000) : 0;\n  }\n);\n\nexport const selectShouldRefreshToken = createSelector(\n  [selectIsAuthenticated, selectTokenExpirationTime, selectLastTokenRefresh],\n  (isAuthenticated, timeUntilExpiration, lastRefresh) => {\n    if (!isAuthenticated || !timeUntilExpiration) return false;\n\n    const REFRESH_THRESHOLD = 5 * 60; // 5 minutes before expiration\n    const MIN_REFRESH_INTERVAL = 30 * 60; // Don't refresh more than once every 30 minutes\n\n    if (timeUntilExpiration <= REFRESH_THRESHOLD) {\n      if (!lastRefresh) return true;\n\n      const timeSinceLastRefresh =\n        (new Date().getTime() - new Date(lastRefresh).getTime()) / 1000;\n      return timeSinceLastRefresh >= MIN_REFRESH_INTERVAL;\n    }\n\n    return false;\n  }\n);\n\nexport const selectAuthStatusSummary = createSelector(\n  [\n    selectIsAuthenticated,\n    selectCurrentUser,\n    selectAuthLoading,\n    selectAuthError,\n    selectIsTokenExpired,\n    selectTokenExpirationTime,\n  ],\n  (\n    isAuthenticated,\n    user,\n    loading,\n    error,\n    isTokenExpired,\n    timeUntilExpiration\n  ) => ({\n    isAuthenticated,\n    hasUser: user !== null,\n    loading,\n    error,\n    isTokenExpired,\n    timeUntilExpiration,\n    serverUrl: user?.serverUrl || null,\n    username: user?.username || null,\n  })\n);\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/store/selectors/syncSelectors.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SyncPhase' is defined but never used.","line":3,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":31}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createSelector } from '@reduxjs/toolkit';\nimport { RootState } from '../index';\nimport { SyncStatus, SyncPhase, ConflictType } from '../../types/sync';\n\n// Base selector for sync state\nconst selectSyncState = (state: RootState) => state.sync;\n\n// Basic selectors\nexport const selectSyncStatus = createSelector(\n  [selectSyncState],\n  sync => sync.status\n);\n\nexport const selectLastSyncTime = createSelector(\n  [selectSyncState],\n  sync => sync.lastSyncTime\n);\n\nexport const selectSyncError = createSelector(\n  [selectSyncState],\n  sync => sync.error\n);\n\nexport const selectIsOnline = createSelector(\n  [selectSyncState],\n  sync => sync.isOnline\n);\n\nexport const selectNetworkType = createSelector(\n  [selectSyncState],\n  sync => sync.networkType\n);\n\n// Progress selectors\nexport const selectSyncProgress = createSelector(\n  [selectSyncState],\n  sync => sync.progress\n);\n\nexport const selectSyncPhase = createSelector(\n  [selectSyncProgress],\n  progress => progress.phase\n);\n\nexport const selectSyncProgressPercentage = createSelector(\n  [selectSyncProgress],\n  progress => {\n    if (progress.totalItems === 0) return 0;\n    return Math.round((progress.processedItems / progress.totalItems) * 100);\n  }\n);\n\nexport const selectCurrentSyncItem = createSelector(\n  [selectSyncProgress],\n  progress => progress.currentItem\n);\n\nexport const selectEstimatedTimeRemaining = createSelector(\n  [selectSyncProgress],\n  progress => progress.estimatedTimeRemaining\n);\n\n// Configuration selectors\nexport const selectSyncConfig = createSelector(\n  [selectSyncState],\n  sync => sync.config\n);\n\nexport const selectBackgroundSyncEnabled = createSelector(\n  [selectSyncConfig],\n  config => config.backgroundSyncEnabled\n);\n\nexport const selectSyncInterval = createSelector(\n  [selectSyncConfig],\n  config => config.syncInterval\n);\n\nexport const selectSyncOnWifiOnly = createSelector(\n  [selectSyncConfig],\n  config => config.syncOnWifiOnly\n);\n\nexport const selectConflictResolutionStrategy = createSelector(\n  [selectSyncConfig],\n  config => config.conflictResolutionStrategy\n);\n\n// Conflict selectors\nexport const selectSyncConflicts = createSelector(\n  [selectSyncState],\n  sync => sync.conflicts\n);\n\nexport const selectConflictCount = createSelector(\n  [selectSyncConflicts],\n  conflicts => conflicts.length\n);\n\nexport const selectUnresolvedConflicts = createSelector(\n  [selectSyncConflicts],\n  conflicts => conflicts.filter(conflict => !conflict.resolvedAt)\n);\n\nexport const selectConflictsByType = createSelector(\n  [selectSyncConflicts],\n  conflicts => {\n    return conflicts.reduce(\n      (acc, conflict) => {\n        const type = conflict.type;\n        if (!acc[type]) {\n          acc[type] = [];\n        }\n        acc[type].push(conflict);\n        return acc;\n      },\n      {} as Record<ConflictType, typeof conflicts>\n    );\n  }\n);\n\nexport const selectConflictsByArticle = createSelector(\n  [selectSyncConflicts],\n  conflicts => {\n    return conflicts.reduce(\n      (acc, conflict) => {\n        const articleId = conflict.articleId;\n        if (!acc[articleId]) {\n          acc[articleId] = [];\n        }\n        acc[articleId].push(conflict);\n        return acc;\n      },\n      {} as Record<string, typeof conflicts>\n    );\n  }\n);\n\n// Statistics selectors\nexport const selectSyncStats = createSelector(\n  [selectSyncState],\n  sync => sync.stats\n);\n\nexport const selectTotalSyncs = createSelector(\n  [selectSyncStats],\n  stats => stats.totalSyncs\n);\n\nexport const selectSuccessfulSyncs = createSelector(\n  [selectSyncStats],\n  stats => stats.successfulSyncs\n);\n\nexport const selectFailedSyncs = createSelector(\n  [selectSyncStats],\n  stats => stats.failedSyncs\n);\n\nexport const selectSyncSuccessRate = createSelector(\n  [selectTotalSyncs, selectSuccessfulSyncs],\n  (total, successful) => {\n    if (total === 0) return 0;\n    return Math.round((successful / total) * 100);\n  }\n);\n\nexport const selectLastSyncDuration = createSelector(\n  [selectSyncStats],\n  stats => stats.lastSyncDuration\n);\n\nexport const selectAverageSyncDuration = createSelector(\n  [selectSyncStats],\n  stats => stats.averageSyncDuration\n);\n\nexport const selectItemsSynced = createSelector(\n  [selectSyncStats],\n  stats => stats.itemsSynced\n);\n\nexport const selectDataTransferStats = createSelector(\n  [selectSyncStats],\n  stats => stats.dataTransfer\n);\n\nexport const selectTotalDataTransferred = createSelector(\n  [selectDataTransferStats],\n  dataTransfer => dataTransfer.bytesUploaded + dataTransfer.bytesDownloaded\n);\n\n// Boolean selectors for UI state\nexport const selectIsSyncing = createSelector(\n  [selectSyncStatus],\n  status => status === SyncStatus.SYNCING\n);\n\nexport const selectIsSyncIdle = createSelector(\n  [selectSyncStatus],\n  status => status === SyncStatus.IDLE\n);\n\nexport const selectIsSyncSuccessful = createSelector(\n  [selectSyncStatus],\n  status => status === SyncStatus.SUCCESS\n);\n\nexport const selectIsSyncError = createSelector(\n  [selectSyncStatus],\n  status => status === SyncStatus.ERROR\n);\n\nexport const selectIsSyncPaused = createSelector(\n  [selectSyncStatus],\n  status => status === SyncStatus.PAUSED\n);\n\nexport const selectHasConflicts = createSelector(\n  [selectConflictCount],\n  count => count > 0\n);\n\nexport const selectHasSyncError = createSelector(\n  [selectSyncError],\n  error => error !== null\n);\n\nexport const selectCanSync = createSelector(\n  [selectIsOnline, selectSyncStatus, selectSyncConfig],\n  (isOnline, status, config) => {\n    if (!isOnline) return false;\n    if (status === SyncStatus.SYNCING) return false;\n\n    // Check network restrictions\n    if (config.syncOnWifiOnly && config.syncOnCellular === false) {\n      // Would need to check network type here\n      return true; // Simplified for now\n    }\n\n    return true;\n  }\n);\n\n// Complex computed selectors\nexport const selectSyncStatusSummary = createSelector(\n  [\n    selectSyncStatus,\n    selectLastSyncTime,\n    selectSyncError,\n    selectConflictCount,\n    selectSyncProgressPercentage,\n    selectCurrentSyncItem,\n  ],\n  (\n    status,\n    lastSyncTime,\n    error,\n    conflictCount,\n    progressPercentage,\n    currentItem\n  ) => ({\n    status,\n    lastSyncTime,\n    error,\n    conflictCount,\n    progressPercentage,\n    currentItem,\n    hasIssues: error !== null || conflictCount > 0,\n  })\n);\n\nexport const selectSyncHealthMetrics = createSelector(\n  [\n    selectSyncSuccessRate,\n    selectAverageSyncDuration,\n    selectConflictCount,\n    selectTotalDataTransferred,\n    selectIsOnline,\n  ],\n  (successRate, avgDuration, conflicts, dataTransferred, isOnline) => ({\n    successRate,\n    avgDuration,\n    conflicts,\n    dataTransferred,\n    isOnline,\n    healthScore: calculateHealthScore(successRate, conflicts, isOnline),\n  })\n);\n\n// Helper function for health score calculation\nfunction calculateHealthScore(\n  successRate: number,\n  conflictCount: number,\n  isOnline: boolean\n): number {\n  let score = 100;\n\n  // Reduce score based on success rate\n  score -= (100 - successRate) * 0.5;\n\n  // Reduce score for conflicts\n  score -= Math.min(conflictCount * 5, 30);\n\n  // Reduce score if offline\n  if (!isOnline) {\n    score -= 20;\n  }\n\n  return Math.max(0, Math.round(score));\n}\n\n// Selectors for sync timing and scheduling\nexport const selectNextSyncTime = createSelector(\n  [selectLastSyncTime, selectSyncInterval],\n  (lastSyncTime, interval) => {\n    if (!lastSyncTime) return null;\n\n    const lastSync = new Date(lastSyncTime);\n    const nextSync = new Date(lastSync.getTime() + interval * 60 * 1000);\n\n    return nextSync.toISOString();\n  }\n);\n\nexport const selectTimeUntilNextSync = createSelector(\n  [selectNextSyncTime],\n  nextSyncTime => {\n    if (!nextSyncTime) return null;\n\n    const now = new Date();\n    const next = new Date(nextSyncTime);\n    const diff = next.getTime() - now.getTime();\n\n    return Math.max(0, diff);\n  }\n);\n\nexport const selectIsSyncDue = createSelector(\n  [selectTimeUntilNextSync],\n  timeUntilNext => {\n    if (timeUntilNext === null) return false;\n    return timeUntilNext <= 0;\n  }\n);\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/store/slices/articlesSlice.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":175,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":175,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[4025,4086],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":227,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":227,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5899,5991],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":229,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":229,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[6022,6101],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":265,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":265,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7180,7279],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getState' is defined but never used. Allowed unused args must match /^_/u.","line":294,"column":67,"nodeType":null,"messageId":"unusedVar","endLine":294,"endColumn":75},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":296,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":296,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8162,8233],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":312,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":312,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8663,8758],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":352,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":352,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[10310,10375],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  createSlice,\n  createAsyncThunk,\n  PayloadAction,\n  createEntityAdapter,\n} from '@reduxjs/toolkit';\nimport { Article, PaginatedResponse } from '../../types';\nimport { RootState } from '../index';\nimport { articlesApiService } from '../../services/ArticlesApiService';\nimport DatabaseService from '../../services/DatabaseService';\n\n// Entity adapter for normalized state management\nconst articlesAdapter = createEntityAdapter<Article>({\n  selectId: article => article.id,\n  sortComparer: (a, b) =>\n    new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime(),\n});\n\n// Enhanced state interface with sync state and pagination\nexport interface ArticlesState\n  extends ReturnType<typeof articlesAdapter.getInitialState> {\n  // Loading states\n  loading: {\n    fetch: boolean;\n    create: boolean;\n    update: boolean;\n    delete: boolean;\n    sync: boolean;\n  };\n\n  // Error states\n  error: {\n    fetch: string | null;\n    create: string | null;\n    update: string | null;\n    delete: string | null;\n    sync: string | null;\n  };\n\n  // Pagination state\n  pagination: {\n    page: number;\n    limit: number;\n    totalPages: number;\n    totalItems: number;\n    hasMore: boolean;\n  };\n\n  // Search and filtering\n  filters: {\n    searchQuery: string;\n    isArchived?: boolean;\n    isFavorite?: boolean;\n    isRead?: boolean;\n    tags?: string[];\n  };\n\n  // Sync state management\n  sync: {\n    lastSyncTime: string | null;\n    isSyncing: boolean;\n    pendingChanges: string[]; // Article IDs with pending changes\n    conflicts: string[]; // Article IDs with sync conflicts\n    syncError: string | null;\n  };\n\n  // UI state\n  selectedArticleId: string | null;\n  multiSelectMode: boolean;\n  selectedArticleIds: string[];\n}\n\n// Initial state\nconst initialState: ArticlesState = {\n  ...articlesAdapter.getInitialState(),\n  loading: {\n    fetch: false,\n    create: false,\n    update: false,\n    delete: false,\n    sync: false,\n  },\n  error: {\n    fetch: null,\n    create: null,\n    update: null,\n    delete: null,\n    sync: null,\n  },\n  pagination: {\n    page: 1,\n    limit: 20,\n    totalPages: 0,\n    totalItems: 0,\n    hasMore: false,\n  },\n  filters: {\n    searchQuery: '',\n    isArchived: undefined,\n    isFavorite: undefined,\n    isRead: undefined,\n    tags: undefined,\n  },\n  sync: {\n    lastSyncTime: null,\n    isSyncing: false,\n    pendingChanges: [],\n    conflicts: [],\n    syncError: null,\n  },\n  selectedArticleId: null,\n  multiSelectMode: false,\n  selectedArticleIds: [],\n};\n\n// Async thunk interfaces\ninterface FetchArticlesParams {\n  page?: number;\n  limit?: number;\n  searchQuery?: string;\n  filters?: Partial<ArticlesState['filters']>;\n  forceRefresh?: boolean;\n  fetchFullContent?: boolean;\n}\n\ninterface CreateArticleParams {\n  title: string;\n  url: string;\n  summary?: string;\n  content?: string;\n  tags?: string[];\n}\n\ninterface UpdateArticleParams {\n  id: string;\n  updates: Partial<Omit<Article, 'id' | 'createdAt' | 'updatedAt'>>;\n}\n\ninterface DeleteArticleParams {\n  id: string;\n  permanent?: boolean;\n}\n\ninterface SyncArticlesParams {\n  fullSync?: boolean;\n  articlesOnly?: boolean;\n}\n\n// Async thunk actions\nexport const fetchArticles = createAsyncThunk<\n  PaginatedResponse<Article>,\n  FetchArticlesParams,\n  { rejectValue: string; state: RootState }\n>('articles/fetchArticles', async (params, { rejectWithValue, getState }) => {\n  try {\n    const state = getState();\n    \n    // Check if user is authenticated\n    if (!state.auth.isAuthenticated || !state.auth.user) {\n      return rejectWithValue('Please configure your Readeck server settings first');\n    }\n\n    const currentPage = params.page || state.articles.pagination.page;\n\n    const response = await articlesApiService.fetchArticles({\n      ...params,\n      page: currentPage,\n      limit: params.limit || state.articles.pagination.limit,\n      filters: params.filters || state.articles.filters,\n      fetchFullContent: false, // Disable bulk full content fetching to avoid API spam\n    });\n\n    return response;\n  } catch (error) {\n    console.error('[articlesSlice] fetchArticles error:', error);\n    \n    let errorMessage = 'Failed to fetch articles';\n    if (error instanceof Error) {\n      if (error.message.includes('401') || error.message.includes('unauthorized')) {\n        errorMessage = 'Authentication failed. Please check your server settings.';\n      } else if (error.message.includes('404') || error.message.includes('not found')) {\n        errorMessage = 'Server not found. Please check your server URL.';\n      } else if (error.message.includes('Network') || error.message.includes('network')) {\n        errorMessage = 'Network error. Please check your connection and server URL.';\n      } else {\n        errorMessage = error.message;\n      }\n    }\n    \n    return rejectWithValue(errorMessage);\n  }\n});\n\nexport const createArticle = createAsyncThunk<\n  Article,\n  CreateArticleParams,\n  { rejectValue: string }\n>('articles/createArticle', async (params, { rejectWithValue }) => {\n  try {\n    const article = await articlesApiService.createArticle(params);\n    return article;\n  } catch (error) {\n    const errorMessage =\n      error instanceof Error ? error.message : 'Failed to create article';\n    return rejectWithValue(errorMessage);\n  }\n});\n\nexport const updateArticle = createAsyncThunk<\n  Article,\n  UpdateArticleParams,\n  { rejectValue: string }\n>('articles/updateArticle', async (params, { rejectWithValue }) => {\n  try {\n    // Update via API first\n    const article = await articlesApiService.updateArticle(params);\n    \n    // Also persist to local database with is_modified flag for sync\n    try {\n      const updatedArticleForDB = {\n        ...article,\n        isModified: true, // Mark as modified for sync\n        syncedAt: null, // Clear synced timestamp since it's now modified\n      };\n      \n      await DatabaseService.updateArticle(article.id, updatedArticleForDB);\n      console.log('[ArticlesSlice] Article updated in database and marked for sync:', article.id);\n    } catch (dbError) {\n      console.warn('[ArticlesSlice] Failed to update article in database:', dbError);\n      // Don't fail the whole operation if database update fails\n    }\n    \n    return article;\n  } catch (error) {\n    const errorMessage =\n      error instanceof Error ? error.message : 'Failed to update article';\n    return rejectWithValue(errorMessage);\n  }\n});\n\nexport const updateArticleLocalWithDB = createAsyncThunk<\n  Article,\n  { id: string; updates: Partial<Article> },\n  { rejectValue: string }\n>('articles/updateArticleLocalWithDB', async (params, { rejectWithValue, getState }) => {\n  try {\n    const state = getState() as RootState;\n    const existingArticle = state.articles.entities[params.id];\n    \n    if (!existingArticle) {\n      throw new Error('Article not found');\n    }\n    \n    // Merge updates with existing article\n    const updatedArticle = {\n      ...existingArticle,\n      ...params.updates,\n      isModified: true, // Mark as modified for sync\n      syncedAt: null, // Clear synced timestamp\n      updatedAt: new Date().toISOString(),\n    };\n    \n    // Persist to database\n    await DatabaseService.updateArticle(params.id, updatedArticle);\n    console.log('[ArticlesSlice] Article updated locally in database and marked for sync:', params.id);\n    \n    return updatedArticle;\n  } catch (error) {\n    const errorMessage =\n      error instanceof Error ? error.message : 'Failed to update article locally';\n    return rejectWithValue(errorMessage);\n  }\n});\n\nexport const deleteArticle = createAsyncThunk<\n  string,\n  DeleteArticleParams,\n  { rejectValue: string }\n>('articles/deleteArticle', async (params, { rejectWithValue }) => {\n  try {\n    await articlesApiService.deleteArticle(params);\n    return params.id;\n  } catch (error) {\n    const errorMessage =\n      error instanceof Error ? error.message : 'Failed to delete article';\n    return rejectWithValue(errorMessage);\n  }\n});\n\nexport const loadLocalArticles = createAsyncThunk<\n  PaginatedResponse<Article>,\n  FetchArticlesParams,\n  { rejectValue: string; state: RootState }\n>('articles/loadLocalArticles', async (params, { rejectWithValue, getState }) => {\n  try {\n    console.log('[articlesSlice] Loading articles from local database...');\n    \n    const page = params.page || 1;\n    const limit = params.limit || 20;\n    const offset = (page - 1) * limit;\n    \n    const result = await DatabaseService.getArticles({\n      limit,\n      offset,\n      searchQuery: params.searchQuery,\n      isArchived: params.filters?.isArchived,\n      isFavorite: params.filters?.isFavorite,\n      isRead: params.filters?.isRead,\n    });\n\n    if (result.success && result.data) {\n      console.log(`[articlesSlice] Loaded ${result.data.items.length} articles from local database`);\n      \n      // Convert database articles to Article format\n      const articles = result.data.items.map(dbArticle => ({\n        id: dbArticle.id,\n        title: dbArticle.title,\n        url: dbArticle.url,\n        summary: dbArticle.summary || '',\n        content: dbArticle.content || '',\n        imageUrl: dbArticle.image_url || '',\n        readTime: dbArticle.read_time || 0,\n        isArchived: Boolean(dbArticle.is_archived),\n        isFavorite: Boolean(dbArticle.is_favorite),\n        isRead: Boolean(dbArticle.is_read),\n        tags: [], // Tags not implemented in local DB yet\n        sourceUrl: dbArticle.source_url || dbArticle.url,\n        createdAt: new Date(dbArticle.created_at * 1000).toISOString(),\n        updatedAt: new Date(dbArticle.updated_at * 1000).toISOString(),\n        syncedAt: dbArticle.synced_at ? new Date(dbArticle.synced_at * 1000).toISOString() : undefined,\n      }));\n\n      // Calculate pagination from database result\n      const currentPage = Math.floor(result.data.offset / result.data.limit) + 1;\n      const totalPages = Math.ceil(result.data.totalCount / result.data.limit);\n      \n      return {\n        items: articles,\n        pagination: {\n          page: currentPage,\n          limit: result.data.limit,\n          total: result.data.totalCount,\n          pages: totalPages,\n          hasNextPage: result.data.hasMore,\n          hasPreviousPage: result.data.offset > 0,\n        },\n      };\n    } else {\n      throw new Error(result.error || 'Failed to load local articles');\n    }\n  } catch (error) {\n    console.error('[articlesSlice] loadLocalArticles error:', error);\n    return rejectWithValue(error instanceof Error ? error.message : 'Failed to load local articles');\n  }\n});\n\nexport const syncArticles = createAsyncThunk<\n  { syncedCount: number; conflictCount: number },\n  SyncArticlesParams,\n  { rejectValue: string }\n>('articles/syncArticles', async (params, { rejectWithValue }) => {\n  try {\n    const result = await articlesApiService.syncArticles(params);\n    return result;\n  } catch (error) {\n    const errorMessage =\n      error instanceof Error ? error.message : 'Failed to sync articles';\n    return rejectWithValue(errorMessage);\n  }\n});\n\n// Slice definition\nconst articlesSlice = createSlice({\n  name: 'articles',\n  initialState,\n  reducers: {\n    // Clear errors\n    clearError: (\n      state,\n      action: PayloadAction<keyof ArticlesState['error'] | 'all'>\n    ) => {\n      if (action.payload === 'all') {\n        state.error = initialState.error;\n      } else {\n        state.error[action.payload] = null;\n      }\n    },\n\n    // Update filters\n    setFilters: (\n      state,\n      action: PayloadAction<Partial<ArticlesState['filters']>>\n    ) => {\n      state.filters = { ...state.filters, ...action.payload };\n      // Reset pagination when filters change\n      state.pagination.page = 1;\n    },\n\n    clearFilters: state => {\n      state.filters = initialState.filters;\n      state.pagination.page = 1;\n    },\n\n    // Pagination\n    setPage: (state, action: PayloadAction<number>) => {\n      state.pagination.page = action.payload;\n    },\n\n    setPageSize: (state, action: PayloadAction<number>) => {\n      state.pagination.limit = action.payload;\n      state.pagination.page = 1; // Reset to first page\n    },\n\n    // Article selection\n    setSelectedArticle: (state, action: PayloadAction<string | null>) => {\n      state.selectedArticleId = action.payload;\n    },\n\n    toggleMultiSelectMode: state => {\n      state.multiSelectMode = !state.multiSelectMode;\n      if (!state.multiSelectMode) {\n        state.selectedArticleIds = [];\n      }\n    },\n\n    toggleArticleSelection: (state, action: PayloadAction<string>) => {\n      const articleId = action.payload;\n      const index = state.selectedArticleIds.indexOf(articleId);\n      if (index > -1) {\n        state.selectedArticleIds.splice(index, 1);\n      } else {\n        state.selectedArticleIds.push(articleId);\n      }\n    },\n\n    clearSelection: state => {\n      state.selectedArticleIds = [];\n      state.multiSelectMode = false;\n    },\n\n    // Local article updates (for optimistic updates)\n    updateArticleLocal: (\n      state,\n      action: PayloadAction<{ id: string; updates: Partial<Article> }>\n    ) => {\n      const { id, updates } = action.payload;\n      const existingArticle = state.entities[id];\n      if (existingArticle) {\n        articlesAdapter.updateOne(state, {\n          id,\n          changes: {\n            ...updates,\n            updatedAt: new Date().toISOString(),\n          },\n        });\n\n        // Mark as having pending changes for sync\n        if (!state.sync.pendingChanges.includes(id)) {\n          state.sync.pendingChanges.push(id);\n        }\n      }\n    },\n\n    // Sync state management\n    markSyncConflict: (state, action: PayloadAction<string>) => {\n      const articleId = action.payload;\n      if (!state.sync.conflicts.includes(articleId)) {\n        state.sync.conflicts.push(articleId);\n      }\n    },\n\n    resolveSyncConflict: (state, action: PayloadAction<string>) => {\n      const articleId = action.payload;\n      state.sync.conflicts = state.sync.conflicts.filter(\n        id => id !== articleId\n      );\n      state.sync.pendingChanges = state.sync.pendingChanges.filter(\n        id => id !== articleId\n      );\n    },\n\n    clearSyncError: state => {\n      state.sync.syncError = null;\n    },\n\n    // Clear all articles data (used during logout)\n    clearAll: state => {\n      articlesAdapter.removeAll(state);\n      return {\n        ...initialState,\n        ids: state.ids,\n        entities: state.entities,\n      };\n    },\n  },\n\n  extraReducers: builder => {\n    builder\n      // Fetch articles\n      .addCase(fetchArticles.pending, state => {\n        state.loading.fetch = true;\n        state.error.fetch = null;\n      })\n      .addCase(fetchArticles.fulfilled, (state, action) => {\n        state.loading.fetch = false;\n        state.error.fetch = null;\n\n        const { items, page, totalPages, totalItems } = action.payload;\n\n        // Update pagination\n        state.pagination = {\n          page,\n          totalPages,\n          totalItems,\n          limit: state.pagination.limit,\n          hasMore: page < totalPages,\n        };\n\n        // Handle pagination: replace for page 1, append for subsequent pages\n        if (page === 1) {\n          articlesAdapter.setAll(state, items);\n        } else {\n          articlesAdapter.addMany(state, items);\n        }\n      })\n      .addCase(fetchArticles.rejected, (state, action) => {\n        state.loading.fetch = false;\n        state.error.fetch = action.payload || 'Failed to fetch articles';\n      })\n\n      // Load local articles\n      .addCase(loadLocalArticles.pending, state => {\n        state.loading.fetch = true;\n        state.error.fetch = null;\n      })\n      .addCase(loadLocalArticles.fulfilled, (state, action) => {\n        state.loading.fetch = false;\n        state.error.fetch = null;\n\n        const { items, pagination } = action.payload;\n\n        // Update pagination\n        state.pagination = {\n          page: pagination.page,\n          totalPages: pagination.pages,\n          totalItems: pagination.total,\n          limit: pagination.limit,\n          hasMore: pagination.hasNextPage,\n        };\n\n        // Handle pagination: replace for page 1, append for subsequent pages\n        if (pagination.page === 1) {\n          articlesAdapter.setAll(state, items);\n        } else {\n          articlesAdapter.addMany(state, items);\n        }\n      })\n      .addCase(loadLocalArticles.rejected, (state, action) => {\n        state.loading.fetch = false;\n        state.error.fetch = action.payload || 'Failed to load local articles';\n      })\n\n      // Create article\n      .addCase(createArticle.pending, state => {\n        state.loading.create = true;\n        state.error.create = null;\n      })\n      .addCase(createArticle.fulfilled, (state, action) => {\n        state.loading.create = false;\n        state.error.create = null;\n        articlesAdapter.addOne(state, action.payload);\n        state.pagination.totalItems += 1;\n      })\n      .addCase(createArticle.rejected, (state, action) => {\n        state.loading.create = false;\n        state.error.create = action.payload || 'Failed to create article';\n      })\n\n      // Update article\n      .addCase(updateArticle.pending, state => {\n        state.loading.update = true;\n        state.error.update = null;\n      })\n      .addCase(updateArticle.fulfilled, (state, action) => {\n        state.loading.update = false;\n        state.error.update = null;\n        \n        // Get existing article to preserve fields that might not be in API response\n        const existingArticle = state.entities[action.payload.id];\n        \n        if (existingArticle) {\n          // Create a smart merge that preserves important fields like content\n          const mergedChanges = { ...existingArticle };\n          \n          // Only update fields that are meaningful (not empty strings or undefined)\n          Object.entries(action.payload).forEach(([key, value]) => {\n            // Always update these fields regardless of value\n            const alwaysUpdateFields = ['id', 'isRead', 'isArchived', 'isFavorite', 'tags', 'syncedAt', 'updatedAt'];\n            \n            // For content, only update if the new value has actual content\n            if (key === 'content') {\n              if (value && typeof value === 'string' && value.trim().length > 0) {\n                mergedChanges[key] = value;\n              }\n              // Otherwise keep existing content\n            }\n            // For other fields, update if not empty or if it's an always-update field\n            else if (alwaysUpdateFields.includes(key) || (value !== '' && value !== null && value !== undefined)) {\n              mergedChanges[key] = value;\n            }\n          });\n          \n          articlesAdapter.updateOne(state, {\n            id: action.payload.id,\n            changes: mergedChanges,\n          });\n        } else {\n          // No existing article, use the payload as-is\n          articlesAdapter.updateOne(state, {\n            id: action.payload.id,\n            changes: action.payload,\n          });\n        }\n        \n        // Remove from pending changes after successful sync\n        state.sync.pendingChanges = state.sync.pendingChanges.filter(\n          id => id !== action.payload.id\n        );\n      })\n      .addCase(updateArticle.rejected, (state, action) => {\n        state.loading.update = false;\n        state.error.update = action.payload || 'Failed to update article';\n      })\n\n      // Update article locally with database persistence\n      .addCase(updateArticleLocalWithDB.pending, state => {\n        state.loading.update = true;\n        state.error.update = null;\n      })\n      .addCase(updateArticleLocalWithDB.fulfilled, (state, action) => {\n        state.loading.update = false;\n        state.error.update = null;\n        articlesAdapter.updateOne(state, {\n          id: action.payload.id,\n          changes: action.payload,\n        });\n        // Mark as having pending changes for sync\n        if (!state.sync.pendingChanges.includes(action.payload.id)) {\n          state.sync.pendingChanges.push(action.payload.id);\n        }\n      })\n      .addCase(updateArticleLocalWithDB.rejected, (state, action) => {\n        state.loading.update = false;\n        state.error.update = action.payload || 'Failed to update article locally';\n      })\n\n      // Delete article\n      .addCase(deleteArticle.pending, state => {\n        state.loading.delete = true;\n        state.error.delete = null;\n      })\n      .addCase(deleteArticle.fulfilled, (state, action) => {\n        state.loading.delete = false;\n        state.error.delete = null;\n        articlesAdapter.removeOne(state, action.payload);\n        state.pagination.totalItems = Math.max(\n          0,\n          state.pagination.totalItems - 1\n        );\n\n        // Clean up selection and sync state\n        state.selectedArticleIds = state.selectedArticleIds.filter(\n          id => id !== action.payload\n        );\n        state.sync.pendingChanges = state.sync.pendingChanges.filter(\n          id => id !== action.payload\n        );\n        state.sync.conflicts = state.sync.conflicts.filter(\n          id => id !== action.payload\n        );\n\n        if (state.selectedArticleId === action.payload) {\n          state.selectedArticleId = null;\n        }\n      })\n      .addCase(deleteArticle.rejected, (state, action) => {\n        state.loading.delete = false;\n        state.error.delete = action.payload || 'Failed to delete article';\n      })\n\n      // Sync articles\n      .addCase(syncArticles.pending, state => {\n        state.loading.sync = true;\n        state.sync.isSyncing = true;\n        state.sync.syncError = null;\n      })\n      .addCase(syncArticles.fulfilled, (state, action) => {\n        state.loading.sync = false;\n        state.sync.isSyncing = false;\n        state.sync.lastSyncTime = new Date().toISOString();\n        state.sync.syncError = null;\n\n        const { conflictCount } = action.payload;\n\n        // Clear pending changes for successfully synced articles\n        // This would be more sophisticated in a real implementation\n        if (conflictCount === 0) {\n          state.sync.pendingChanges = [];\n        }\n      })\n      .addCase(syncArticles.rejected, (state, action) => {\n        state.loading.sync = false;\n        state.sync.isSyncing = false;\n        state.sync.syncError = action.payload || 'Failed to sync articles';\n      });\n  },\n});\n\n// Export selectors created by entity adapter\nexport const {\n  selectAll: selectAllArticles,\n  selectById: selectArticleById,\n  selectIds: selectArticleIds,\n  selectEntities: selectArticleEntities,\n  selectTotal: selectTotalArticles,\n} = articlesAdapter.getSelectors((state: RootState) => state.articles);\n\n// Export action creators\nexport const {\n  clearError,\n  setFilters,\n  clearFilters,\n  setPage,\n  setPageSize,\n  setSelectedArticle,\n  toggleMultiSelectMode,\n  toggleArticleSelection,\n  clearSelection,\n  updateArticleLocal,\n  markSyncConflict,\n  resolveSyncConflict,\n  clearSyncError,\n  clearAll,\n} = articlesSlice.actions;\n\nexport default articlesSlice.reducer;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/store/slices/authSlice.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2539,2542],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2539,2542],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"consistent-return","severity":2,"message":"Expected to return a value at the end of async arrow function.","line":86,"column":44,"nodeType":"ArrowFunctionExpression","messageId":"missingReturn","endLine":86,"endColumn":46},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":91,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":91,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[2774,2845],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":109,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":109,"endColumn":23,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[3510,3588],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":114,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":114,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[3705,3781],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":132,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4352,4355],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4352,4355],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":163,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":163,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5637,5811],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":178,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":178,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[6123,6192],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":181,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":181,"endColumn":23,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[6232,6302],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":257,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":257,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[8499,8568],"text":""},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';\nimport { authStorageService } from '../../services/AuthStorageService';\nimport { errorHandler, ErrorCategory } from '../../utils/errorHandler';\nimport { logger } from '../../utils/logger';\nimport {\n  AuthState,\n  AuthCredentials,\n  LoginResponse,\n  AuthenticatedUser,\n} from '../../types/auth';\n\nconst initialState: AuthState = {\n  user: null,\n  token: null,\n  isAuthenticated: false,\n  loading: false,\n  error: null,\n  lastTokenRefresh: undefined,\n};\n\nexport const loginUser = createAsyncThunk<\n  { user: AuthenticatedUser; token: string },\n  AuthCredentials,\n  { rejectValue: string }\n>('auth/loginUser', async (credentials, { rejectWithValue }) => {\n  try {\n    logger.info('Login attempt initiated', { \n      serverUrl: credentials.serverUrl,\n      username: credentials.username,\n    });\n    const response = await fetch(`${credentials.serverUrl}/api/auth/login`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        username: credentials.username,\n        password: credentials.password,\n      }),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      throw new Error(errorData.message || `Login failed: ${response.status}`);\n    }\n\n    const loginResponse: LoginResponse = await response.json();\n\n    const user: AuthenticatedUser = {\n      id: loginResponse.user.id,\n      username: loginResponse.user.username,\n      email: loginResponse.user.email,\n      serverUrl: credentials.serverUrl,\n      lastLoginAt: new Date().toISOString(),\n      tokenExpiresAt: new Date(\n        Date.now() + loginResponse.expiresIn * 1000\n      ).toISOString(),\n    };\n\n    const tokenStored = await authStorageService.storeToken(\n      loginResponse.token\n    );\n    if (!tokenStored) {\n      logger.warn('Failed to store token securely');\n    }\n\n    logger.info('Login successful', { userId: user.id });\n    return { user, token: loginResponse.token };\n  } catch (error) {\n    const handledError = errorHandler.handleError(error, {\n      category: ErrorCategory.AUTHENTICATION,\n      context: { \n        actionType: 'login',\n        serverUrl: credentials.serverUrl,\n        username: credentials.username,\n      },\n    });\n    \n    logger.error('Login failed', { error: handledError });\n    return rejectWithValue(handledError.userMessage);\n  }\n});\n\nexport const logoutUser = createAsyncThunk<void, void, { rejectValue: string; dispatch: any }>(\n  'auth/logoutUser',\n  async (_, { rejectWithValue, dispatch }) => {\n    try {\n      // Clear auth token from secure storage\n      const tokenDeleted = await authStorageService.deleteToken();\n      if (!tokenDeleted) {\n        console.warn('[AuthSlice] Failed to delete token from secure storage');\n      }\n\n      // Clear all locally stored data\n      try {\n        // Import here to avoid circular dependencies\n        const { clearAll: clearAllArticles } = await import('./articlesSlice');\n        const { resetSyncState, resetSyncStats } = await import('./syncSlice');\n        const databaseService = (await import('../../services/DatabaseService')).default;\n        \n        // Clear Redux state\n        dispatch(clearAllArticles());\n        dispatch(resetSyncState());\n        dispatch(resetSyncStats());\n        \n        // Clear database data\n        const clearResult = await databaseService.clearAllData();\n        if (!clearResult.success) {\n          console.warn('[AuthSlice] Failed to clear database data:', clearResult.error);\n        }\n        \n        logger.info('User logged out - all local data cleared');\n      } catch (error) {\n        console.warn('[AuthSlice] Error clearing local data during logout:', error);\n        // Don't fail the logout if data cleanup fails\n      }\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : 'Logout failed';\n      return rejectWithValue(errorMessage);\n    }\n  }\n);\n\nexport const initializeAuth = createAsyncThunk<\n  { user: AuthenticatedUser; token: string } | null,\n  void,\n  { rejectValue: string }\n>('auth/initializeAuth', async (_, { rejectWithValue }) => {\n  try {\n    // Use the enhanced retrieveAuthData method to get both token and user data\n    const authData = await (authStorageService as any).retrieveAuthData();\n\n    if (authData && authData.token) {\n      const validation = await authStorageService.validateStoredToken();\n\n      if (validation.isValid && !validation.isExpired) {\n        // Restore user data from stored auth data\n        const user: AuthenticatedUser = authData.user ? {\n          id: authData.user.id,\n          username: authData.user.username,\n          email: authData.user.email,\n          serverUrl: authData.serverUrl,\n          lastLoginAt: authData.user.lastLoginAt,\n          tokenExpiresAt: authData.expiresAt,\n        } : {\n          // Fallback for legacy tokens without user data\n          id: 'readeck-user',\n          username: 'Readeck User',\n          email: 'user@readeck.local',\n          serverUrl: authData.serverUrl || '',\n          lastLoginAt: new Date().toISOString(),\n          tokenExpiresAt: authData.expiresAt,\n        };\n        \n        // Configure the ReadeckApiService with the restored server URL\n        if (user.serverUrl) {\n          try {\n            const { readeckApiService } = await import('../../services/ReadeckApiService');\n            const cleanUrl = user.serverUrl.trim().replace(/\\/$/, '');\n            const apiUrl = cleanUrl.includes('/api') ? cleanUrl : `${cleanUrl}/api`;\n            \n            console.log('[AuthSlice] Configuring API service on auth restore:', {\n              originalUrl: user.serverUrl,\n              cleanUrl,\n              apiUrl,\n            });\n            \n            readeckApiService.updateConfig({\n              baseUrl: apiUrl,\n            });\n            \n            logger.info('API service configured for restored session', { \n              serverUrl: user.serverUrl,\n              apiUrl,\n            });\n          } catch (error) {\n            console.error('[AuthSlice] Failed to configure API service:', error);\n          }\n        } else {\n          console.warn('[AuthSlice] No server URL found in restored auth data');\n        }\n        \n        logger.info('Auth initialized successfully', { userId: user.id, serverUrl: user.serverUrl });\n        return { user, token: authData.token };\n      } else {\n        logger.info('Stored token is invalid or expired, clearing auth data');\n        await authStorageService.deleteToken();\n        return null;\n      }\n    }\n\n    logger.debug('No stored auth data found');\n    return null;\n  } catch (error) {\n    const errorMessage =\n      error instanceof Error ? error.message : 'Auth initialization failed';\n    logger.error('Auth initialization failed', { error: errorMessage });\n    return rejectWithValue(errorMessage);\n  }\n});\n\n// Helper thunk to restore full auth state from storage\nexport const restoreAuthState = createAsyncThunk<\n  { user: AuthenticatedUser; token: string } | null,\n  void,\n  { rejectValue: string }\n>('auth/restoreAuthState', async (_, { rejectWithValue }) => {\n  try {\n    const token = await authStorageService.retrieveToken();\n    \n    if (!token) {\n      return null;\n    }\n    \n    // TODO: Properly restore user data including serverUrl from storage\n    // For now, we'll need to handle this in the app initialization\n    \n    return null;\n  } catch (error) {\n    const errorMessage =\n      error instanceof Error ? error.message : 'Auth restoration failed';\n    return rejectWithValue(errorMessage);\n  }\n});\n\nexport const refreshToken = createAsyncThunk<\n  { token: string },\n  string,\n  { rejectValue: string }\n>('auth/refreshToken', async (serverUrl, { rejectWithValue }) => {\n  try {\n    const currentToken = await authStorageService.retrieveToken();\n\n    if (!currentToken) {\n      throw new Error('No token available for refresh');\n    }\n\n    const response = await fetch(`${serverUrl}/api/auth/refresh`, {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${currentToken}`,\n        'Content-Type': 'application/json',\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(`Token refresh failed: ${response.status}`);\n    }\n\n    const refreshResponse = await response.json();\n\n    const tokenStored = await authStorageService.storeToken(\n      refreshResponse.token\n    );\n    if (!tokenStored) {\n      console.warn('[AuthSlice] Failed to store refreshed token securely');\n    }\n\n    return { token: refreshResponse.token };\n  } catch (error) {\n    const errorMessage =\n      error instanceof Error ? error.message : 'Token refresh failed';\n    return rejectWithValue(errorMessage);\n  }\n});\n\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    clearError: state => {\n      state.error = null;\n    },\n    setUser: (state, action: PayloadAction<AuthenticatedUser>) => {\n      state.user = action.payload;\n      state.isAuthenticated = true;\n    },\n    clearAuth: state => {\n      state.user = null;\n      state.token = null;\n      state.isAuthenticated = false;\n      state.error = null;\n      state.lastTokenRefresh = undefined;\n    },\n  },\n  extraReducers: builder => {\n    builder\n      .addCase(loginUser.pending, state => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(loginUser.fulfilled, (state, action) => {\n        state.loading = false;\n        state.user = action.payload.user;\n        state.token = action.payload.token;\n        state.isAuthenticated = true;\n        state.error = null;\n      })\n      .addCase(loginUser.rejected, (state, action) => {\n        state.loading = false;\n        state.user = null;\n        state.token = null;\n        state.isAuthenticated = false;\n        state.error = action.payload || 'Login failed';\n      })\n      .addCase(logoutUser.pending, state => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(logoutUser.fulfilled, state => {\n        state.loading = false;\n        state.user = null;\n        state.token = null;\n        state.isAuthenticated = false;\n        state.error = null;\n        state.lastTokenRefresh = undefined;\n      })\n      .addCase(logoutUser.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.payload || 'Logout failed';\n        state.user = null;\n        state.token = null;\n        state.isAuthenticated = false;\n        state.lastTokenRefresh = undefined;\n      })\n      .addCase(initializeAuth.pending, state => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(initializeAuth.fulfilled, (state, action) => {\n        state.loading = false;\n        if (action.payload) {\n          state.user = action.payload.user;\n          state.token = action.payload.token;\n          state.isAuthenticated = true;\n        } else {\n          state.isAuthenticated = false;\n        }\n      })\n      .addCase(initializeAuth.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.payload || 'Auth initialization failed';\n        state.isAuthenticated = false;\n      })\n      .addCase(refreshToken.pending, state => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(refreshToken.fulfilled, (state, action) => {\n        state.loading = false;\n        state.token = action.payload.token;\n        state.lastTokenRefresh = new Date().toISOString();\n        state.error = null;\n      })\n      .addCase(refreshToken.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.payload || 'Token refresh failed';\n        state.user = null;\n        state.token = null;\n        state.isAuthenticated = false;\n        state.lastTokenRefresh = undefined;\n      });\n  },\n});\n\nexport const { clearError, setUser, clearAuth } = authSlice.actions;\n\nexport default authSlice.reducer;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/store/slices/syncSlice.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'NetworkType' is defined but never used.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'state' is defined but never used. Allowed unused args must match /^_/u.","line":327,"column":50,"nodeType":null,"messageId":"unusedVar","endLine":327,"endColumn":55}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport {\n  SyncState,\n  SyncStatus,\n  SyncPhase,\n  NetworkType,\n  ConflictResolutionStrategy,\n  StartSyncPayload,\n  SyncProgressPayload,\n  SyncSuccessPayload,\n  SyncErrorPayload,\n  AddConflictPayload,\n  ResolveConflictPayload,\n  UpdateSyncConfigPayload,\n  NetworkStatusPayload,\n} from '../../types/sync';\n\nconst initialState: SyncState = {\n  // Sync status tracking\n  status: SyncStatus.IDLE,\n  lastSyncTime: null,\n\n  // Progress tracking\n  progress: {\n    phase: SyncPhase.INITIALIZING,\n    totalItems: 0,\n    processedItems: 0,\n    currentItem: null,\n    estimatedTimeRemaining: null,\n  },\n\n  // Network and connectivity\n  isOnline: true,\n  networkType: null,\n\n  // Configuration\n  config: {\n    backgroundSyncEnabled: true,\n    syncInterval: 15, // 15 minutes\n    syncOnWifiOnly: false,\n    syncOnCellular: true,\n    downloadImages: true,\n    fullTextSync: true,\n    conflictResolutionStrategy: ConflictResolutionStrategy.LAST_WRITE_WINS,\n    batchSize: 50,\n  },\n\n  // Conflict resolution\n  conflicts: [],\n\n  // Error handling\n  error: null,\n\n  // Statistics\n  stats: {\n    totalSyncs: 0,\n    successfulSyncs: 0,\n    failedSyncs: 0,\n    lastSyncDuration: null,\n    averageSyncDuration: null,\n    itemsSynced: {\n      articlesCreated: 0,\n      articlesUpdated: 0,\n      articlesDeleted: 0,\n      conflictsResolved: 0,\n    },\n    dataTransfer: {\n      bytesUploaded: 0,\n      bytesDownloaded: 0,\n      requestCount: 0,\n      cacheHits: 0,\n    },\n  },\n};\n\nconst syncSlice = createSlice({\n  name: 'sync',\n  initialState,\n  reducers: {\n    // Sync lifecycle actions\n    startSync: (state, action: PayloadAction<StartSyncPayload>) => {\n      state.status = SyncStatus.SYNCING;\n      state.error = null;\n      state.progress = {\n        phase: SyncPhase.INITIALIZING,\n        totalItems: 0,\n        processedItems: 0,\n        currentItem: null,\n        estimatedTimeRemaining: null,\n      };\n\n      // Apply any sync options\n      if (action.payload.syncOptions) {\n        state.config = { ...state.config, ...action.payload.syncOptions };\n      }\n\n      // Increment total sync count\n      state.stats.totalSyncs += 1;\n    },\n\n    syncProgress: (state, action: PayloadAction<SyncProgressPayload>) => {\n      if (state.status === SyncStatus.SYNCING) {\n        state.progress = {\n          ...state.progress,\n          ...action.payload,\n        };\n      }\n    },\n\n    syncSuccess: (state, action: PayloadAction<SyncSuccessPayload>) => {\n      state.status = SyncStatus.SUCCESS;\n      state.error = null;\n      state.lastSyncTime = action.payload.syncTime;\n\n      // Update statistics\n      state.stats.successfulSyncs += 1;\n      state.stats.lastSyncDuration = action.payload.syncDuration;\n\n      // Calculate average sync duration\n      const totalDuration =\n        (state.stats.averageSyncDuration || 0) *\n          (state.stats.successfulSyncs - 1) +\n        action.payload.syncDuration;\n      state.stats.averageSyncDuration =\n        totalDuration / state.stats.successfulSyncs;\n\n      // Reset progress\n      state.progress = {\n        phase: SyncPhase.FINALIZING,\n        totalItems: action.payload.itemsProcessed,\n        processedItems: action.payload.itemsProcessed,\n        currentItem: null,\n        estimatedTimeRemaining: 0,\n      };\n    },\n\n    syncError: (state, action: PayloadAction<SyncErrorPayload>) => {\n      state.status = SyncStatus.ERROR;\n      state.error = action.payload.error;\n      state.stats.failedSyncs += 1;\n\n      // Reset progress on error\n      state.progress = {\n        ...state.progress,\n        currentItem: null,\n        estimatedTimeRemaining: null,\n      };\n    },\n\n    pauseSync: state => {\n      if (state.status === SyncStatus.SYNCING) {\n        state.status = SyncStatus.PAUSED;\n      }\n    },\n\n    resumeSync: state => {\n      if (state.status === SyncStatus.PAUSED) {\n        state.status = SyncStatus.SYNCING;\n      }\n    },\n\n    // Conflict resolution actions\n    addConflict: (state, action: PayloadAction<AddConflictPayload>) => {\n      const conflictId = `${action.payload.articleId}_${Date.now()}`;\n      const conflict = {\n        id: conflictId,\n        articleId: action.payload.articleId,\n        type: action.payload.type,\n        localVersion: action.payload.localVersion,\n        remoteVersion: action.payload.remoteVersion,\n        createdAt: new Date().toISOString(),\n        resolvedAt: null,\n        resolution: null,\n      };\n\n      state.conflicts.push(conflict);\n    },\n\n    resolveConflict: (state, action: PayloadAction<ResolveConflictPayload>) => {\n      const conflictIndex = state.conflicts.findIndex(\n        conflict => conflict.id === action.payload.conflictId\n      );\n\n      if (conflictIndex !== -1) {\n        state.conflicts[conflictIndex] = {\n          ...state.conflicts[conflictIndex],\n          resolvedAt: new Date().toISOString(),\n          resolution: action.payload.resolution,\n        };\n\n        // Remove resolved conflict after a short delay (handled by middleware)\n        // For now, we'll remove it immediately\n        state.conflicts.splice(conflictIndex, 1);\n        state.stats.itemsSynced.conflictsResolved += 1;\n      }\n    },\n\n    clearConflicts: state => {\n      state.conflicts = [];\n    },\n\n    // Configuration actions\n    updateSyncConfig: (\n      state,\n      action: PayloadAction<UpdateSyncConfigPayload>\n    ) => {\n      state.config = { ...state.config, ...action.payload.config };\n    },\n\n    resetSyncConfig: state => {\n      state.config = initialState.config;\n    },\n\n    // Network status actions\n    updateNetworkStatus: (\n      state,\n      action: PayloadAction<NetworkStatusPayload>\n    ) => {\n      state.isOnline = action.payload.isOnline;\n      state.networkType = action.payload.networkType;\n\n      // Pause sync if offline\n      if (!action.payload.isOnline && state.status === SyncStatus.SYNCING) {\n        state.status = SyncStatus.PAUSED;\n      }\n    },\n\n    // State management actions\n    resetSyncState: state => {\n      return {\n        ...initialState,\n        // Preserve configuration and statistics across resets\n        config: state.config,\n        stats: state.stats,\n      };\n    },\n\n    clearSyncError: state => {\n      state.error = null;\n      if (state.status === SyncStatus.ERROR || state.status === SyncStatus.SUCCESS) {\n        state.status = SyncStatus.IDLE;\n      }\n    },\n\n    resetSyncStatus: state => {\n      state.status = SyncStatus.IDLE;\n      state.error = null;\n      state.progress = {\n        phase: SyncPhase.INITIALIZING,\n        totalItems: 0,\n        processedItems: 0,\n        currentItem: null,\n        estimatedTimeRemaining: null,\n      };\n    },\n\n    cancelSync: state => {\n      state.status = SyncStatus.IDLE;\n      state.error = null;\n      state.progress = {\n        phase: SyncPhase.INITIALIZING,\n        totalItems: 0,\n        processedItems: 0,\n        currentItem: null,\n        estimatedTimeRemaining: null,\n      };\n    },\n\n    // Statistics actions\n    updateSyncStats: (\n      state,\n      action: PayloadAction<{\n        articlesCreated?: number;\n        articlesUpdated?: number;\n        articlesDeleted?: number;\n        bytesUploaded?: number;\n        bytesDownloaded?: number;\n        requestCount?: number;\n        cacheHits?: number;\n      }>\n    ) => {\n      const { payload } = action;\n\n      if (payload.articlesCreated !== undefined) {\n        state.stats.itemsSynced.articlesCreated += payload.articlesCreated;\n      }\n      if (payload.articlesUpdated !== undefined) {\n        state.stats.itemsSynced.articlesUpdated += payload.articlesUpdated;\n      }\n      if (payload.articlesDeleted !== undefined) {\n        state.stats.itemsSynced.articlesDeleted += payload.articlesDeleted;\n      }\n      if (payload.bytesUploaded !== undefined) {\n        state.stats.dataTransfer.bytesUploaded += payload.bytesUploaded;\n      }\n      if (payload.bytesDownloaded !== undefined) {\n        state.stats.dataTransfer.bytesDownloaded += payload.bytesDownloaded;\n      }\n      if (payload.requestCount !== undefined) {\n        state.stats.dataTransfer.requestCount += payload.requestCount;\n      }\n      if (payload.cacheHits !== undefined) {\n        state.stats.dataTransfer.cacheHits += payload.cacheHits;\n      }\n    },\n\n    resetSyncStats: state => {\n      state.stats = initialState.stats;\n    },\n  },\n  extraReducers: (builder) => {\n    // Handle async thunk actions\n    builder\n      // Start sync operation\n      .addCase('sync/startOperation/pending', (state) => {\n        state.status = SyncStatus.SYNCING;\n        state.error = null;\n        state.progress = {\n          phase: SyncPhase.INITIALIZING,\n          totalItems: 0,\n          processedItems: 0,\n          currentItem: null,\n          estimatedTimeRemaining: null,\n        };\n        state.stats.totalSyncs += 1;\n      })\n      .addCase('sync/startOperation/fulfilled', (state) => {\n        // Success is handled by the sync service dispatching syncSuccess\n      })\n      .addCase('sync/startOperation/rejected', (state, action) => {\n        state.status = SyncStatus.ERROR;\n        state.error = action.error.message || 'Sync failed';\n        state.stats.failedSyncs += 1;\n      })\n      // Pause sync operation\n      .addCase('sync/pauseOperation/fulfilled', (state) => {\n        if (state.status === SyncStatus.SYNCING) {\n          state.status = SyncStatus.PAUSED;\n        }\n      })\n      // Resume sync operation\n      .addCase('sync/resumeOperation/pending', (state) => {\n        if (state.status === SyncStatus.PAUSED) {\n          state.status = SyncStatus.SYNCING;\n        }\n      })\n      .addCase('sync/resumeOperation/rejected', (state, action) => {\n        state.status = SyncStatus.ERROR;\n        state.error = action.error.message || 'Resume sync failed';\n      })\n      // Cancel sync operation\n      .addCase('sync/cancelOperation/fulfilled', (state) => {\n        state.status = SyncStatus.IDLE;\n        state.error = null;\n        state.progress = {\n          phase: SyncPhase.INITIALIZING,\n          totalItems: 0,\n          processedItems: 0,\n          currentItem: null,\n          estimatedTimeRemaining: null,\n        };\n      });\n  },\n});\n\n// Export action creators\nexport const {\n  startSync,\n  syncProgress,\n  syncSuccess,\n  syncError,\n  pauseSync,\n  resumeSync,\n  cancelSync,\n  addConflict,\n  resolveConflict,\n  clearConflicts,\n  updateSyncConfig,\n  resetSyncConfig,\n  updateNetworkStatus,\n  resetSyncState,\n  clearSyncError,\n  resetSyncStatus,\n  updateSyncStats,\n  resetSyncStats,\n} = syncSlice.actions;\n\nexport default syncSlice.reducer;\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/store/thunks/syncThunks.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'syncProgress' is defined but never used.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'syncSuccess' is defined but never used.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'syncError' is defined but never used.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SyncPhase' is defined but never used.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":19},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":44,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":74,"endColumn":6},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":45,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":45,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1101,1158],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":50,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":50,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1296,1361],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":59,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":59,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1633,1691],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1920,1923],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1920,1923],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":69,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":69,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1974,2040],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":88,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":124,"endColumn":6},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":89,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":89,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2391,2446],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":101,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":101,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2783,2881],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":116,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":116,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3280,3345],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":134,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":141,"endColumn":6},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":135,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":135,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3725,3769],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":155,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":176,"endColumn":6},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":156,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":156,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4143,4188],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":186,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":193,"endColumn":6},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":187,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":187,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4944,4991],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createAsyncThunk } from '@reduxjs/toolkit';\nimport NetInfo, { NetInfoState } from '@react-native-community/netinfo';\nimport { syncService } from '../../services/SyncService';\nimport { RootState } from '../index';\nimport {\n  syncProgress,\n  syncSuccess,\n  syncError,\n  updateNetworkStatus,\n} from '../slices/syncSlice';\nimport { fetchArticles } from '../slices/articlesSlice';\nimport { SyncPhase, NetworkType } from '../../types/sync';\n\ninterface StartSyncParams {\n  syncOptions?: {\n    fullTextSync?: boolean;\n    downloadImages?: boolean;\n  };\n  forceFull?: boolean;\n}\n\n/**\n * Get network type from NetInfo state\n */\nconst getNetworkType = (netInfoState: NetInfoState): NetworkType | null => {\n  if (!netInfoState.isConnected) return null;\n  \n  switch (netInfoState.type) {\n    case 'wifi':\n      return NetworkType.WIFI;\n    case 'cellular':\n      return NetworkType.CELLULAR;\n    default:\n      return NetworkType.UNKNOWN;\n  }\n};\n\n/**\n * Initialize sync service\n */\nexport const initializeSyncService = createAsyncThunk(\n  'sync/initialize',\n  async (_, { dispatch }) => {\n    try {\n      console.log('[SyncThunks] Initializing sync service...');\n      await syncService.initialize();\n      \n      // Get initial network status\n      const netInfoState = await NetInfo.fetch();\n      console.log('[SyncThunks] Initial network state:', netInfoState);\n      \n      dispatch(updateNetworkStatus({\n        isOnline: netInfoState.isConnected || false,\n        networkType: getNetworkType(netInfoState),\n      }));\n      \n      // Set up network monitoring\n      const unsubscribe = NetInfo.addEventListener(state => {\n        console.log('[SyncThunks] Network state changed:', state);\n        dispatch(updateNetworkStatus({\n          isOnline: state.isConnected || false,\n          networkType: getNetworkType(state),\n        }));\n      });\n      \n      // Store unsubscribe function for cleanup\n      (window as any).__netInfoUnsubscribe = unsubscribe;\n      \n      console.log('[SyncThunks] Sync service initialized successfully');\n      return true;\n    } catch (error) {\n      // Let the service layer handle error logging\n      throw error;\n    }\n  }\n);\n\n/**\n * Start sync operation\n */\nexport const startSyncOperation = createAsyncThunk<\n  void,\n  StartSyncParams,\n  { state: RootState }\n>(\n  'sync/startOperation',\n  async (params, { dispatch, getState }) => {\n    try {\n      console.log('[SyncThunks] Starting sync operation...');\n      \n      // Check if sync service is initialized\n      const state = getState();\n      if (!state.sync.isOnline) {\n        throw new Error('Cannot sync while offline');\n      }\n      \n      // Initialize sync service if not already initialized\n      try {\n        await syncService.initialize();\n      } catch (initError) {\n        console.log('[SyncThunks] Sync service already initialized or initialization failed:', initError);\n      }\n      \n      // Update sync configuration if options provided\n      if (params.syncOptions) {\n        syncService.updateConfig(params.syncOptions);\n      }\n      \n      // Start the actual sync\n      const result = await syncService.startFullSync(params.forceFull);\n      \n      if (!result.success) {\n        throw new Error(result.errors[0]?.error || 'Sync failed');\n      }\n      \n      console.log('[SyncThunks] Sync completed successfully:', result);\n      \n      // Refresh articles list after successful sync\n      dispatch(fetchArticles({ page: 1, forceRefresh: true }));\n      \n    } catch (error) {\n      // Let the service layer handle error logging\n      throw error;\n    }\n  }\n);\n\n/**\n * Pause sync operation\n */\nexport const pauseSyncOperation = createAsyncThunk(\n  'sync/pauseOperation',\n  async () => {\n    try {\n      console.log('[SyncThunks] Pausing sync...');\n      await syncService.stopSync();\n      return true;\n    } catch (error) {\n      // Let the service layer handle error logging\n      throw error;\n    }\n  }\n);\n\n/**\n * Resume sync operation\n */\nexport const resumeSyncOperation = createAsyncThunk<\n  void,\n  void,\n  { state: RootState }\n>(\n  'sync/resumeOperation',\n  async (_, { dispatch, getState }) => {\n    try {\n      console.log('[SyncThunks] Resuming sync...');\n      \n      const state = getState();\n      if (!state.sync.isOnline) {\n        throw new Error('Cannot resume sync while offline');\n      }\n      \n      // Restart sync from where it left off\n      const result = await syncService.startFullSync(false);\n      \n      if (!result.success) {\n        throw new Error(result.errors[0]?.error || 'Resume sync failed');\n      }\n      \n      // Refresh articles list after successful sync\n      dispatch(fetchArticles({ page: 1, forceRefresh: true }));\n      \n    } catch (error) {\n      // Let the service layer handle error logging\n      throw error;\n    }\n  }\n);\n\n/**\n * Cancel sync operation\n */\nexport const cancelSyncOperation = createAsyncThunk(\n  'sync/cancelOperation',\n  async () => {\n    try {\n      console.log('[SyncThunks] Cancelling sync...');\n      await syncService.stopSync();\n      return true;\n    } catch (error) {\n      // Let the service layer handle error logging\n      throw error;\n    }\n  }\n);","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/types/articles.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2653,2656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2653,2656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":212,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":212,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4812,4815],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4812,4815],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":245,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":245,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5578,5581],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5578,5581],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":260,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":260,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5859,5862],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5859,5862],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Articles API type definitions\n * Comprehensive typing for article operations and state management\n */\n\nimport { Article, PaginatedResponse } from './index';\n\n// API Service interfaces\nexport interface IArticlesApiService {\n  fetchArticles(\n    params: FetchArticlesParams\n  ): Promise<PaginatedResponse<Article>>;\n  createArticle(params: CreateArticleParams): Promise<Article>;\n  updateArticle(params: UpdateArticleParams): Promise<Article>;\n  deleteArticle(params: DeleteArticleParams): Promise<void>;\n  syncArticles(params: SyncArticlesParams): Promise<ArticleSyncResult>;\n  getArticle(id: string): Promise<Article>;\n  getArticleContent(contentUrl: string): Promise<string>;\n  batchUpdateArticles(updates: BatchUpdateParams[]): Promise<Article[]>;\n  batchDeleteArticles(ids: string[]): Promise<void>;\n  getArticleStats(): Promise<ArticleStats>;\n}\n\n// Request parameters for article operations\nexport interface FetchArticlesParams {\n  page?: number;\n  limit?: number;\n  searchQuery?: string;\n  filters?: ArticleFilterOptions;\n  forceRefresh?: boolean;\n}\n\nexport interface CreateArticleParams {\n  title: string;\n  url: string;\n  summary?: string;\n  content?: string;\n  tags?: string[];\n}\n\nexport interface UpdateArticleParams {\n  id: string;\n  updates: Partial<Omit<Article, 'id' | 'createdAt' | 'updatedAt'>>;\n}\n\nexport interface DeleteArticleParams {\n  id: string;\n  permanent?: boolean;\n}\n\nexport interface SyncArticlesParams {\n  fullSync?: boolean;\n  articlesOnly?: boolean;\n}\n\nexport interface BatchUpdateParams {\n  id: string;\n  updates: Partial<Article>;\n}\n\n// Filter and search options\nexport interface ArticleFilterOptions {\n  isArchived?: boolean;\n  isFavorite?: boolean;\n  isRead?: boolean;\n  tags?: string[];\n  dateRange?: {\n    from?: string;\n    to?: string;\n  };\n  readTimeRange?: {\n    min?: number;\n    max?: number;\n  };\n}\n\nexport interface ArticleSearchOptions {\n  query: string;\n  searchFields?: ('title' | 'summary' | 'content' | 'tags')[];\n  matchMode?: 'exact' | 'partial' | 'fuzzy';\n  caseSensitive?: boolean;\n}\n\n// Response types\nexport interface ArticleSyncResult {\n  syncedCount: number;\n  conflictCount: number;\n  lastSyncTime?: string;\n  errors?: ArticleSyncError[];\n}\n\nexport interface ArticleStats {\n  total: number;\n  read: number;\n  favorite: number;\n  archived: number;\n  unread: number;\n  recentlyAdded: number;\n  averageReadTime?: number;\n  topTags?: TagStat[];\n}\n\nexport interface TagStat {\n  tag: string;\n  count: number;\n}\n\n// Error types specific to article operations\nexport interface ArticleApiError {\n  code: ArticleErrorCode;\n  message: string;\n  articleId?: string;\n  statusCode?: number;\n  details?: any;\n  retryable: boolean;\n  timestamp: string;\n}\n\nexport enum ArticleErrorCode {\n  ARTICLE_NOT_FOUND = 'ARTICLE_NOT_FOUND',\n  INVALID_URL = 'INVALID_URL',\n  FETCH_FAILED = 'FETCH_FAILED',\n  DUPLICATE_ARTICLE = 'DUPLICATE_ARTICLE',\n  INVALID_UPDATE = 'INVALID_UPDATE',\n  DELETE_FAILED = 'DELETE_FAILED',\n  SYNC_CONFLICT = 'SYNC_CONFLICT',\n  OFFLINE_ERROR = 'OFFLINE_ERROR',\n  QUOTA_EXCEEDED = 'QUOTA_EXCEEDED',\n  UNKNOWN_ARTICLE_ERROR = 'UNKNOWN_ARTICLE_ERROR',\n}\n\nexport interface ArticleSyncError {\n  articleId: string;\n  error: ArticleApiError;\n  conflictData?: {\n    local: Partial<Article>;\n    remote: Partial<Article>;\n  };\n}\n\n// Optimistic update types\nexport interface OptimisticUpdate {\n  id: string;\n  type: 'create' | 'update' | 'delete';\n  timestamp: string;\n  originalData?: Article;\n  pendingData?: Partial<Article>;\n  status: 'pending' | 'success' | 'failed';\n  error?: ArticleApiError;\n}\n\n// Bulk operations\nexport interface BulkOperationRequest {\n  operation:\n    | 'archive'\n    | 'unarchive'\n    | 'favorite'\n    | 'unfavorite'\n    | 'read'\n    | 'unread'\n    | 'delete';\n  articleIds: string[];\n  options?: {\n    permanent?: boolean; // for delete operation\n    tags?: string[]; // for tagging operations\n  };\n}\n\nexport interface BulkOperationResult {\n  successful: string[];\n  failed: Array<{\n    articleId: string;\n    error: ArticleApiError;\n  }>;\n  totalProcessed: number;\n}\n\n// Content extraction and processing\nexport interface ArticleContentMetadata {\n  wordCount: number;\n  readingTime: number;\n  language?: string;\n  primaryImage?: string;\n  excerpt?: string;\n  publishedDate?: string;\n  author?: string;\n  siteName?: string;\n}\n\nexport interface ContentExtractionResult {\n  title: string;\n  content: string;\n  summary: string;\n  metadata: ArticleContentMetadata;\n  success: boolean;\n  error?: string;\n}\n\n// Cache and offline types\nexport interface ArticleCacheEntry {\n  article: Article;\n  cachedAt: string;\n  expiresAt?: string;\n  accessCount: number;\n  lastAccessed: string;\n  priority: 'high' | 'normal' | 'low';\n}\n\nexport interface OfflineQueueItem {\n  id: string;\n  type: 'create' | 'update' | 'delete' | 'sync';\n  payload: any;\n  timestamp: string;\n  retryCount: number;\n  maxRetries: number;\n  nextRetryAt?: string;\n  status: 'pending' | 'processing' | 'failed' | 'completed';\n  error?: ArticleApiError;\n}\n\n// Export and import types\nexport interface ArticleExportOptions {\n  format: 'json' | 'csv' | 'html' | 'epub' | 'pdf';\n  includeContent: boolean;\n  includeMetadata: boolean;\n  filters?: ArticleFilterOptions;\n  dateRange?: {\n    from: string;\n    to: string;\n  };\n}\n\nexport interface ArticleExportResult {\n  success: boolean;\n  filePath?: string;\n  downloadUrl?: string;\n  fileSize?: number;\n  articleCount: number;\n  error?: string;\n}\n\nexport interface ArticleImportOptions {\n  source: 'json' | 'csv' | 'opml' | 'bookmarks' | 'pocket' | 'instapaper';\n  filePath?: string;\n  data?: any;\n  options?: {\n    skipDuplicates?: boolean;\n    autoTag?: string[];\n    markAsRead?: boolean;\n    importContent?: boolean;\n  };\n}\n\nexport interface ArticleImportResult {\n  success: boolean;\n  imported: number;\n  skipped: number;\n  failed: number;\n  errors?: Array<{\n    item: any;\n    error: string;\n  }>;\n}\n\n// Validation types\nexport interface ArticleValidationRules {\n  title: {\n    required: boolean;\n    minLength?: number;\n    maxLength?: number;\n  };\n  url: {\n    required: boolean;\n    validProtocols?: string[];\n    allowedDomains?: string[];\n    blockedDomains?: string[];\n  };\n  tags: {\n    maxCount?: number;\n    maxLength?: number;\n    allowedCharacters?: RegExp;\n  };\n  content: {\n    maxLength?: number;\n  };\n}\n\nexport interface ArticleValidationResult {\n  valid: boolean;\n  errors: Array<{\n    field: keyof Article;\n    message: string;\n    code: string;\n  }>;\n  warnings?: Array<{\n    field: keyof Article;\n    message: string;\n    code: string;\n  }>;\n}\n\n// Service configuration\nexport interface ArticlesServiceConfig {\n  maxConcurrentRequests: number;\n  requestTimeout: number;\n  retryAttempts: number;\n  retryDelay: number;\n  cacheSize: number;\n  cacheTTL: number;\n  offlineQueueSize: number;\n  syncInterval: number;\n  contentExtractionTimeout: number;\n  batchSize: number;\n}\n\n// Hooks and component types for React integration\nexport interface UseArticlesOptions {\n  page?: number;\n  limit?: number;\n  filters?: ArticleFilterOptions;\n  search?: ArticleSearchOptions;\n  autoRefresh?: boolean;\n  refreshInterval?: number;\n}\n\nexport interface UseArticlesResult {\n  articles: Article[];\n  loading: boolean;\n  error: string | null;\n  pagination: {\n    page: number;\n    totalPages: number;\n    totalItems: number;\n    hasMore: boolean;\n  };\n  refetch: () => Promise<void>;\n  loadMore: () => Promise<void>;\n  refresh: () => Promise<void>;\n}\n\nexport interface UseArticleResult {\n  article: Article | null;\n  loading: boolean;\n  error: string | null;\n  refetch: () => Promise<void>;\n  update: (updates: Partial<Article>) => Promise<void>;\n  delete: () => Promise<void>;\n}\n\n// Advanced search and filtering\nexport interface ArticleSearchFilters extends ArticleFilterOptions {\n  search?: ArticleSearchOptions;\n  sortBy?: 'createdAt' | 'updatedAt' | 'title' | 'readTime' | 'relevance';\n  sortOrder?: 'asc' | 'desc';\n  groupBy?: 'none' | 'tags' | 'date' | 'readStatus' | 'source';\n}\n\nexport interface SearchResultGroup {\n  key: string;\n  label: string;\n  articles: Article[];\n  count: number;\n}\n\nexport interface GroupedSearchResult {\n  groups: SearchResultGroup[];\n  totalCount: number;\n  searchQuery: string;\n  appliedFilters: ArticleSearchFilters;\n  executionTime: number;\n}\n\n// Analytics and metrics\nexport interface ArticleMetrics {\n  readingSpeed: number; // words per minute\n  completionRate: number; // percentage of articles read to completion\n  favoriteRate: number; // percentage of articles marked as favorite\n  archiveRate: number; // percentage of articles archived\n  averageSessionTime: number; // minutes spent reading\n  topReadingTimes: string[]; // preferred reading hours\n  deviceUsage: {\n    mobile: number;\n    tablet: number;\n    desktop: number;\n  };\n}\n\nexport interface ReadingSession {\n  articleId: string;\n  startTime: string;\n  endTime?: string;\n  duration?: number;\n  progress: number; // percentage read (0-100)\n  scrollPosition: number;\n  device: 'mobile' | 'tablet' | 'desktop';\n  completed: boolean;\n}\n\n// Real-time updates and websocket types\nexport interface ArticleUpdateEvent {\n  type: 'created' | 'updated' | 'deleted' | 'archived' | 'favorited';\n  articleId: string;\n  article?: Article;\n  changes?: Partial<Article>;\n  timestamp: string;\n  userId: string;\n}\n\nexport interface SyncStatusEvent {\n  type: 'sync_started' | 'sync_progress' | 'sync_completed' | 'sync_failed';\n  progress?: number;\n  totalItems?: number;\n  currentItem?: number;\n  error?: ArticleApiError;\n  timestamp: string;\n}\n\n// Type guards and utility types\nexport type ArticleField = keyof Article;\nexport type RequiredArticleFields =\n  | 'id'\n  | 'title'\n  | 'url'\n  | 'createdAt'\n  | 'updatedAt';\nexport type OptionalArticleFields = Exclude<\n  ArticleField,\n  RequiredArticleFields\n>;\n\nexport interface CreateArticleDTO extends Pick<Article, 'title' | 'url'> {\n  summary?: string;\n  content?: string;\n  tags?: string[];\n  isFavorite?: boolean;\n}\n\nexport interface UpdateArticleDTO\n  extends Partial<Omit<Article, RequiredArticleFields>> {}\n\n// Re-export commonly used types from main types file\nexport type { Article, PaginatedResponse, ApiResponse } from './index';\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/types/auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/types/database.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":64,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1952,1955],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1952,1955],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2255,2258],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2255,2258],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2504,2507],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2504,2507],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2524,2527],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2524,2527],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":119,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3267,3270],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3267,3270],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":149,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3917,3920],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3917,3920],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":184,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4818,4821],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4818,4821],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":186,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4852,4855],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4852,4855],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Database Type Definitions for Mobdeck SQLite Operations\n * Provides comprehensive TypeScript interfaces for all database entities and operations\n */\n\n// Raw database row interfaces (matching SQLite schema exactly)\nexport interface DBArticle {\n  id: string;\n  title: string;\n  summary: string | null;\n  content: string | null;\n  url: string;\n  image_url: string | null;\n  read_time: number | null;\n  is_archived: number; // SQLite boolean as integer\n  is_favorite: number; // SQLite boolean as integer\n  is_read: number; // SQLite boolean as integer\n  source_url: string | null;\n  created_at: number; // Unix timestamp\n  updated_at: number; // Unix timestamp\n  synced_at: number | null; // Unix timestamp\n  is_modified: number; // SQLite boolean as integer\n  deleted_at: number | null; // Unix timestamp for soft deletes\n}\n\nexport interface DBLabel {\n  id: number;\n  name: string;\n  color: string | null;\n  created_at: number; // Unix timestamp\n  updated_at: number; // Unix timestamp\n  synced_at: number | null; // Unix timestamp\n}\n\nexport interface DBArticleLabel {\n  article_id: string;\n  label_id: number;\n  created_at: number; // Unix timestamp\n}\n\nexport interface DBSyncMetadata {\n  id: number;\n  entity_type: string; // 'article', 'label', etc.\n  entity_id: string;\n  operation: string; // 'create', 'update', 'delete'\n  local_timestamp: number; // Unix timestamp\n  server_timestamp: number | null; // Unix timestamp\n  sync_status: string; // 'pending', 'syncing', 'completed', 'failed'\n  conflict_resolution: string | null; // 'local_wins', 'server_wins', 'merged'\n  retry_count: number;\n  error_message: string | null;\n  created_at: number; // Unix timestamp\n  updated_at: number; // Unix timestamp\n}\n\nexport interface DBSchemaVersion {\n  version: number;\n  applied_at: number; // Unix timestamp\n  description: string | null;\n}\n\n// Database operation interfaces\nexport interface DatabaseConnection {\n  executeSql: (sql: string, params?: any[]) => Promise<DatabaseResult>;\n  transaction: (fn: (tx: DatabaseTransaction) => void) => Promise<void>;\n  readTransaction: (fn: (tx: DatabaseTransaction) => void) => Promise<void>;\n  close: () => Promise<void>;\n}\n\nexport interface DatabaseTransaction {\n  executeSql: (\n    sql: string,\n    params?: any[],\n    success?: (tx: DatabaseTransaction, result: DatabaseResult) => void,\n    error?: (tx: DatabaseTransaction, error: Error) => void\n  ) => void;\n}\n\nexport interface DatabaseResult {\n  rows: {\n    length: number;\n    item: (index: number) => any;\n    raw: () => any[];\n  };\n  rowsAffected: number;\n  insertId?: number;\n}\n\n// Query filter interfaces\nexport interface ArticleFilters {\n  isArchived?: boolean;\n  isFavorite?: boolean;\n  isRead?: boolean;\n  labelIds?: number[];\n  searchQuery?: string;\n  limit?: number;\n  offset?: number;\n  sortBy?: 'created_at' | 'updated_at' | 'title';\n  sortOrder?: 'ASC' | 'DESC';\n}\n\nexport interface LabelFilters {\n  searchQuery?: string;\n  limit?: number;\n  offset?: number;\n  sortBy?: 'name' | 'created_at';\n  sortOrder?: 'ASC' | 'DESC';\n}\n\nexport interface SyncMetadataFilters {\n  entityType?: string;\n  syncStatus?: string;\n  operation?: string;\n  limit?: number;\n  offset?: number;\n}\n\n// Database operation result types\nexport interface DatabaseOperationResult<T = any> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  rowsAffected?: number;\n  insertId?: number;\n}\n\nexport interface PaginatedResult<T> {\n  items: T[];\n  totalCount: number;\n  hasMore: boolean;\n  limit: number;\n  offset: number;\n}\n\n// Database statistics and health\nexport interface DatabaseStats {\n  totalArticles: number;\n  archivedArticles: number;\n  favoriteArticles: number;\n  unreadArticles: number;\n  totalLabels: number;\n  pendingSyncItems: number;\n  databaseSize: number; // in bytes\n  lastSyncAt: number | null;\n}\n\n// Transaction context for batch operations\nexport interface TransactionContext {\n  executeSql: (sql: string, params?: any[]) => Promise<DatabaseResult>;\n  rollback: () => void;\n}\n\n// Database migration interface\nexport interface Migration {\n  version: number;\n  description: string;\n  up: (tx: DatabaseTransaction) => Promise<void>;\n  down?: (tx: DatabaseTransaction) => Promise<void>;\n}\n\n// Database configuration\nexport interface DatabaseConfig {\n  name: string;\n  version: string;\n  displayName: string;\n  size: number;\n  location?: string;\n}\n\n// Error types for database operations\nexport enum DatabaseErrorCode {\n  CONNECTION_FAILED = 'CONNECTION_FAILED',\n  QUERY_FAILED = 'QUERY_FAILED',\n  TRANSACTION_FAILED = 'TRANSACTION_FAILED',\n  MIGRATION_FAILED = 'MIGRATION_FAILED',\n  CONSTRAINT_VIOLATION = 'CONSTRAINT_VIOLATION',\n  NOT_FOUND = 'NOT_FOUND',\n  DUPLICATE_ENTRY = 'DUPLICATE_ENTRY',\n  UNKNOWN_ERROR = 'UNKNOWN_ERROR',\n}\n\nexport interface DatabaseError extends Error {\n  code: DatabaseErrorCode;\n  details?: any;\n  query?: string;\n  params?: any[];\n}\n\n// Service method interfaces for type safety\nexport interface DatabaseServiceInterface {\n  // Connection management\n  initialize(): Promise<void>;\n  close(): Promise<void>;\n  isConnected(): boolean;\n\n  // Transaction management\n  executeInTransaction<T>(\n    operation: (ctx: TransactionContext) => Promise<T>\n  ): Promise<T>;\n\n  // Article operations\n  createArticle(\n    article: Omit<DBArticle, 'created_at' | 'updated_at'>\n  ): Promise<DatabaseOperationResult<string>>;\n  getArticle(id: string): Promise<DatabaseOperationResult<DBArticle>>;\n  updateArticle(\n    id: string,\n    updates: Partial<DBArticle>\n  ): Promise<DatabaseOperationResult>;\n  deleteArticle(\n    id: string,\n    softDelete?: boolean\n  ): Promise<DatabaseOperationResult>;\n  getArticles(\n    filters?: ArticleFilters\n  ): Promise<DatabaseOperationResult<PaginatedResult<DBArticle>>>;\n  searchArticles(\n    query: string,\n    filters?: ArticleFilters\n  ): Promise<DatabaseOperationResult<PaginatedResult<DBArticle>>>;\n\n  // Label operations\n  createLabel(\n    label: Omit<DBLabel, 'id' | 'created_at' | 'updated_at'>\n  ): Promise<DatabaseOperationResult<number>>;\n  getLabel(id: number): Promise<DatabaseOperationResult<DBLabel>>;\n  updateLabel(\n    id: number,\n    updates: Partial<DBLabel>\n  ): Promise<DatabaseOperationResult>;\n  deleteLabel(id: number): Promise<DatabaseOperationResult>;\n  getLabels(\n    filters?: LabelFilters\n  ): Promise<DatabaseOperationResult<PaginatedResult<DBLabel>>>;\n\n  // Article-Label relationship operations\n  addLabelToArticle(\n    articleId: string,\n    labelId: number\n  ): Promise<DatabaseOperationResult>;\n  removeLabelFromArticle(\n    articleId: string,\n    labelId: number\n  ): Promise<DatabaseOperationResult>;\n  getArticleLabels(\n    articleId: string\n  ): Promise<DatabaseOperationResult<DBLabel[]>>;\n  getLabelArticles(\n    labelId: number\n  ): Promise<DatabaseOperationResult<DBArticle[]>>;\n\n  // Sync metadata operations\n  createSyncMetadata(\n    metadata: Omit<DBSyncMetadata, 'id' | 'created_at' | 'updated_at'>\n  ): Promise<DatabaseOperationResult<number>>;\n  updateSyncMetadata(\n    id: number,\n    updates: Partial<DBSyncMetadata>\n  ): Promise<DatabaseOperationResult>;\n  getSyncMetadata(\n    filters?: SyncMetadataFilters\n  ): Promise<DatabaseOperationResult<PaginatedResult<DBSyncMetadata>>>;\n  deleteSyncMetadata(id: number): Promise<DatabaseOperationResult>;\n\n  // Utility operations\n  getStats(): Promise<DatabaseOperationResult<DatabaseStats>>;\n  vacuum(): Promise<DatabaseOperationResult>;\n  backup(path: string): Promise<DatabaseOperationResult>;\n\n  // Migration operations\n  getCurrentVersion(): Promise<number>;\n  runMigrations(migrations: Migration[]): Promise<DatabaseOperationResult>;\n}\n\n// Helper type for converting SQLite boolean integers to JavaScript booleans\nexport type BooleanFields<T> = {\n  [K in keyof T]: T[K] extends number\n    ? K extends 'is_archived' | 'is_favorite' | 'is_read' | 'is_modified'\n      ? boolean\n      : T[K]\n    : T[K];\n};\n\n// Converted article type with proper boolean fields\nexport type Article = BooleanFields<DBArticle> & {\n  createdAt: Date;\n  updatedAt: Date;\n  syncedAt?: Date;\n  deletedAt?: Date;\n};\n\n// Converted label type\nexport type Label = DBLabel & {\n  createdAt: Date;\n  updatedAt: Date;\n  syncedAt?: Date;\n};\n\n// Helper functions type definitions\nexport interface DatabaseUtils {\n  convertDBArticleToArticle(dbArticle: DBArticle): Article;\n  convertArticleToDBArticle(article: Article): DBArticle;\n  convertDBLabelToLabel(dbLabel: DBLabel): Label;\n  convertLabelToDBLabel(label: Label): DBLabel;\n  createTimestamp(): number;\n  formatTimestamp(timestamp: number): Date;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/types/index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":162,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":162,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3174,3177],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3174,3177],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// API Response Types\nexport interface ApiResponse<T> {\n  data: T;\n  message?: string;\n  error?: string;\n}\n\nexport interface PaginatedResponse<T> {\n  items: T[];\n  page: number;\n  totalPages: number;\n  totalItems: number;\n}\n\n// Entity Types\nexport interface Article {\n  id: string;\n  title: string;\n  summary: string;\n  content: string;\n  url: string;\n  imageUrl?: string;\n  readTime?: number;\n  isArchived: boolean;\n  isFavorite: boolean;\n  isRead: boolean;\n  tags?: string[];\n  sourceUrl?: string;\n  createdAt: string;\n  updatedAt: string;\n  syncedAt?: string;\n  contentUrl?: string; // URL to fetch full article content\n  isModified?: boolean; // Flag to track local modifications for sync\n}\n\nexport interface User {\n  id: string;\n  username: string;\n  email: string;\n  serverUrl: string;\n}\n\nexport interface AuthCredentials {\n  serverUrl: string;\n  username: string;\n  password: string;\n}\n\nexport interface AuthToken {\n  token: string;\n  expiresAt: string;\n}\n\n// Redux State Types\nexport interface ArticlesState {\n  articles: Article[];\n  loading: boolean;\n  error: string | null;\n  lastSync: string | null;\n  searchQuery: string;\n  filters: {\n    isArchived?: boolean;\n    isFavorite?: boolean;\n    isRead?: boolean;\n    tags?: string[];\n  };\n}\n\nexport interface AuthState {\n  user: User | null;\n  token: string | null;\n  isAuthenticated: boolean;\n  loading: boolean;\n  error: string | null;\n}\n\nexport interface SyncState {\n  isSyncing: boolean;\n  lastSyncTime: string | null;\n  syncError: string | null;\n  pendingChanges: number;\n}\n\nexport interface SettingsState {\n  theme: 'light' | 'dark' | 'system';\n  syncInterval: number; // in minutes\n  syncOnWifiOnly: boolean;\n  offlineMode: boolean;\n  articleCacheSize: number;\n  fontSize: 'small' | 'medium' | 'large';\n  fontFamily: string;\n}\n\nexport interface RootState {\n  articles: ArticlesState;\n  auth: AuthState;\n  sync: SyncState;\n  settings: SettingsState;\n}\n\n// Component Props Types\nexport interface SearchProps {\n  value: string;\n  placeholder?: string;\n  onSearch: (query: string) => void;\n  onChange: (query: string) => void;\n  onClear?: () => void;\n}\n\nexport interface ArticleCardProps {\n  article: Article;\n  onPress: () => void;\n  onLongPress?: () => void;\n  onToggleFavorite?: () => void;\n  onToggleArchive?: () => void;\n}\n\n// Navigation Types\nexport type RootStackParamList = {\n  Auth: undefined;\n  Home: undefined;\n  Article: { articleId: string };\n  Settings: undefined;\n  Search: { query?: string };\n};\n\nexport type TabParamList = {\n  Articles: undefined;\n  Favorites: undefined;\n  Archive: undefined;\n  Settings: undefined;\n};\n\n// Service Types\nexport interface SyncOptions {\n  fullSync?: boolean;\n  articlesOnly?: boolean;\n  force?: boolean;\n}\n\nexport interface DatabaseArticle\n  extends Omit<Article, 'createdAt' | 'updatedAt' | 'syncedAt'> {\n  created_at: number;\n  updated_at: number;\n  synced_at?: number;\n}\n\n// Enhanced database types (re-export from database module)\nexport type {\n  DBArticle,\n  DBLabel,\n  DBArticleLabel,\n  DBSyncMetadata,\n  ArticleFilters,\n  DatabaseStats,\n} from '../database/types';\n\n// Error Types\nexport interface AppError {\n  code: string;\n  message: string;\n  details?: any;\n}\n\nexport enum ErrorCode {\n  NETWORK_ERROR = 'NETWORK_ERROR',\n  AUTH_ERROR = 'AUTH_ERROR',\n  SYNC_ERROR = 'SYNC_ERROR',\n  DATABASE_ERROR = 'DATABASE_ERROR',\n  VALIDATION_ERROR = 'VALIDATION_ERROR',\n}\n\n// Utility Types\nexport type DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\nexport type AsyncAction<T> = {\n  pending: boolean;\n  error: string | null;\n  data: T | null;\n};\n\n// Share Intent Types\nexport interface SharedData {\n  text: string;\n  subject?: string;\n  timestamp: number;\n}\n\nexport interface ShareModuleInterface {\n  getSharedData(): Promise<SharedData | null>;\n  clearSharedData(): Promise<boolean>;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/types/labels.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4042,4045],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4042,4045],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":289,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":289,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6417,6420],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6417,6420],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":305,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":305,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6746,6749],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6746,6749],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Labels API type definitions\n * Comprehensive typing for Readeck labels/tags management operations\n */\n\nimport { PaginatedResponse } from './index';\n\n// Core label entity types\nexport interface Label {\n  id: string;\n  name: string;\n  color?: string;\n  description?: string;\n  articleCount: number;\n  createdAt: string;\n  updatedAt: string;\n}\n\n// Readeck API label types (snake_case from server)\nexport interface ReadeckLabel {\n  id: string;\n  name: string;\n  color?: string;\n  description?: string;\n  article_count: number;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface ReadeckLabelList {\n  labels: ReadeckLabel[];\n  pagination: {\n    page: number;\n    per_page: number;\n    total_pages: number;\n    total_count: number;\n  };\n}\n\n// Label operations request types\nexport interface CreateLabelRequest {\n  name: string;\n  color?: string;\n  description?: string;\n}\n\nexport interface UpdateLabelRequest {\n  name?: string;\n  color?: string;\n  description?: string;\n}\n\nexport interface LabelFilters {\n  page?: number;\n  per_page?: number;\n  search?: string;\n  sort_by?: 'name' | 'created_at' | 'updated_at' | 'article_count';\n  sort_order?: 'asc' | 'desc';\n  include_empty?: boolean; // Include labels with no articles\n}\n\n// Label assignment operations\nexport interface AssignLabelRequest {\n  article_id: string;\n  label_id: string;\n}\n\nexport interface RemoveLabelRequest {\n  article_id: string;\n  label_id: string;\n}\n\nexport interface BatchLabelAssignmentRequest {\n  article_ids: string[];\n  label_ids: string[];\n  operation: 'assign' | 'remove';\n}\n\nexport interface BatchLabelAssignmentResult {\n  successful: Array<{\n    article_id: string;\n    label_id: string;\n  }>;\n  failed: Array<{\n    article_id: string;\n    label_id: string;\n    error: LabelApiError;\n  }>;\n  totalProcessed: number;\n}\n\n// API Service interface\nexport interface ILabelsApiService {\n  fetchLabels(params: FetchLabelsParams): Promise<PaginatedResponse<Label>>;\n  createLabel(params: CreateLabelParams): Promise<Label>;\n  updateLabel(params: UpdateLabelParams): Promise<Label>;\n  deleteLabel(params: DeleteLabelParams): Promise<void>;\n  assignToArticle(params: AssignLabelToArticleParams): Promise<void>;\n  removeFromArticle(params: RemoveLabelFromArticleParams): Promise<void>;\n  getLabel(id: string): Promise<Label>;\n  batchAssignLabels(\n    params: BatchAssignLabelsParams\n  ): Promise<BatchLabelAssignmentResult>;\n  getLabelStats(): Promise<LabelStats>;\n}\n\n// Service operation parameters\nexport interface FetchLabelsParams {\n  page?: number;\n  limit?: number;\n  searchQuery?: string;\n  sortBy?: 'name' | 'createdAt' | 'updatedAt' | 'articleCount';\n  sortOrder?: 'asc' | 'desc';\n  includeEmpty?: boolean;\n  forceRefresh?: boolean;\n}\n\nexport interface CreateLabelParams {\n  name: string;\n  color?: string;\n  description?: string;\n}\n\nexport interface UpdateLabelParams {\n  id: string;\n  updates: Partial<\n    Omit<Label, 'id' | 'createdAt' | 'updatedAt' | 'articleCount'>\n  >;\n}\n\nexport interface DeleteLabelParams {\n  id: string;\n  transferToLabel?: string; // Optional: transfer articles to another label before deletion\n}\n\nexport interface AssignLabelToArticleParams {\n  labelId: string;\n  articleId: string;\n}\n\nexport interface RemoveLabelFromArticleParams {\n  labelId: string;\n  articleId: string;\n}\n\nexport interface BatchAssignLabelsParams {\n  operation: 'assign' | 'remove';\n  labelIds: string[];\n  articleIds: string[];\n}\n\n// Response and statistics types\nexport interface LabelStats {\n  totalLabels: number;\n  totalAssignments: number;\n  mostUsedLabels: Array<{\n    label: Label;\n    articleCount: number;\n  }>;\n  unusedLabels: number;\n  averageLabelsPerArticle: number;\n}\n\nexport interface LabelUsageStats {\n  labelId: string;\n  labelName: string;\n  articleCount: number;\n  recentlyUsed: boolean;\n  lastUsed?: string;\n  createdAt: string;\n}\n\n// Error types specific to label operations\nexport interface LabelApiError {\n  code: LabelErrorCode;\n  message: string;\n  labelId?: string;\n  articleId?: string;\n  statusCode?: number;\n  details?: any;\n  retryable: boolean;\n  timestamp: string;\n}\n\nexport enum LabelErrorCode {\n  LABEL_NOT_FOUND = 'LABEL_NOT_FOUND',\n  LABEL_ALREADY_EXISTS = 'LABEL_ALREADY_EXISTS',\n  INVALID_LABEL_NAME = 'INVALID_LABEL_NAME',\n  LABEL_IN_USE = 'LABEL_IN_USE',\n  ASSIGNMENT_FAILED = 'ASSIGNMENT_FAILED',\n  REMOVAL_FAILED = 'REMOVAL_FAILED',\n  DUPLICATE_ASSIGNMENT = 'DUPLICATE_ASSIGNMENT',\n  ASSIGNMENT_NOT_FOUND = 'ASSIGNMENT_NOT_FOUND',\n  BATCH_OPERATION_FAILED = 'BATCH_OPERATION_FAILED',\n  QUOTA_EXCEEDED = 'QUOTA_EXCEEDED',\n  UNKNOWN_LABEL_ERROR = 'UNKNOWN_LABEL_ERROR',\n}\n\n// Cache and optimization types\nexport interface LabelCacheEntry {\n  label: Label;\n  cachedAt: string;\n  expiresAt?: string;\n  accessCount: number;\n  lastAccessed: string;\n}\n\nexport interface LabelSearchResult {\n  labels: Label[];\n  totalCount: number;\n  searchQuery: string;\n  executionTime: number;\n  suggestions?: string[];\n}\n\n// Validation types\nexport interface LabelValidationRules {\n  name: {\n    required: boolean;\n    minLength: number;\n    maxLength: number;\n    allowedCharacters: RegExp;\n    forbiddenNames: string[];\n  };\n  color: {\n    format: 'hex' | 'rgb' | 'hsl';\n    allowedColors?: string[];\n  };\n  description: {\n    maxLength: number;\n  };\n}\n\nexport interface LabelValidationResult {\n  valid: boolean;\n  errors: Array<{\n    field: keyof Label;\n    message: string;\n    code: string;\n  }>;\n  warnings?: Array<{\n    field: keyof Label;\n    message: string;\n    code: string;\n  }>;\n}\n\n// Bulk operations\nexport interface BulkLabelOperation {\n  type: 'create' | 'update' | 'delete' | 'merge';\n  labels: Label[];\n  options?: {\n    skipValidation?: boolean;\n    allowDuplicates?: boolean;\n    mergeTarget?: string; // For merge operations\n  };\n}\n\nexport interface BulkLabelOperationResult {\n  successful: Label[];\n  failed: Array<{\n    label: Partial<Label>;\n    error: LabelApiError;\n  }>;\n  totalProcessed: number;\n  skipped: number;\n}\n\n// Import/Export types\nexport interface LabelExportOptions {\n  format: 'json' | 'csv' | 'xml';\n  includeStats: boolean;\n  includeAssignments: boolean;\n  filters?: LabelFilters;\n}\n\nexport interface LabelExportResult {\n  success: boolean;\n  filePath?: string;\n  downloadUrl?: string;\n  fileSize?: number;\n  labelCount: number;\n  error?: string;\n}\n\nexport interface LabelImportOptions {\n  source: 'json' | 'csv' | 'xml' | 'tags';\n  filePath?: string;\n  data?: any;\n  options?: {\n    skipDuplicates?: boolean;\n    updateExisting?: boolean;\n    preserveColors?: boolean;\n    mergeStrategy?: 'replace' | 'merge' | 'skip';\n  };\n}\n\nexport interface LabelImportResult {\n  success: boolean;\n  imported: number;\n  updated: number;\n  skipped: number;\n  failed: number;\n  errors?: Array<{\n    item: any;\n    error: string;\n  }>;\n}\n\n// React hooks integration types\nexport interface UseLabelsOptions {\n  page?: number;\n  limit?: number;\n  search?: string;\n  sortBy?: 'name' | 'createdAt' | 'articleCount';\n  sortOrder?: 'asc' | 'desc';\n  includeEmpty?: boolean;\n  autoRefresh?: boolean;\n  refreshInterval?: number;\n}\n\nexport interface UseLabelsResult {\n  labels: Label[];\n  loading: boolean;\n  error: string | null;\n  pagination: {\n    page: number;\n    totalPages: number;\n    totalItems: number;\n    hasMore: boolean;\n  };\n  refetch: () => Promise<void>;\n  loadMore: () => Promise<void>;\n  refresh: () => Promise<void>;\n}\n\nexport interface UseLabelResult {\n  label: Label | null;\n  loading: boolean;\n  error: string | null;\n  refetch: () => Promise<void>;\n  update: (updates: Partial<Label>) => Promise<void>;\n  delete: (transferTo?: string) => Promise<void>;\n  assignToArticle: (articleId: string) => Promise<void>;\n  removeFromArticle: (articleId: string) => Promise<void>;\n}\n\n// Advanced search and filtering\nexport interface LabelSearchFilters {\n  query?: string;\n  colorFilter?: string[];\n  articleCountRange?: {\n    min?: number;\n    max?: number;\n  };\n  dateRange?: {\n    from?: string;\n    to?: string;\n  };\n  includeUnused?: boolean;\n  sortBy?: 'name' | 'createdAt' | 'updatedAt' | 'articleCount' | 'relevance';\n  sortOrder?: 'asc' | 'desc';\n}\n\n// Real-time updates\nexport interface LabelUpdateEvent {\n  type: 'created' | 'updated' | 'deleted' | 'assigned' | 'removed';\n  labelId: string;\n  label?: Label;\n  articleId?: string;\n  changes?: Partial<Label>;\n  timestamp: string;\n  userId: string;\n}\n\n// Service configuration\nexport interface LabelsServiceConfig {\n  maxConcurrentRequests: number;\n  requestTimeout: number;\n  retryAttempts: number;\n  retryDelay: number;\n  cacheSize: number;\n  cacheTTL: number;\n  batchSize: number;\n  validationRules: LabelValidationRules;\n}\n\n// Type guards and utility types\nexport type LabelField = keyof Label;\nexport type RequiredLabelFields = 'id' | 'name' | 'createdAt' | 'updatedAt';\nexport type OptionalLabelFields = Exclude<LabelField, RequiredLabelFields>;\n\nexport interface CreateLabelDTO extends Pick<Label, 'name'> {\n  color?: string;\n  description?: string;\n}\n\nexport interface UpdateLabelDTO\n  extends Partial<Omit<Label, RequiredLabelFields>> {}\n\n// Re-export commonly used types\nexport type { PaginatedResponse } from './index';\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/types/readeck.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":310,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":310,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10540,10543],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10540,10543],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":311,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":311,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10571,10574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10571,10574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Readeck API type definitions\n * Comprehensive typing for Readeck REST API client operations\n */\n\n// Base API configuration\nexport interface ReadeckApiConfig {\n  baseUrl: string;\n  timeout: number;\n  retryAttempts: number;\n  retryDelay: number;\n}\n\n// API Error types\nexport interface ReadeckApiError {\n  code: ReadeckErrorCode;\n  message: string;\n  statusCode?: number;\n  details?: string;\n  retryable: boolean;\n  timestamp: string;\n}\n\nexport enum ReadeckErrorCode {\n  NETWORK_ERROR = 'NETWORK_ERROR',\n  AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',\n  AUTHORIZATION_ERROR = 'AUTHORIZATION_ERROR',\n  NOT_FOUND = 'NOT_FOUND',\n  SERVER_ERROR = 'SERVER_ERROR',\n  TIMEOUT_ERROR = 'TIMEOUT_ERROR',\n  RETRY_EXHAUSTED = 'RETRY_EXHAUSTED',\n  INVALID_RESPONSE = 'INVALID_RESPONSE',\n  RATE_LIMITED = 'RATE_LIMITED',\n  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',\n  CONNECTION_ERROR = 'CONNECTION_ERROR',\n  UNKNOWN_ERROR = 'UNKNOWN_ERROR',\n}\n\n// Generic API response wrapper\nexport interface ReadeckApiResponse<T> {\n  data: T;\n  status: number;\n  headers: Record<string, string>;\n  timestamp: string;\n}\n\n// Readeck Bookmark/Article types - Updated to match API documentation\nexport interface ReadeckArticle {\n  id: string;                    // Bookmark's ID\n  title: string;                 // Bookmark's title\n  description?: string;          // Bookmark's short description\n  url: string;                   // Bookmark's original URL\n  site?: string;                 // Bookmark's site host name\n  site_name?: string;           // Bookmark's site name\n  authors?: string[];           // Author list\n  lang?: string;                // Language Code\n  type: 'article' | 'photo' | 'video';  // The bookmark type\n  document_type?: string;       // The bookmark document type\n  has_article: boolean;         // Indicates whether the bookmarks contains an article\n  loaded: boolean;              // Becomes true when the bookmark is ready\n  state: 0 | 1 | 2;            // 0: loaded, 1: error, 2: loading\n  is_archived: boolean;         // true when the bookmark is in the archives\n  is_marked: boolean;           // true when the bookmark is in the favorites\n  is_deleted: boolean;          // true when the bookmark is scheduled for deletion\n  labels?: string[];            // Bookmark's labels\n  published?: string | null;    // Publication date. Can be null when unknown\n  reading_time?: number;        // Duration of the article, in minutes\n  read_progress: number;        // Reading progress percentage (0-100)\n  word_count?: number;          // Number of words in the article\n  text_direction?: 'rtl' | 'ltr'; // Direction of the article's text\n  created: string;              // Creation date\n  updated: string;              // Last update\n  resources?: {                 // Resources associated with the bookmark\n    article?: {\n      src: string;              // URL of the article resource\n    };\n    icon?: {\n      src: string;              // URL of the icon resource\n      height?: number;\n      width?: number;\n    };\n    image?: {\n      src: string;              // URL of the image resource\n      height?: number;\n      width?: number;\n    };\n    thumbnail?: {\n      src: string;              // URL of the thumbnail resource\n      height?: number;\n      width?: number;\n    };\n    log?: {\n      src: string;              // URL of the log resource\n    };\n    props?: {\n      src: string;              // URL of the props resource\n    };\n  };\n  links?: Array<{               // Links collected in the article\n    content_type: string;       // MIME type of the destination\n    domain: string;             // Link's domain\n    is_page: boolean;           // true when the destination is a web page\n    title: string;              // Link's title\n    url: string;                // Link URI\n  }>;\n  read_anchor?: string;         // CSS selector of the last seen element\n}\n\nexport interface ReadeckArticleList {\n  articles: ReadeckArticle[];\n  pagination: {\n    page: number;\n    per_page: number;\n    total_pages: number;\n    total_count: number;\n  };\n}\n\n// Article operations - Updated to match API documentation\nexport interface CreateArticleRequest {\n  url: string;           // Required - URL to fetch\n  title?: string;        // Optional - Title of the bookmark\n  labels?: string[];     // Optional - List of labels to set to the bookmark\n}\n\nexport interface UpdateArticleRequest {\n  title?: string;                // New bookmark's title\n  is_archived?: boolean;         // Archive state\n  is_deleted?: boolean;          // If true, schedules for deletion, otherwise cancels deletion\n  is_marked?: boolean;           // Favorite state\n  labels?: string[];             // Replaces the bookmark's labels\n  add_labels?: string[];         // Add the given labels to the bookmark\n  remove_labels?: string[];      // Remove the given labels from the bookmark\n  read_anchor?: string;          // CSS selector of the last seen element\n  read_progress?: number;        // Reading progress percentage (0-100)\n}\n\nexport interface ArticleFilters {\n  limit?: number;                // Number of items per page\n  offset?: number;               // Pagination offset\n  sort?: string[];               // Sorting parameters: created, -created, domain, -domain, duration, -duration, published, -published, site, -site, title, -title\n  search?: string;               // A full text search string\n  title?: string;                // Bookmark title\n  author?: string;               // Author's name\n  site?: string;                 // Bookmark site name or domain\n  type?: ('article' | 'photo' | 'video')[]; // Bookmark type\n  labels?: string;               // One or several labels\n  is_loaded?: boolean;           // Filter by loaded state\n  has_errors?: boolean;          // Filter bookmarks with or without errors\n  has_labels?: boolean;          // Filter bookmarks with or without labels\n  is_marked?: boolean;           // Filter by marked (favorite) status\n  is_archived?: boolean;         // Filter by archived status\n  range_start?: string;          // Date range start\n  range_end?: string;            // Date range end\n  read_status?: ('unread' | 'reading' | 'read')[]; // Read progress status\n  updated_since?: string;        // Retrieve bookmarks created after this date (date-time)\n  id?: string;                   // One or more bookmark ID\n  collection?: string;           // A collection ID\n}\n\n// Authentication types - Updated to match Readeck API documentation\nexport interface ReadeckLoginRequest {\n  username: string;\n  password: string;\n}\n\nexport interface ReadeckAuthRequest {\n  application: string;  // Required - Application name\n  username: string;     // Required - Username  \n  password: string;     // Required - Password\n  roles?: string[];     // Optional - List of roles to restrict token access\n}\n\nexport interface ReadeckLoginResponse {\n  id: string;      // Token ID\n  token: string;   // Authentication token - store this value\n}\n\n// User profile types - Updated to match Readeck API documentation\nexport interface ReadeckUser {\n  id: string;\n  username: string;\n  email: string;\n  created: string;    // Changed from created_at to match API\n  updated: string;    // Changed from updated_at to match API\n}\n\nexport interface ReadeckUserProfile {\n  provider: {\n    application: string;      // Registered application name\n    id: string;              // Authentication provider ID (token ID)\n    name: string;            // Provider name\n    permissions: string[];   // Permissions granted for this session\n    roles: string[];         // Roles granted for this session\n  };\n  user: {\n    created: string;         // Creation date\n    email: string;           // User email\n    username: string;        // Username\n    updated: string;         // Last update date\n    settings: {\n      debug_info: boolean;   // Enable debug information\n    };\n    reader_settings: {\n      font: string;          // Font setting\n      font_size: number;     // Font size\n      line_height: number;   // Line height\n    };\n  };\n}\n\n// System information\nexport interface ReadeckSystemInfo {\n  version: string;\n  api_version: string;\n  uptime: number;\n  articles_count: number;\n  users_count: number;\n}\n\n// Sync related types\nexport interface ReadeckSyncResponse {\n  articles: ReadeckArticle[];\n  last_updated: string;\n  total_count: number;\n  has_more: boolean;\n}\n\nexport interface SyncRequest {\n  since?: string;\n  limit?: number;\n  include_deleted?: boolean;\n}\n\n// Request configuration\nexport interface RequestConfig {\n  timeout?: number;\n  retryAttempts?: number;\n  skipAuth?: boolean;\n  skipRetry?: boolean;\n}\n\n// Network connectivity state\nexport interface NetworkState {\n  isConnected: boolean;\n  isWifiEnabled: boolean;\n  isCellularEnabled: boolean;\n  networkType: 'wifi' | 'cellular' | 'unknown' | 'none';\n}\n\n// Retry configuration\nexport interface RetryConfig {\n  attempts: number;\n  delay: number;\n  backoffMultiplier: number;\n  maxDelay: number;\n  retryableStatusCodes: number[];\n  retryableErrorCodes: ReadeckErrorCode[];\n}\n\n// Service interface for dependency injection\nexport interface IReadeckApiService {\n  // Authentication\n  login(\n    credentials: ReadeckLoginRequest\n  ): Promise<ReadeckApiResponse<ReadeckLoginResponse>>;\n  validateToken(): Promise<ReadeckApiResponse<ReadeckUser>>;\n  refreshToken(): Promise<ReadeckApiResponse<ReadeckLoginResponse>>;\n\n  // Articles\n  getArticles(\n    filters?: ArticleFilters\n  ): Promise<ReadeckApiResponse<ReadeckArticleList>>;\n  getArticle(id: string): Promise<ReadeckApiResponse<ReadeckArticle>>;\n  createArticle(\n    article: CreateArticleRequest\n  ): Promise<ReadeckApiResponse<ReadeckArticle>>;\n  updateArticle(\n    id: string,\n    updates: UpdateArticleRequest\n  ): Promise<ReadeckApiResponse<ReadeckArticle>>;\n  deleteArticle(id: string): Promise<ReadeckApiResponse<void>>;\n\n  // User\n  getUserProfile(): Promise<ReadeckApiResponse<ReadeckUserProfile>>;\n  updateUserProfile(\n    updates: Partial<ReadeckUserProfile>\n  ): Promise<ReadeckApiResponse<ReadeckUserProfile>>;\n\n  // System\n  getSystemInfo(): Promise<ReadeckApiResponse<ReadeckSystemInfo>>;\n\n  // Sync\n  syncArticles(\n    request?: SyncRequest\n  ): Promise<ReadeckApiResponse<ReadeckSyncResponse>>;\n\n  // Configuration\n  updateConfig(config: Partial<ReadeckApiConfig>): void;\n  getNetworkState(): NetworkState;\n}\n\n// HTTP method types\nexport type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n\n// Request options\nexport interface ApiRequestOptions {\n  method: HttpMethod;\n  url: string;\n  data?: any;\n  params?: Record<string, any>;\n  headers?: Record<string, string>;\n  config?: RequestConfig;\n}\n\n// Response interceptor result\nexport interface InterceptorResult<T> {\n  data: T;\n  proceed: boolean;\n  error?: ReadeckApiError;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/types/sync.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1795,1798],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1795,1798],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1817,1820],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1817,1820],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":159,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3387,3390],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3387,3390],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3409,3412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3409,3412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":166,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3543,3546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3543,3546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface SyncState {\n  // Sync status tracking\n  status: SyncStatus;\n  lastSyncTime: string | null;\n\n  // Progress tracking\n  progress: SyncProgress;\n\n  // Network and connectivity\n  isOnline: boolean;\n  networkType: NetworkType | null;\n\n  // Configuration\n  config: SyncConfiguration;\n\n  // Conflict resolution\n  conflicts: ConflictResolution[];\n\n  // Error handling\n  error: string | null;\n\n  // Statistics\n  stats: SyncStatistics;\n}\n\nexport enum SyncStatus {\n  IDLE = 'idle',\n  SYNCING = 'syncing',\n  SUCCESS = 'success',\n  ERROR = 'error',\n  PAUSED = 'paused',\n}\n\nexport enum NetworkType {\n  WIFI = 'wifi',\n  CELLULAR = 'cellular',\n  ETHERNET = 'ethernet',\n  UNKNOWN = 'unknown',\n}\n\nexport interface SyncProgress {\n  phase: SyncPhase;\n  totalItems: number;\n  processedItems: number;\n  currentItem: string | null;\n  estimatedTimeRemaining: number | null;\n}\n\nexport enum SyncPhase {\n  INITIALIZING = 'initializing',\n  UPLOADING_CHANGES = 'uploading_changes',\n  DOWNLOADING_UPDATES = 'downloading_updates',\n  RESOLVING_CONFLICTS = 'resolving_conflicts',\n  FINALIZING = 'finalizing',\n}\n\nexport interface SyncConfiguration {\n  // Background sync settings\n  backgroundSyncEnabled: boolean;\n  syncInterval: number; // minutes\n\n  // Network preferences\n  syncOnWifiOnly: boolean;\n  syncOnCellular: boolean;\n\n  // Data preferences\n  downloadImages: boolean;\n  fullTextSync: boolean;\n\n  // Conflict resolution strategy\n  conflictResolutionStrategy: ConflictResolutionStrategy;\n\n  // Batch size\n  batchSize: number;\n}\n\nexport enum ConflictResolutionStrategy {\n  LAST_WRITE_WINS = 'last_write_wins',\n  MANUAL = 'manual',\n  LOCAL_WINS = 'local_wins',\n  REMOTE_WINS = 'remote_wins',\n}\n\nexport interface ConflictResolution {\n  id: string;\n  articleId: string;\n  type: ConflictType;\n  localVersion: any;\n  remoteVersion: any;\n  createdAt: string;\n  resolvedAt: string | null;\n  resolution: ConflictResolutionStrategy | null;\n}\n\nexport enum ConflictType {\n  CONTENT_MODIFIED = 'content_modified',\n  STATUS_CHANGED = 'status_changed',\n  TAGS_UPDATED = 'tags_updated',\n  DELETED_LOCALLY = 'deleted_locally',\n  DELETED_REMOTELY = 'deleted_remotely',\n}\n\nexport interface SyncStatistics {\n  totalSyncs: number;\n  successfulSyncs: number;\n  failedSyncs: number;\n  lastSyncDuration: number | null; // milliseconds\n  averageSyncDuration: number | null; // milliseconds\n  itemsSynced: SyncItemStats;\n  dataTransfer: DataTransferStats;\n}\n\nexport interface SyncItemStats {\n  articlesCreated: number;\n  articlesUpdated: number;\n  articlesDeleted: number;\n  conflictsResolved: number;\n}\n\nexport interface DataTransferStats {\n  bytesUploaded: number;\n  bytesDownloaded: number;\n  requestCount: number;\n  cacheHits: number;\n}\n\n// Action payload types\nexport interface StartSyncPayload {\n  fullSync?: boolean;\n  forceSync?: boolean;\n  syncOptions?: Partial<SyncConfiguration>;\n}\n\nexport interface SyncProgressPayload {\n  phase: SyncPhase;\n  totalItems: number;\n  processedItems: number;\n  currentItem?: string;\n  estimatedTimeRemaining?: number;\n}\n\nexport interface SyncSuccessPayload {\n  syncDuration: number;\n  itemsProcessed: number;\n  conflictsDetected: number;\n  syncTime: string;\n}\n\nexport interface SyncErrorPayload {\n  error: string;\n  errorCode?: string;\n  phase?: SyncPhase;\n  retryable?: boolean;\n}\n\nexport interface AddConflictPayload {\n  articleId: string;\n  type: ConflictType;\n  localVersion: any;\n  remoteVersion: any;\n}\n\nexport interface ResolveConflictPayload {\n  conflictId: string;\n  resolution: ConflictResolutionStrategy;\n  resolvedVersion?: any;\n}\n\nexport interface UpdateSyncConfigPayload {\n  config: Partial<SyncConfiguration>;\n}\n\nexport interface NetworkStatusPayload {\n  isOnline: boolean;\n  networkType: NetworkType | null;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/utils/adbHelper.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":115,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":115,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[3455,3514],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":147,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":147,"endColumn":23,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[4579,4641],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":170,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":170,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[5153,5226],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":175,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":175,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5508,5567],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":186,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":186,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5915,6016],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":191,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":191,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6117,6172],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":201,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":201,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6551,6592],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":218,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":218,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[6989,7070],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":223,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":223,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[7252,7337],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":242,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":242,"endColumn":23,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[7832,7916],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":248,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":248,"endColumn":23,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[8071,8148],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":251,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":251,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8176,8258],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":257,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":257,"endColumn":23,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[8482,8565],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":263,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":263,"endColumn":23,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[8719,8795],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":268,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":268,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8964,9124],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":272,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":272,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[9232,9309],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":273,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":273,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9316,9482],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'testName' is defined but never used. Allowed unused args must match /^_/u.","line":280,"column":60,"nodeType":null,"messageId":"unusedVar","endLine":280,"endColumn":68},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":313,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":313,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10428,10431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10428,10431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":334,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":334,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10883,10886],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10883,10886],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":388,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":388,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[13059,13120],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":481,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":481,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[15504,15564],"text":""},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ADB Helper - Android Debug Bridge utilities for React Native performance testing\n * \n * This module provides utilities to interact with Android devices/emulators via ADB\n * for real device performance testing instead of mocked tests.\n */\n\nimport { exec, spawn } from 'child_process';\nimport { promisify } from 'util';\nimport { performance } from 'perf_hooks';\n\nconst execAsync = promisify(exec);\n\nexport interface DeviceInfo {\n  id: string;\n  status: 'device' | 'emulator' | 'offline';\n  model?: string;\n  version?: string;\n  arch?: string;\n  apiLevel?: number;\n}\n\nexport interface PerformanceMetrics {\n  cpuUsage: number;\n  memoryUsage: number;\n  networkLatency: number;\n  frameRate: number;\n  jankCount: number;\n  renderTime: number;\n  duration: number;\n}\n\nexport interface NetworkCondition {\n  type: 'fast' | 'moderate' | 'slow' | 'offline';\n  downloadSpeed: number; // kbps\n  uploadSpeed: number;   // kbps\n  latency: number;       // ms\n  packetLoss: number;    // percentage\n}\n\nexport class AdbHelper {\n  private packageName: string;\n  private currentDevice?: DeviceInfo;\n\n  constructor(packageName: string = 'com.mobdeck') {\n    this.packageName = packageName;\n  }\n\n  /**\n   * Get list of connected Android devices/emulators\n   */\n  async getDevices(): Promise<DeviceInfo[]> {\n    try {\n      const { stdout } = await execAsync('adb devices -l');\n      const lines = stdout.split('\\n').filter(line => line.trim() && !line.startsWith('List'));\n      \n      const devices: DeviceInfo[] = [];\n      for (const line of lines) {\n        const parts = line.split(/\\s+/);\n        if (parts.length >= 2) {\n          const id = parts[0];\n          const status = parts[1] as 'device' | 'emulator' | 'offline';\n          \n          // Extract model and other info from device description\n          const modelMatch = line.match(/model:(\\S+)/);\n          const model = modelMatch ? modelMatch[1] : undefined;\n          \n          devices.push({\n            id,\n            status,\n            model,\n          });\n        }\n      }\n      \n      return devices;\n    } catch (error) {\n      throw new Error(`Failed to get devices: ${error}`);\n    }\n  }\n\n  /**\n   * Connect to a specific device for testing\n   */\n  async connectToDevice(deviceId?: string): Promise<DeviceInfo> {\n    const devices = await this.getDevices();\n    \n    if (devices.length === 0) {\n      throw new Error('No Android devices found. Please connect a device or start an emulator.');\n    }\n\n    // Use specified device or first available\n    const targetDevice = deviceId \n      ? devices.find(d => d.id === deviceId)\n      : devices.find(d => d.status === 'device') || devices[0];\n\n    if (!targetDevice) {\n      throw new Error(`Device ${deviceId} not found`);\n    }\n\n    if (targetDevice.status === 'offline') {\n      throw new Error(`Device ${targetDevice.id} is offline`);\n    }\n\n    // Get additional device info\n    try {\n      const { stdout: versionOutput } = await execAsync(`adb -s ${targetDevice.id} shell getprop ro.build.version.release`);\n      const { stdout: apiOutput } = await execAsync(`adb -s ${targetDevice.id} shell getprop ro.build.version.sdk`);\n      const { stdout: archOutput } = await execAsync(`adb -s ${targetDevice.id} shell getprop ro.product.cpu.abi`);\n      \n      targetDevice.version = versionOutput.trim();\n      targetDevice.apiLevel = parseInt(apiOutput.trim(), 10);\n      targetDevice.arch = archOutput.trim();\n    } catch (error) {\n      console.warn('Could not get detailed device info:', error);\n    }\n\n    this.currentDevice = targetDevice;\n    return targetDevice;\n  }\n\n  /**\n   * Check if the React Native app is installed and running\n   */\n  async isAppRunning(): Promise<boolean> {\n    if (!this.currentDevice) {\n      throw new Error('No device connected');\n    }\n\n    try {\n      // Try modern approach first (Android 7+)\n      const { stdout } = await execAsync(`adb -s ${this.currentDevice.id} shell \"pidof ${this.packageName}\"`);\n      if (stdout.trim().length > 0) {\n        return true;\n      }\n    } catch (error) {\n      // Fallback to older ps command\n      try {\n        const { stdout } = await execAsync(`adb -s ${this.currentDevice.id} shell \"ps | grep ${this.packageName}\"`);\n        return stdout.trim().length > 0;\n      } catch (fallbackError) {\n        // Final fallback using dumpsys\n        try {\n          const { stdout } = await execAsync(`adb -s ${this.currentDevice.id} shell \"dumpsys activity activities | grep ${this.packageName}\"`);\n          return stdout.includes(this.packageName);\n        } catch (finalError) {\n          console.warn('All app detection methods failed:', finalError);\n          return false;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Launch the React Native app\n   */\n  async launchApp(): Promise<void> {\n    if (!this.currentDevice) {\n      throw new Error('No device connected');\n    }\n\n    try {\n      // First try to stop any existing instances\n      try {\n        await execAsync(`adb -s ${this.currentDevice.id} shell am force-stop ${this.packageName}`);\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      } catch (stopError) {\n        console.warn('Could not stop existing app instance:', stopError.message);\n      }\n\n      // Launch the app with additional flags for better reliability\n      const launchResult = await execAsync(`adb -s ${this.currentDevice.id} shell am start -n ${this.packageName}/.MainActivity -a android.intent.action.MAIN -c android.intent.category.LAUNCHER`);\n      console.log('Launch command result:', launchResult.stdout);\n      \n      // Wait for app to start with progressive checking\n      let attempts = 0;\n      const maxAttempts = 10;\n      let isRunning = false;\n      \n      while (attempts < maxAttempts && !isRunning) {\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        isRunning = await this.isAppRunning();\n        attempts++;\n        console.log(`App launch check ${attempts}/${maxAttempts}: ${isRunning ? 'running' : 'not running'}`);\n      }\n      \n      if (!isRunning) {\n        // Try one more time with different approach\n        console.log('Attempting alternative launch method...');\n        await execAsync(`adb -s ${this.currentDevice.id} shell monkey -p ${this.packageName} -c android.intent.category.LAUNCHER 1`);\n        await new Promise(resolve => setTimeout(resolve, 3000));\n        isRunning = await this.isAppRunning();\n      }\n      \n      if (!isRunning) {\n        throw new Error('App failed to start after multiple attempts');\n      }\n      \n      console.log('App launched successfully');\n    } catch (error) {\n      throw new Error(`Failed to launch app: ${error.message}`);\n    }\n  }\n\n  /**\n   * Kill the React Native app\n   */\n  async killApp(): Promise<void> {\n    if (!this.currentDevice) {\n      throw new Error('No device connected');\n    }\n\n    try {\n      await execAsync(`adb -s ${this.currentDevice.id} shell am force-stop ${this.packageName}`);\n    } catch (error) {\n      console.warn(`Could not force-stop app (emulator limitation): ${error.message}`);\n      // Try alternative method\n      try {\n        await execAsync(`adb -s ${this.currentDevice.id} shell \"pkill ${this.packageName}\"`);\n      } catch (alternativeError) {\n        console.warn(`Alternative app kill method also failed: ${alternativeError.message}`);\n      }\n    }\n  }\n\n  /**\n   * Set network conditions on the device\n   */\n  async setNetworkConditions(condition: NetworkCondition): Promise<void> {\n    if (!this.currentDevice) {\n      throw new Error('No device connected');\n    }\n\n    try {\n      if (condition.type === 'offline') {\n        // Try to disable network - gracefully handle emulator limitations\n        try {\n          await execAsync(`adb -s ${this.currentDevice.id} shell svc data disable`);\n        } catch (error) {\n          console.warn('Could not disable mobile data (emulator limitation):', error.message);\n        }\n        \n        try {\n          await execAsync(`adb -s ${this.currentDevice.id} shell svc wifi disable`);\n        } catch (error) {\n          console.warn('Could not disable wifi (emulator limitation):', error.message);\n        }\n        \n        console.log(`Network conditions set: ${condition.type} - simulated offline mode`);\n      } else {\n        // Try to enable network - gracefully handle emulator limitations\n        try {\n          await execAsync(`adb -s ${this.currentDevice.id} shell svc data enable`);\n        } catch (error) {\n          console.warn('Could not enable mobile data (emulator limitation):', error.message);\n        }\n        \n        try {\n          await execAsync(`adb -s ${this.currentDevice.id} shell svc wifi enable`);\n        } catch (error) {\n          console.warn('Could not enable wifi (emulator limitation):', error.message);\n        }\n        \n        // Note: Network throttling requires additional tools like `tc` or proxy setup\n        // For now, we'll log the intended conditions\n        console.log(`Network conditions set: ${condition.type} - ${condition.downloadSpeed}kbps down, ${condition.uploadSpeed}kbps up, ${condition.latency}ms latency`);\n      }\n    } catch (error) {\n      // Don't throw error for network condition setting - just log it\n      console.warn(`Network condition setting partially failed: ${error.message}`);\n      console.log(`Network conditions simulated: ${condition.type} - ${condition.downloadSpeed}kbps down, ${condition.uploadSpeed}kbps up, ${condition.latency}ms latency`);\n    }\n  }\n\n  /**\n   * Measure app performance metrics\n   */\n  async measurePerformance(operation: () => Promise<void>, testName: string): Promise<PerformanceMetrics> {\n    if (!this.currentDevice) {\n      throw new Error('No device connected');\n    }\n\n    const startTime = performance.now();\n    \n    // Start performance monitoring\n    const perfMonitor = this.startPerformanceMonitoring();\n    \n    try {\n      // Execute the operation\n      await operation();\n      \n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      // Stop monitoring and collect metrics\n      const metrics = await this.stopPerformanceMonitoring(perfMonitor);\n      \n      return {\n        ...metrics,\n        duration,\n      };\n    } catch (error) {\n      await this.stopPerformanceMonitoring(perfMonitor);\n      throw error;\n    }\n  }\n\n  /**\n   * Start performance monitoring\n   */\n  private startPerformanceMonitoring(): any {\n    if (!this.currentDevice) {\n      throw new Error('No device connected');\n    }\n\n    // Start dumpsys monitoring for detailed metrics\n    const monitor = spawn('adb', [\n      '-s', this.currentDevice.id,\n      'shell',\n      'dumpsys',\n      'gfxinfo',\n      this.packageName,\n      'framestats'\n    ]);\n\n    return monitor;\n  }\n\n  /**\n   * Stop performance monitoring and collect metrics\n   */\n  private async stopPerformanceMonitoring(monitor: any): Promise<Omit<PerformanceMetrics, 'duration'>> {\n    if (!this.currentDevice) {\n      throw new Error('No device connected');\n    }\n\n    try {\n      // Kill the monitor process\n      monitor.kill();\n\n      // Get CPU usage\n      const { stdout: cpuOutput } = await execAsync(`adb -s ${this.currentDevice.id} shell \"dumpsys cpuinfo | grep ${this.packageName}\"`);\n      const cpuMatch = cpuOutput.match(/(\\d+\\.?\\d*)%/);\n      const cpuUsage = cpuMatch ? parseFloat(cpuMatch[1]) : 0;\n\n      // Get memory usage\n      const { stdout: memOutput } = await execAsync(`adb -s ${this.currentDevice.id} shell \"dumpsys meminfo ${this.packageName} | grep 'TOTAL'\"`);\n      const memMatch = memOutput.match(/(\\d+)/);\n      const memoryUsage = memMatch ? parseInt(memMatch[1], 10) : 0;\n\n      // Get network latency (simplified)\n      let networkLatency = 0;\n      try {\n        const { stdout: pingOutput } = await execAsync(`adb -s ${this.currentDevice.id} shell \"ping -c 1 8.8.8.8\"`);\n        const latencyMatch = pingOutput.match(/time=(\\d+\\.?\\d*)/);\n        networkLatency = latencyMatch ? parseFloat(latencyMatch[1]) : 0;\n      } catch (error) {\n        // Network might be offline or unreachable\n        networkLatency = -1;\n      }\n\n      // Get frame rate and jank info\n      const { stdout: gfxOutput } = await execAsync(`adb -s ${this.currentDevice.id} shell \"dumpsys gfxinfo ${this.packageName} | grep 'Total frames'\"`);\n      const frameMatch = gfxOutput.match(/Total frames rendered: (\\d+)/);\n      const jankMatch = gfxOutput.match(/Janky frames: (\\d+)/);\n      \n      const totalFrames = frameMatch ? parseInt(frameMatch[1], 10) : 0;\n      const jankyFrames = jankMatch ? parseInt(jankMatch[1], 10) : 0;\n      \n      // Calculate approximate frame rate and jank\n      const frameRate = totalFrames > 0 ? 60 : 0; // Simplified\n      const jankCount = jankyFrames;\n\n      // Get render time (simplified)\n      const renderTime = cpuUsage > 0 ? cpuUsage * 16.67 : 0; // Rough estimate based on CPU\n\n      return {\n        cpuUsage,\n        memoryUsage,\n        networkLatency,\n        frameRate,\n        jankCount,\n        renderTime,\n      };\n    } catch (error) {\n      console.warn('Error collecting performance metrics:', error);\n      return {\n        cpuUsage: 0,\n        memoryUsage: 0,\n        networkLatency: 0,\n        frameRate: 0,\n        jankCount: 0,\n        renderTime: 0,\n      };\n    }\n  }\n\n  /**\n   * Send touch events to the device\n   */\n  async sendTouchEvent(x: number, y: number): Promise<void> {\n    if (!this.currentDevice) {\n      throw new Error('No device connected');\n    }\n\n    try {\n      await execAsync(`adb -s ${this.currentDevice.id} shell input tap ${x} ${y}`);\n    } catch (error) {\n      throw new Error(`Failed to send touch event: ${error}`);\n    }\n  }\n\n  /**\n   * Send text input to the device\n   */\n  async sendTextInput(text: string): Promise<void> {\n    if (!this.currentDevice) {\n      throw new Error('No device connected');\n    }\n\n    try {\n      // Escape special characters\n      const escapedText = text.replace(/[&|\\\\;$%@\"<>()+,]/g, '\\\\$&');\n      await execAsync(`adb -s ${this.currentDevice.id} shell input text \"${escapedText}\"`);\n    } catch (error) {\n      throw new Error(`Failed to send text input: ${error}`);\n    }\n  }\n\n  /**\n   * Send key events to the device\n   */\n  async sendKeyEvent(keyCode: number): Promise<void> {\n    if (!this.currentDevice) {\n      throw new Error('No device connected');\n    }\n\n    try {\n      await execAsync(`adb -s ${this.currentDevice.id} shell input keyevent ${keyCode}`);\n    } catch (error) {\n      throw new Error(`Failed to send key event: ${error}`);\n    }\n  }\n\n  /**\n   * Take a screenshot of the device\n   */\n  async takeScreenshot(filename: string): Promise<string> {\n    if (!this.currentDevice) {\n      throw new Error('No device connected');\n    }\n\n    try {\n      const remotePath = '/sdcard/screenshot.png';\n      await execAsync(`adb -s ${this.currentDevice.id} shell screencap -p ${remotePath}`);\n      await execAsync(`adb -s ${this.currentDevice.id} pull ${remotePath} ${filename}`);\n      await execAsync(`adb -s ${this.currentDevice.id} shell rm ${remotePath}`);\n      return filename;\n    } catch (error) {\n      throw new Error(`Failed to take screenshot: ${error}`);\n    }\n  }\n\n  /**\n   * Get current device information\n   */\n  getCurrentDevice(): DeviceInfo | undefined {\n    return this.currentDevice;\n  }\n\n  /**\n   * Disconnect from the current device\n   */\n  async disconnect(): Promise<void> {\n    if (this.currentDevice) {\n      try {\n        await this.killApp();\n      } catch (error) {\n        console.warn('Error killing app during disconnect:', error);\n      }\n      this.currentDevice = undefined;\n    }\n  }\n}\n\n/**\n * Network condition presets\n */\nexport const NETWORK_CONDITIONS: Record<string, NetworkCondition> = {\n  FAST: {\n    type: 'fast',\n    downloadSpeed: 10000, // 10 Mbps\n    uploadSpeed: 5000,    // 5 Mbps\n    latency: 10,          // 10ms\n    packetLoss: 0,        // 0%\n  },\n  MODERATE: {\n    type: 'moderate',\n    downloadSpeed: 1000,  // 1 Mbps\n    uploadSpeed: 500,     // 500 kbps\n    latency: 100,         // 100ms\n    packetLoss: 0.01,     // 1%\n  },\n  SLOW: {\n    type: 'slow',\n    downloadSpeed: 100,   // 100 kbps\n    uploadSpeed: 50,      // 50 kbps\n    latency: 500,         // 500ms\n    packetLoss: 0.05,     // 5%\n  },\n  OFFLINE: {\n    type: 'offline',\n    downloadSpeed: 0,\n    uploadSpeed: 0,\n    latency: Infinity,\n    packetLoss: 1,        // 100%\n  },\n};\n\n/**\n * Common Android key codes\n */\nexport const KEY_CODES = {\n  BACK: 4,\n  HOME: 3,\n  MENU: 82,\n  SEARCH: 84,\n  ENTER: 66,\n  DEL: 67,\n  TAB: 61,\n  SPACE: 62,\n  DPAD_UP: 19,\n  DPAD_DOWN: 20,\n  DPAD_LEFT: 21,\n  DPAD_RIGHT: 22,\n  DPAD_CENTER: 23,\n};","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/utils/conflictResolution.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[457,460],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[457,460],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1096,1099],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1096,1099],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1116,1119],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1116,1119],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":68,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":68,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1710,1837],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":104,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":104,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2876,3124],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":135,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":135,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3796,3898],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":158,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":158,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4323,4426],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'localValue' is defined but never used. Allowed unused args must match /^_/u.","line":214,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":214,"endColumn":13},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":214,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5593,5596],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5593,5596],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'remoteValue' is defined but never used. Allowed unused args must match /^_/u.","line":215,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":215,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":215,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":215,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5613,5616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5613,5616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'localValue' is defined but never used. Allowed unused args must match /^_/u.","line":241,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":241,"endColumn":13},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":241,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":241,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6103,6106],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6103,6106],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'remoteValue' is defined but never used. Allowed unused args must match /^_/u.","line":242,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":242,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":242,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6123,6126],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6123,6126],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":270,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":270,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6683,6686],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6683,6686],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":270,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":270,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6691,6694],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6691,6694],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":375,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":375,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9247,9250],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9247,9250],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":379,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":379,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9399,9402],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9399,9402],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":383,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":383,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9551,9554],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9551,9554],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":389,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":389,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9794,9797],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9794,9797],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Conflict Resolution Utilities\n *\n * Provides conflict resolution strategies for synchronization between local and remote data.\n * Implements various strategies including Last-Write-Wins, Local-Wins, Remote-Wins, and Manual resolution.\n */\n\nimport { Article } from '../types';\nimport { ConflictResolutionStrategy, ConflictType } from '../types/sync';\n\n/**\n * Result of a conflict resolution operation\n */\nexport interface ConflictResolutionResult<T = any> {\n  resolved: boolean;\n  resolvedData?: T;\n  strategy: ConflictResolutionStrategy;\n  conflictType: ConflictType;\n  metadata: {\n    localTimestamp: Date;\n    remoteTimestamp: Date;\n    resolutionTimestamp: Date;\n    changes: string[];\n  };\n}\n\n/**\n * Configuration for conflict resolution\n */\nexport interface ConflictResolutionConfig {\n  strategy: ConflictResolutionStrategy;\n  autoResolve: boolean;\n  preserveLocalChanges: boolean;\n  preserveRemoteChanges: boolean;\n  logConflicts: boolean;\n}\n\n/**\n * Details about detected conflicts between local and remote data\n */\nexport interface ConflictDetails {\n  field: string;\n  localValue: any;\n  remoteValue: any;\n  conflictType: ConflictType;\n  severity: 'low' | 'medium' | 'high';\n}\n\n/**\n * Resolve conflicts between local and remote articles using the specified strategy\n */\nexport function resolveConflict(\n  localArticle: Article,\n  remoteArticle: Article,\n  strategy: ConflictResolutionStrategy,\n  config?: Partial<ConflictResolutionConfig>\n): Article {\n  const resolverConfig: ConflictResolutionConfig = {\n    strategy,\n    autoResolve: true,\n    preserveLocalChanges: false,\n    preserveRemoteChanges: false,\n    logConflicts: true,\n    ...config,\n  };\n\n  if (resolverConfig.logConflicts) {\n    console.log(\n      `[ConflictResolution] Resolving conflict for article: ${localArticle.id} using strategy: ${strategy}`\n    );\n  }\n\n  switch (strategy) {\n    case ConflictResolutionStrategy.LAST_WRITE_WINS:\n      return resolveLastWriteWins(localArticle, remoteArticle, resolverConfig);\n\n    case ConflictResolutionStrategy.LOCAL_WINS:\n      return resolveLocalWins(localArticle, remoteArticle, resolverConfig);\n\n    case ConflictResolutionStrategy.REMOTE_WINS:\n      return resolveRemoteWins(localArticle, remoteArticle, resolverConfig);\n\n    case ConflictResolutionStrategy.MANUAL:\n      throw new Error('Manual conflict resolution requires user intervention');\n\n    default:\n      throw new Error(`Unknown conflict resolution strategy: ${strategy}`);\n  }\n}\n\n/**\n * Resolve conflict using Last-Write-Wins strategy\n * The version with the most recent updatedAt timestamp wins\n */\nfunction resolveLastWriteWins(\n  localArticle: Article,\n  remoteArticle: Article,\n  config: ConflictResolutionConfig\n): Article {\n  const localTimestamp = new Date(localArticle.updatedAt);\n  const remoteTimestamp = new Date(remoteArticle.updatedAt);\n\n  if (config.logConflicts) {\n    console.log(`[ConflictResolution] Last-Write-Wins comparison:`, {\n      localTimestamp: localTimestamp.toISOString(),\n      remoteTimestamp: remoteTimestamp.toISOString(),\n      winner: localTimestamp > remoteTimestamp ? 'local' : 'remote',\n    });\n  }\n\n  // Return the version with the latest timestamp\n  const winningArticle =\n    localTimestamp > remoteTimestamp ? localArticle : remoteArticle;\n\n  // Preserve certain metadata from both versions\n  return {\n    ...winningArticle,\n    // Always use the most recent sync timestamp\n    syncedAt: new Date().toISOString(),\n    // Mark as no longer modified since we're resolving the conflict\n    isModified: false,\n  };\n}\n\n/**\n * Resolve conflict using Local-Wins strategy\n * Always prefer the local version\n */\nfunction resolveLocalWins(\n  localArticle: Article,\n  remoteArticle: Article,\n  config: ConflictResolutionConfig\n): Article {\n  if (config.logConflicts) {\n    console.log(\n      `[ConflictResolution] Local-Wins resolution for article: ${localArticle.id}`\n    );\n  }\n\n  return {\n    ...localArticle,\n    // Update sync timestamp but keep as modified to upload later\n    syncedAt: new Date().toISOString(),\n    isModified: true,\n  };\n}\n\n/**\n * Resolve conflict using Remote-Wins strategy\n * Always prefer the remote version\n */\nfunction resolveRemoteWins(\n  localArticle: Article,\n  remoteArticle: Article,\n  config: ConflictResolutionConfig\n): Article {\n  if (config.logConflicts) {\n    console.log(\n      `[ConflictResolution] Remote-Wins resolution for article: ${localArticle.id}`\n    );\n  }\n\n  return {\n    ...remoteArticle,\n    // Update sync timestamp and mark as not modified\n    syncedAt: new Date().toISOString(),\n    isModified: false,\n  };\n}\n\n/**\n * Detect conflicts between local and remote articles\n */\nexport function detectConflicts(\n  localArticle: Article,\n  remoteArticle: Article\n): ConflictDetails[] {\n  const conflicts: ConflictDetails[] = [];\n\n  // Check for field-level conflicts\n  const fieldsToCheck: Array<keyof Article> = [\n    'title',\n    'summary',\n    'content',\n    'isArchived',\n    'isFavorite',\n    'isRead',\n    'tags',\n  ];\n\n  for (const field of fieldsToCheck) {\n    const localValue = localArticle[field];\n    const remoteValue = remoteArticle[field];\n\n    if (!deepEqual(localValue, remoteValue)) {\n      conflicts.push({\n        field: field as string,\n        localValue,\n        remoteValue,\n        conflictType: getConflictType(field, localValue, remoteValue),\n        severity: getConflictSeverity(field, localValue, remoteValue),\n      });\n    }\n  }\n\n  return conflicts;\n}\n\n/**\n * Determine the type of conflict based on the field and values\n */\nfunction getConflictType(\n  field: keyof Article,\n  localValue: any,\n  remoteValue: any\n): ConflictType {\n  switch (field) {\n    case 'title':\n    case 'summary':\n    case 'content':\n      return ConflictType.CONTENT_MODIFIED;\n\n    case 'isArchived':\n    case 'isFavorite':\n    case 'isRead':\n      return ConflictType.STATUS_CHANGED;\n\n    case 'tags':\n      return ConflictType.TAGS_UPDATED;\n\n    default:\n      return ConflictType.CONTENT_MODIFIED;\n  }\n}\n\n/**\n * Determine the severity of a conflict\n */\nfunction getConflictSeverity(\n  field: keyof Article,\n  localValue: any,\n  remoteValue: any\n): 'low' | 'medium' | 'high' {\n  switch (field) {\n    case 'content':\n      return 'high'; // Content changes are high severity\n\n    case 'title':\n      return 'medium'; // Title changes are medium severity\n\n    case 'summary':\n      return 'medium';\n\n    case 'isArchived':\n    case 'isFavorite':\n    case 'isRead':\n      return 'low'; // Status changes are low severity\n\n    case 'tags':\n      return 'low'; // Tag changes are low severity\n\n    default:\n      return 'medium';\n  }\n}\n\n/**\n * Check if two values are deeply equal\n */\nfunction deepEqual(a: any, b: any): boolean {\n  if (a === b) return true;\n\n  if (a == null || b == null) return a === b;\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false;\n    }\n    return true;\n  }\n\n  if (typeof a === 'object' && typeof b === 'object') {\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n\n    if (keysA.length !== keysB.length) return false;\n\n    for (const key of keysA) {\n      if (!keysB.includes(key)) return false;\n      if (!deepEqual(a[key], b[key])) return false;\n    }\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Create a detailed conflict resolution result\n */\nexport function createConflictResolutionResult<T>(\n  localData: T,\n  remoteData: T,\n  resolvedData: T,\n  strategy: ConflictResolutionStrategy,\n  conflictType: ConflictType,\n  changes: string[]\n): ConflictResolutionResult<T> {\n  return {\n    resolved: true,\n    resolvedData,\n    strategy,\n    conflictType,\n    metadata: {\n      localTimestamp: new Date(),\n      remoteTimestamp: new Date(),\n      resolutionTimestamp: new Date(),\n      changes,\n    },\n  };\n}\n\n/**\n * Merge articles intelligently, combining non-conflicting changes\n */\nexport function mergeArticles(\n  localArticle: Article,\n  remoteArticle: Article,\n  baseArticle?: Article\n): Article {\n  // If we have a base article (common ancestor), perform three-way merge\n  if (baseArticle) {\n    return performThreeWayMerge(baseArticle, localArticle, remoteArticle);\n  }\n\n  // Otherwise, perform two-way merge using Last-Write-Wins as default\n  return resolveLastWriteWins(localArticle, remoteArticle, {\n    strategy: ConflictResolutionStrategy.LAST_WRITE_WINS,\n    autoResolve: true,\n    preserveLocalChanges: false,\n    preserveRemoteChanges: false,\n    logConflicts: true,\n  });\n}\n\n/**\n * Perform three-way merge when base article is available\n */\nfunction performThreeWayMerge(\n  baseArticle: Article,\n  localArticle: Article,\n  remoteArticle: Article\n): Article {\n  const merged: Article = { ...baseArticle };\n\n  // Fields to merge\n  const fieldsToMerge: Array<keyof Article> = [\n    'title',\n    'summary',\n    'content',\n    'isArchived',\n    'isFavorite',\n    'isRead',\n    'tags',\n  ];\n\n  for (const field of fieldsToMerge) {\n    const baseValue = baseArticle[field];\n    const localValue = localArticle[field];\n    const remoteValue = remoteArticle[field];\n\n    // If local and remote are the same, use that value\n    if (deepEqual(localValue, remoteValue)) {\n      (merged as any)[field] = localValue;\n    }\n    // If local changed but remote didn't, use local\n    else if (deepEqual(remoteValue, baseValue)) {\n      (merged as any)[field] = localValue;\n    }\n    // If remote changed but local didn't, use remote\n    else if (deepEqual(localValue, baseValue)) {\n      (merged as any)[field] = remoteValue;\n    }\n    // Both changed differently - use Last-Write-Wins\n    else {\n      const localTimestamp = new Date(localArticle.updatedAt);\n      const remoteTimestamp = new Date(remoteArticle.updatedAt);\n      (merged as any)[field] =\n        localTimestamp > remoteTimestamp ? localValue : remoteValue;\n    }\n  }\n\n  // Always use the latest timestamps\n  merged.updatedAt = new Date(\n    Math.max(\n      new Date(localArticle.updatedAt).getTime(),\n      new Date(remoteArticle.updatedAt).getTime()\n    )\n  );\n  merged.syncedAt = new Date().toISOString();\n  merged.isModified = false;\n\n  return merged;\n}\n\n/**\n * Validate that a conflict resolution is safe to apply\n */\nexport function validateResolution(\n  localArticle: Article,\n  remoteArticle: Article,\n  resolvedArticle: Article\n): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  // Ensure essential fields are preserved\n  if (!resolvedArticle.id) {\n    errors.push('Resolved article must have an ID');\n  }\n\n  if (!resolvedArticle.title || resolvedArticle.title.trim().length === 0) {\n    errors.push('Resolved article must have a title');\n  }\n\n  if (!resolvedArticle.url) {\n    errors.push('Resolved article must have a URL');\n  }\n\n  // Ensure timestamps are reasonable\n  if (resolvedArticle.createdAt > new Date()) {\n    errors.push('Resolved article creation date cannot be in the future');\n  }\n\n  if (resolvedArticle.updatedAt > new Date()) {\n    errors.push('Resolved article update date cannot be in the future');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * Generate a human-readable description of the conflicts\n */\nexport function describeConflicts(conflicts: ConflictDetails[]): string[] {\n  return conflicts.map(conflict => {\n    switch (conflict.conflictType) {\n      case ConflictType.CONTENT_MODIFIED:\n        return `Content in field \"${conflict.field}\" was modified in both local and remote versions`;\n\n      case ConflictType.STATUS_CHANGED:\n        return `Status \"${conflict.field}\" was changed: local=${conflict.localValue}, remote=${conflict.remoteValue}`;\n\n      case ConflictType.TAGS_UPDATED:\n        return `Tags were updated: local=[${conflict.localValue?.join(', ') || ''}], remote=[${conflict.remoteValue?.join(', ') || ''}]`;\n\n      default:\n        return `Field \"${conflict.field}\" has conflicting values`;\n    }\n  });\n}\n\n/**\n * Export utility functions for external use\n */\nexport const ConflictResolutionUtils = {\n  resolveConflict,\n  detectConflicts,\n  mergeArticles,\n  validateResolution,\n  describeConflicts,\n  createConflictResolutionResult,\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/utils/connectivityManager.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":92,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":92,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2678,2746],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":98,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":98,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2955,3040],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":107,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":107,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3266,3336],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":113,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":113,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3434,3503],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":126,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":126,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4069,4126],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":131,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4299,4302],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4299,4302],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":134,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":134,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4356,4551],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":154,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":154,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5278,5345],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":160,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":160,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5569,5650],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":165,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":165,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[5739,5821],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":239,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":239,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7681,7684],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7681,7684],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import NetInfo, { NetInfoState } from '@react-native-community/netinfo';\nimport { logger } from './logger';\nimport { readeckApiService } from '../services/ReadeckApiService';\n\nexport enum ConnectivityStatus {\n  ONLINE = 'online',\n  OFFLINE = 'offline',\n  SERVER_UNREACHABLE = 'server_unreachable',\n  CHECKING = 'checking',\n}\n\ninterface ConnectivityState {\n  networkConnected: boolean;\n  serverReachable: boolean;\n  status: ConnectivityStatus;\n  lastCheckTime: Date;\n  consecutiveFailures: number;\n}\n\nclass ConnectivityManager {\n  private static instance: ConnectivityManager;\n  private listeners: { [event: string]: Function[] } = {};\n  private state: ConnectivityState = {\n    networkConnected: true,\n    serverReachable: true,\n    status: ConnectivityStatus.ONLINE,\n    lastCheckTime: new Date(),\n    consecutiveFailures: 0,\n  };\n  \n  private checkInterval: NodeJS.Timeout | null = null;\n  private readonly CHECK_INTERVAL = 30000; // 30 seconds\n  private readonly MAX_CONSECUTIVE_FAILURES = 3;\n  private readonly QUICK_CHECK_TIMEOUT = 5000; // 5 seconds\n  \n  private constructor() {\n    this.initializeNetworkListener();\n  }\n  \n  static getInstance(): ConnectivityManager {\n    if (!ConnectivityManager.instance) {\n      ConnectivityManager.instance = new ConnectivityManager();\n    }\n    return ConnectivityManager.instance;\n  }\n  \n  private initializeNetworkListener() {\n    // Listen for network state changes\n    NetInfo.addEventListener((state: NetInfoState) => {\n      this.handleNetworkStateChange(state);\n    });\n    \n    // Initial check\n    this.checkConnectivity();\n    \n    // Start periodic checks\n    this.startPeriodicChecks();\n  }\n  \n  private handleNetworkStateChange(state: NetInfoState) {\n    const wasConnected = this.state.networkConnected;\n    this.state.networkConnected = state.isConnected ?? false;\n    \n    logger.debug('[ConnectivityManager] Network state changed:', {\n      isConnected: state.isConnected,\n      type: state.type,\n      isInternetReachable: state.isInternetReachable,\n    });\n    \n    if (!wasConnected && this.state.networkConnected) {\n      // Network reconnected, check server immediately\n      this.checkConnectivity();\n    } else if (wasConnected && !this.state.networkConnected) {\n      // Network disconnected\n      this.updateStatus(ConnectivityStatus.OFFLINE);\n    }\n  }\n  \n  private startPeriodicChecks() {\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n    }\n    \n    this.checkInterval = setInterval(() => {\n      if (this.state.networkConnected) {\n        this.checkServerReachability();\n      }\n    }, this.CHECK_INTERVAL);\n  }\n  \n  async checkConnectivity(): Promise<ConnectivityStatus> {\n    console.log('[ConnectivityManager] Starting connectivity check...');\n    this.updateStatus(ConnectivityStatus.CHECKING);\n    \n    // First check network connectivity\n    const netInfo = await NetInfo.fetch();\n    this.state.networkConnected = netInfo.isConnected ?? false;\n    console.log('[ConnectivityManager] Network connected:', this.state.networkConnected);\n    \n    if (!this.state.networkConnected) {\n      this.updateStatus(ConnectivityStatus.OFFLINE);\n      return this.state.status;\n    }\n    \n    // Then check server reachability\n    await this.checkServerReachability();\n    console.log('[ConnectivityManager] Final status:', this.state.status);\n    return this.state.status;\n  }\n  \n  private async checkServerReachability() {\n    try {\n      console.log('[ConnectivityManager] Checking server reachability...');\n      // Use a lightweight endpoint for connectivity check\n      const controller = new AbortController();\n      \n      // Set a short timeout for connectivity check\n      const timeoutId = setTimeout(() => controller.abort(), this.QUICK_CHECK_TIMEOUT);\n      \n      try {\n        // Try to validate token as a connectivity check with short timeout\n        // This calls the /profile endpoint which is a good way to check server connectivity\n        await readeckApiService.validateToken(this.QUICK_CHECK_TIMEOUT);\n        clearTimeout(timeoutId);\n        \n        console.log('[ConnectivityManager] Server is reachable');\n        this.state.serverReachable = true;\n        this.state.consecutiveFailures = 0;\n        this.updateStatus(ConnectivityStatus.ONLINE);\n        \n      } catch (error: any) {\n        clearTimeout(timeoutId);\n        \n        console.log('[ConnectivityManager] Server check failed:', { \n          code: error.code, \n          message: error.message, \n          name: error.name,\n          status: error.status\n        });\n        \n        // Handle different error types\n        if (error.code === 'CONNECTION_ERROR' || \n            error.code === 'ECONNREFUSED' || \n            error.code === 'ECONNRESET' ||\n            error.message?.includes('Network request failed') ||\n            error.message?.includes('Connection refused') ||\n            error.message?.includes('ECONNREFUSED') ||\n            error.message?.includes('fetch failed') ||\n            error.name === 'AbortError' ||\n            error.name === 'TypeError') {\n          this.handleServerUnreachable();\n        } else if (error.status === 401 || error.code === 'AUTHENTICATION_ERROR') {\n          // Authentication error means server is reachable but token is invalid\n          console.log('[ConnectivityManager] Server reachable (auth error)');\n          this.state.serverReachable = true;\n          this.state.consecutiveFailures = 0;\n          this.updateStatus(ConnectivityStatus.ONLINE);\n        } else {\n          // Other errors, treat as server issue\n          console.log('[ConnectivityManager] Other error, treating as server unreachable');\n          this.handleServerUnreachable();\n        }\n      }\n    } catch (error) {\n      console.error('[ConnectivityManager] Error checking server reachability:', error);\n      this.handleServerUnreachable();\n    }\n  }\n  \n  private handleServerUnreachable() {\n    this.state.serverReachable = false;\n    this.state.consecutiveFailures++;\n    \n    // Always set status to SERVER_UNREACHABLE immediately when server is unreachable\n    this.updateStatus(ConnectivityStatus.SERVER_UNREACHABLE);\n  }\n  \n  private updateStatus(newStatus: ConnectivityStatus) {\n    const oldStatus = this.state.status;\n    this.state.status = newStatus;\n    this.state.lastCheckTime = new Date();\n    \n    if (oldStatus !== newStatus) {\n      logger.info(`[ConnectivityManager] Status changed: ${oldStatus} -> ${newStatus}`);\n      this.emit('statusChanged', newStatus, oldStatus);\n    }\n  }\n  \n  getStatus(): ConnectivityStatus {\n    return this.state.status;\n  }\n  \n  isOnline(): boolean {\n    return this.state.status === ConnectivityStatus.ONLINE;\n  }\n  \n  isOffline(): boolean {\n    return this.state.status === ConnectivityStatus.OFFLINE || \n           this.state.status === ConnectivityStatus.SERVER_UNREACHABLE;\n  }\n  \n  getState(): Readonly<ConnectivityState> {\n    return { ...this.state };\n  }\n  \n  /**\n   * Force an immediate connectivity check\n   */\n  async forceCheck(): Promise<ConnectivityStatus> {\n    logger.debug('[ConnectivityManager] Forcing connectivity check');\n    return this.checkConnectivity();\n  }\n  \n  /**\n   * Add event listener\n   */\n  on(event: string, listener: Function) {\n    if (!this.listeners[event]) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event].push(listener);\n  }\n\n  /**\n   * Remove event listener\n   */\n  off(event: string, listener: Function) {\n    if (this.listeners[event]) {\n      const index = this.listeners[event].indexOf(listener);\n      if (index > -1) {\n        this.listeners[event].splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Emit event\n   */\n  emit(event: string, ...args: any[]) {\n    if (this.listeners[event]) {\n      this.listeners[event].forEach(listener => listener(...args));\n    }\n  }\n\n  /**\n   * Remove all listeners\n   */\n  removeAllListeners() {\n    this.listeners = {};\n  }\n\n  /**\n   * Clean up resources\n   */\n  dispose() {\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n      this.checkInterval = null;\n    }\n    this.removeAllListeners();\n  }\n}\n\nexport const connectivityManager = ConnectivityManager.getInstance();","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/utils/errorHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[672,675],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[672,675],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[989,992],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[989,992],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1128,1131],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1128,1131],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":83,"column":36,"nodeType":"MemberExpression","messageId":"unexpected","endLine":83,"endColumn":49},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":84,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":84,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2023,2026],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2023,2026],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2766,2769],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2766,2769],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":124,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3119,3122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3119,3122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":165,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4391,4394],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4391,4394],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":197,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5282,5285],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5282,5285],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":217,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":217,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5841,5844],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5841,5844],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'code' is defined but never used. Allowed unused args must match /^_/u.","line":225,"column":59,"nodeType":null,"messageId":"unusedVar","endLine":225,"endColumn":63},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":239,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":239,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7113,7116],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7113,7116],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":269,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":269,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7824,7827],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7824,7827],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":269,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":269,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7846,7849],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7846,7849],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":363,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":363,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10769,10831],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":372,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":372,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11019,11022],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11019,11022],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":381,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":381,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11238,11241],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11238,11241],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":390,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":390,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11456,11459],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11456,11459],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Centralized Error Handling Service for Mobdeck\n * Production-ready error classification, reporting, and user-friendly messaging\n */\n\nimport { logger } from './logger';\n\nexport enum ErrorCategory {\n  NETWORK = 'NETWORK',\n  AUTHENTICATION = 'AUTHENTICATION',\n  VALIDATION = 'VALIDATION',\n  STORAGE = 'STORAGE',\n  SYNC = 'SYNC',\n  RUNTIME = 'RUNTIME',\n  UNKNOWN = 'UNKNOWN',\n}\n\nexport enum ErrorSeverity {\n  LOW = 'LOW',\n  MEDIUM = 'MEDIUM',\n  HIGH = 'HIGH',\n  CRITICAL = 'CRITICAL',\n}\n\nexport interface AppError {\n  id: string;\n  category: ErrorCategory;\n  severity: ErrorSeverity;\n  code: string;\n  message: string;\n  userMessage: string;\n  details?: Record<string, any>;\n  stack?: string;\n  timestamp: string;\n  context?: ErrorContext;\n  retryable: boolean;\n  reportable: boolean;\n}\n\nexport interface ErrorContext {\n  userId?: string;\n  serverUrl?: string;\n  actionType?: string;\n  screenName?: string;\n  apiEndpoint?: string;\n  networkState?: string;\n  deviceInfo?: Record<string, any>;\n}\n\nexport interface ErrorReport {\n  errorId: string;\n  sanitizedError: Omit<AppError, 'context'>;\n  sanitizedContext: Record<string, any>;\n  breadcrumbs: string[];\n  sessionId: string;\n}\n\nclass ErrorHandler {\n  private static instance: ErrorHandler;\n  private breadcrumbs: string[] = [];\n  private sessionId: string;\n  private readonly maxBreadcrumbs = 50;\n\n  private constructor() {\n    this.sessionId = this.generateSessionId();\n    this.setupGlobalErrorHandlers();\n  }\n\n  public static getInstance(): ErrorHandler {\n    if (!ErrorHandler.instance) {\n      ErrorHandler.instance = new ErrorHandler();\n    }\n    return ErrorHandler.instance;\n  }\n\n  private generateSessionId(): string {\n    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private setupGlobalErrorHandlers(): void {\n    if (typeof global !== 'undefined') {\n      // Only add breadcrumb without intercepting console.error to avoid double logging\n      const originalConsoleError = console.error;\n      console.error = (...args: any[]) => {\n        this.addBreadcrumb(`Console Error: ${args.join(' ')}`);\n        originalConsoleError.apply(console, args);\n      };\n\n      global.ErrorUtils?.setGlobalHandler?.((error: Error, isFatal: boolean) => {\n        this.handleError(error, {\n          category: ErrorCategory.RUNTIME,\n          severity: isFatal ? ErrorSeverity.CRITICAL : ErrorSeverity.HIGH,\n          context: { isFatal },\n        });\n      });\n    }\n  }\n\n  public addBreadcrumb(message: string): void {\n    const timestamp = new Date().toISOString();\n    this.breadcrumbs.push(`[${timestamp}] ${message}`);\n    \n    if (this.breadcrumbs.length > this.maxBreadcrumbs) {\n      this.breadcrumbs.shift();\n    }\n  }\n\n  public handleError(\n    error: Error | string | any,\n    options: Partial<AppError> = {}\n  ): AppError {\n    const appError = this.createAppError(error, options);\n    \n    this.logError(appError);\n    \n    if (appError.reportable && appError.severity !== ErrorSeverity.LOW) {\n      this.reportError(appError);\n    }\n    \n    return appError;\n  }\n\n  private createAppError(\n    error: Error | string | any,\n    options: Partial<AppError>\n  ): AppError {\n    const id = `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    const timestamp = new Date().toISOString();\n    \n    let message: string;\n    let stack: string | undefined;\n    \n    if (error instanceof Error) {\n      message = error.message;\n      stack = error.stack;\n    } else if (typeof error === 'string') {\n      message = error;\n    } else {\n      message = 'Unknown error occurred';\n    }\n\n    const category = options.category || this.categorizeError(error);\n    const severity = options.severity || this.determineSeverity(category, error);\n    const code = options.code || this.generateErrorCode(category, error);\n    const userMessage = options.userMessage || this.getUserFriendlyMessage(category, code);\n    const retryable = options.retryable ?? this.isRetryable(category, error);\n    const reportable = options.reportable ?? this.isReportable(category, severity);\n\n    return {\n      id,\n      category,\n      severity,\n      code,\n      message,\n      userMessage,\n      details: this.sanitizeDetails(options.details),\n      stack,\n      timestamp,\n      context: this.sanitizeContext(options.context),\n      retryable,\n      reportable,\n    };\n  }\n\n  private categorizeError(error: any): ErrorCategory {\n    if (error?.code === 'NETWORK_ERROR' || error?.message?.includes('network')) {\n      return ErrorCategory.NETWORK;\n    }\n    \n    if (error?.status === 401 || error?.code === 'AUTH_ERROR') {\n      return ErrorCategory.AUTHENTICATION;\n    }\n    \n    if (error?.status === 404 || error?.code === 'NOT_FOUND') {\n      return ErrorCategory.VALIDATION;\n    }\n    \n    if (error?.status >= 400 && error?.status < 500) {\n      return ErrorCategory.VALIDATION;\n    }\n    \n    if (error?.message?.includes('storage') || error?.message?.includes('database')) {\n      return ErrorCategory.STORAGE;\n    }\n    \n    if (error?.message?.includes('sync')) {\n      return ErrorCategory.SYNC;\n    }\n    \n    if (error instanceof Error) {\n      return ErrorCategory.RUNTIME;\n    }\n    \n    return ErrorCategory.UNKNOWN;\n  }\n\n  private determineSeverity(category: ErrorCategory, error: any): ErrorSeverity {\n    if (category === ErrorCategory.AUTHENTICATION) {\n      return ErrorSeverity.HIGH;\n    }\n    \n    if (category === ErrorCategory.STORAGE && error?.message?.includes('critical')) {\n      return ErrorSeverity.CRITICAL;\n    }\n    \n    if (category === ErrorCategory.NETWORK && error?.status >= 500) {\n      return ErrorSeverity.MEDIUM;\n    }\n    \n    if (category === ErrorCategory.VALIDATION) {\n      return ErrorSeverity.LOW;\n    }\n    \n    return ErrorSeverity.MEDIUM;\n  }\n\n  private generateErrorCode(category: ErrorCategory, error: any): string {\n    const categoryPrefix = category.substr(0, 3).toUpperCase();\n    const timestamp = Date.now().toString().substr(-6);\n    const errorType = error?.name || error?.code || 'UNKNOWN';\n    \n    return `${categoryPrefix}_${errorType}_${timestamp}`;\n  }\n\n  private getUserFriendlyMessage(category: ErrorCategory, code: string): string {\n    const messages: Record<ErrorCategory, string> = {\n      [ErrorCategory.NETWORK]: 'Unable to connect to the server. Please check your internet connection and try again.',\n      [ErrorCategory.AUTHENTICATION]: 'Authentication failed. Please check your credentials and try logging in again.',\n      [ErrorCategory.VALIDATION]: 'Please check your input and try again.',\n      [ErrorCategory.STORAGE]: 'Unable to save data locally. Please ensure you have sufficient storage space.',\n      [ErrorCategory.SYNC]: 'Synchronization failed. Your changes will be synced when connection is restored.',\n      [ErrorCategory.RUNTIME]: 'An unexpected error occurred. Please restart the app if the problem persists.',\n      [ErrorCategory.UNKNOWN]: 'Something went wrong. Please try again or contact support if the issue continues.',\n    };\n    \n    return messages[category];\n  }\n\n  private isRetryable(category: ErrorCategory, error: any): boolean {\n    const retryableCategories = [\n      ErrorCategory.NETWORK,\n      ErrorCategory.SYNC,\n    ];\n    \n    if (retryableCategories.includes(category)) {\n      return true;\n    }\n    \n    if (error?.status >= 500 && error?.status < 600) {\n      return true;\n    }\n    \n    if (error?.code === 'TIMEOUT_ERROR') {\n      return true;\n    }\n    \n    return false;\n  }\n\n  private isReportable(category: ErrorCategory, severity: ErrorSeverity): boolean {\n    if (severity === ErrorSeverity.LOW) {\n      return false;\n    }\n    \n    const nonReportableCategories = [ErrorCategory.VALIDATION];\n    return !nonReportableCategories.includes(category);\n  }\n\n  private sanitizeDetails(details?: Record<string, any>): Record<string, any> | undefined {\n    if (!details) return undefined;\n    \n    const sanitized = { ...details };\n    const sensitiveKeys = ['password', 'token', 'authorization', 'secret', 'key', 'credential'];\n    \n    Object.keys(sanitized).forEach(key => {\n      if (sensitiveKeys.some(sensitive => key.toLowerCase().includes(sensitive))) {\n        sanitized[key] = '[REDACTED]';\n      }\n    });\n    \n    return sanitized;\n  }\n\n  private sanitizeContext(context?: ErrorContext): ErrorContext | undefined {\n    if (!context) return undefined;\n    \n    const sanitized = { ...context };\n    \n    if (sanitized.serverUrl) {\n      try {\n        const url = new URL(sanitized.serverUrl);\n        sanitized.serverUrl = `${url.protocol}//${url.hostname}${url.port ? `:${  url.port}` : ''}`;\n      } catch {\n        sanitized.serverUrl = '[INVALID_URL]';\n      }\n    }\n    \n    if (sanitized.userId) {\n      sanitized.userId = sanitized.userId.length > 0 ? '[USER_ID_PRESENT]' : '[NO_USER_ID]';\n    }\n    \n    return sanitized;\n  }\n\n  private logError(appError: AppError): void {\n    const logLevel = this.getLogLevel(appError.severity);\n    \n    // For sync operations and network errors, just log the message without full object details\n    if (appError.category === ErrorCategory.SYNC_OPERATION || \n        appError.category === ErrorCategory.NETWORK) {\n      const operation = appError.context?.actionType || appError.category.toLowerCase();\n      logger.log(logLevel, `[${operation}] ${appError.message}`);\n    } else {\n      logger.log(logLevel, 'Error handled', {\n        errorId: appError.id,\n        category: appError.category,\n        severity: appError.severity,\n        code: appError.code,\n        message: appError.message,\n        retryable: appError.retryable,\n        context: appError.context,\n      });\n    }\n  }\n\n  private getLogLevel(severity: ErrorSeverity): 'debug' | 'info' | 'warn' | 'error' {\n    switch (severity) {\n      case ErrorSeverity.LOW:\n        return 'debug';\n      case ErrorSeverity.MEDIUM:\n        return 'warn';\n      case ErrorSeverity.HIGH:\n      case ErrorSeverity.CRITICAL:\n        return 'error';\n      default:\n        return 'error';\n    }\n  }\n\n  private reportError(appError: AppError): void {\n    try {\n      const report: ErrorReport = {\n        errorId: appError.id,\n        sanitizedError: {\n          id: appError.id,\n          category: appError.category,\n          severity: appError.severity,\n          code: appError.code,\n          message: appError.message,\n          userMessage: appError.userMessage,\n          details: appError.details,\n          stack: appError.stack,\n          timestamp: appError.timestamp,\n          retryable: appError.retryable,\n          reportable: appError.reportable,\n        },\n        sanitizedContext: appError.context || {},\n        breadcrumbs: [...this.breadcrumbs],\n        sessionId: this.sessionId,\n      };\n      \n      if (__DEV__) {\n        console.log('[ErrorHandler] Error report generated:', report);\n      }\n      \n    } catch (reportingError) {\n      logger.error('Failed to generate error report', { reportingError });\n    }\n  }\n\n  public getNetworkErrorHandler() {\n    return (error: any) => {\n      return this.handleError(error, {\n        category: ErrorCategory.NETWORK,\n        context: { actionType: 'network_request' },\n      });\n    };\n  }\n\n  public getStorageErrorHandler() {\n    return (error: any) => {\n      return this.handleError(error, {\n        category: ErrorCategory.STORAGE,\n        context: { actionType: 'storage_operation' },\n      });\n    };\n  }\n\n  public getSyncErrorHandler() {\n    return (error: any) => {\n      return this.handleError(error, {\n        category: ErrorCategory.SYNC,\n        context: { actionType: 'sync_operation' },\n      });\n    };\n  }\n\n  public createReduxErrorAction(error: AppError) {\n    return {\n      type: 'error/errorOccurred',\n      payload: {\n        id: error.id,\n        message: error.userMessage,\n        category: error.category,\n        severity: error.severity,\n        retryable: error.retryable,\n        timestamp: error.timestamp,\n      },\n    };\n  }\n\n  public getBreadcrumbs(): string[] {\n    return [...this.breadcrumbs];\n  }\n\n  public clearBreadcrumbs(): void {\n    this.breadcrumbs = [];\n  }\n\n  public getSessionId(): string {\n    return this.sessionId;\n  }\n}\n\nexport const errorHandler = ErrorHandler.getInstance();\nexport default errorHandler;","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/utils/helpers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[300,303],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[300,303],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":4,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":7,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[328,331],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[328,331],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[639,642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[639,642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export const formatDate = (dateString: string): string => {\n  const options: Intl.DateTimeFormatOptions = {\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n  };\n  return new Date(dateString).toLocaleDateString(undefined, options);\n};\n\nexport const filterArticlesByKeyword = (\n  articles: any[],\n  keyword: string\n): any[] => {\n  return articles.filter(\n    article =>\n      article.title.toLowerCase().includes(keyword.toLowerCase()) ||\n      article.summary.toLowerCase().includes(keyword.toLowerCase())\n  );\n};\n\nexport const debounce = (func: Function, delay: number) => {\n  let timeoutId: NodeJS.Timeout;\n  return (...args: any[]) => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      func(...args);\n    }, delay);\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/utils/logger.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[440,443],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[440,443],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1115,1118],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1115,1118],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":111,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":111,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[2747,2801],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":123,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3100,3103],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3100,3103],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3210,3213],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3210,3213],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":131,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3319,3322],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3319,3322],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":135,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3429,3432],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3429,3432],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":139,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3540,3543],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3540,3543],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":143,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3666,3669],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3666,3669],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":156,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":156,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[3975,4034],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":168,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":168,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4282,4285],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4282,4285],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":176,"column":17,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":176,"endColumn":39},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":177,"column":16,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":177,"endColumn":37},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":194,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":194,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4920,4923],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4920,4923],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":194,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":194,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4942,4945],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4942,4945],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":197,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5022,5025],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5022,5025],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":197,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5039,5042],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5039,5042],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":208,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5326,5329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5326,5329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":231,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":231,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"debug"},"fix":{"range":[5967,5999],"text":""},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":234,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":234,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"info"},"fix":{"range":[6042,6073],"text":""},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":237,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":237,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[6116,6147],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":241,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":241,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[6211,6243],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":244,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":244,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6282,6312],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":257,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":257,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[6698,6746],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":298,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":298,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[7909,7972],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":322,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":322,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8509,8512],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8509,8512],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":374,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":374,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[9916,9983],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":27,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Centralized Logging Service for Mobdeck\n * Production-ready logging with configurable levels, storage rotation, and performance optimization\n */\n\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { Platform } from 'react-native';\n\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'fatal';\n\nexport interface LogEntry {\n  id: string;\n  level: LogLevel;\n  message: string;\n  data?: Record<string, any>;\n  timestamp: string;\n  context: LogContext;\n}\n\nexport interface LogContext {\n  sessionId?: string;\n  userId?: string;\n  screenName?: string;\n  actionType?: string;\n  platform: string;\n  version: string;\n  networkState?: string;\n  memoryUsage?: number;\n}\n\nexport interface LoggerConfig {\n  level: LogLevel;\n  enableConsole: boolean;\n  enableStorage: boolean;\n  enablePerformanceLogging: boolean;\n  maxStorageSize: number; // in bytes\n  maxStorageEntries: number;\n  rotationThreshold: number; // percentage (0-100)\n  sensitiveKeys: string[];\n}\n\nexport interface PerformanceMetric {\n  operation: string;\n  duration: number;\n  timestamp: string;\n  context?: Record<string, any>;\n}\n\nclass Logger {\n  private static instance: Logger;\n  private config: LoggerConfig;\n  private context: Partial<LogContext>;\n  private performanceMarks: Map<string, number> = new Map();\n  private storageKey = '@mobdeck_logs';\n  private performanceKey = '@mobdeck_performance';\n\n  private readonly levelPriority: Record<LogLevel, number> = {\n    debug: 0,\n    info: 1,\n    warn: 2,\n    error: 3,\n    fatal: 4,\n  };\n\n  private constructor() {\n    this.config = this.getDefaultConfig();\n    this.context = this.getDefaultContext();\n    this.initialize();\n  }\n\n  public static getInstance(): Logger {\n    if (!Logger.instance) {\n      Logger.instance = new Logger();\n    }\n    return Logger.instance;\n  }\n\n  private getDefaultConfig(): LoggerConfig {\n    return {\n      level: (typeof __DEV__ !== 'undefined' && __DEV__) ? 'debug' : 'warn',\n      enableConsole: (typeof __DEV__ !== 'undefined' && __DEV__),\n      enableStorage: true,\n      enablePerformanceLogging: (typeof __DEV__ !== 'undefined' && __DEV__),\n      maxStorageSize: 1024 * 1024 * 2, // 2MB\n      maxStorageEntries: 1000,\n      rotationThreshold: 80, // 80%\n      sensitiveKeys: [\n        'password',\n        'token',\n        'authorization',\n        'secret',\n        'key',\n        'credential',\n        'bearer',\n        'session',\n      ],\n    };\n  }\n\n  private getDefaultContext(): Partial<LogContext> {\n    return {\n      platform: Platform.OS,\n      version: '1.0.0', // Should be read from package.json or build config\n    };\n  }\n\n  private async initialize(): Promise<void> {\n    try {\n      await this.checkStorageRotation();\n    } catch (error) {\n      console.warn('[Logger] Failed to initialize:', error);\n    }\n  }\n\n  public updateConfig(config: Partial<LoggerConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n\n  public updateContext(context: Partial<LogContext>): void {\n    this.context = { ...this.context, ...context };\n  }\n\n  public debug(message: string, data?: Record<string, any>): void {\n    this.log('debug', message, data);\n  }\n\n  public info(message: string, data?: Record<string, any>): void {\n    this.log('info', message, data);\n  }\n\n  public warn(message: string, data?: Record<string, any>): void {\n    this.log('warn', message, data);\n  }\n\n  public error(message: string, data?: Record<string, any>): void {\n    this.log('error', message, data);\n  }\n\n  public fatal(message: string, data?: Record<string, any>): void {\n    this.log('fatal', message, data);\n  }\n\n  public log(level: LogLevel, message: string, data?: Record<string, any>): void {\n    if (!this.shouldLog(level)) {\n      return;\n    }\n\n    const logEntry = this.createLogEntry(level, message, data);\n\n    if (this.config.enableConsole) {\n      this.logToConsole(logEntry);\n    }\n\n    if (this.config.enableStorage) {\n      this.logToStorage(logEntry).catch(error => {\n        console.warn('[Logger] Failed to store log entry:', error);\n      });\n    }\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    return this.levelPriority[level] >= this.levelPriority[this.config.level];\n  }\n\n  private createLogEntry(\n    level: LogLevel,\n    message: string,\n    data?: Record<string, any>\n  ): LogEntry {\n    const id = `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    const timestamp = new Date().toISOString();\n    const sanitizedData = data ? this.sanitizeData(data) : undefined;\n    \n    const context: LogContext = {\n      ...this.context,\n      platform: this.context.platform!,\n      version: this.context.version!,\n    };\n\n    if (this.config.enablePerformanceLogging) {\n      context.memoryUsage = this.getMemoryUsage();\n    }\n\n    return {\n      id,\n      level,\n      message,\n      data: sanitizedData,\n      timestamp,\n      context,\n    };\n  }\n\n  private sanitizeData(data: Record<string, any>): Record<string, any> {\n    const sanitized = { ...data };\n    \n    const sanitizeObject = (obj: any, depth = 0): any => {\n      if (depth > 5) return '[MAX_DEPTH_REACHED]';\n      \n      if (obj === null || typeof obj !== 'object') {\n        return obj;\n      }\n      \n      if (Array.isArray(obj)) {\n        return obj.map(item => sanitizeObject(item, depth + 1));\n      }\n      \n      const result: any = {};\n      Object.keys(obj).forEach(key => {\n        if (this.config.sensitiveKeys.some(sensitive => \n          key.toLowerCase().includes(sensitive.toLowerCase())\n        )) {\n          result[key] = '[REDACTED]';\n        } else {\n          result[key] = sanitizeObject(obj[key], depth + 1);\n        }\n      });\n      \n      return result;\n    };\n    \n    return sanitizeObject(sanitized);\n  }\n\n  private logToConsole(logEntry: LogEntry): void {\n    const { level, message, data, timestamp } = logEntry;\n    const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;\n    \n    switch (level) {\n      case 'debug':\n        console.debug(logMessage, data);\n        break;\n      case 'info':\n        console.info(logMessage, data);\n        break;\n      case 'warn':\n        console.warn(logMessage, data);\n        break;\n      case 'error':\n      case 'fatal':\n        console.error(logMessage, data);\n        break;\n      default:\n        console.log(logMessage, data);\n    }\n  }\n\n  private async logToStorage(logEntry: LogEntry): Promise<void> {\n    try {\n      const existingLogs = await this.getStoredLogs();\n      const updatedLogs = [...existingLogs, logEntry];\n      \n      await this.checkAndRotateLogs(updatedLogs);\n      await AsyncStorage.setItem(this.storageKey, JSON.stringify(updatedLogs));\n    } catch (error) {\n      if (__DEV__) {\n        console.error('[Logger] Storage error:', error);\n      }\n    }\n  }\n\n  private async getStoredLogs(): Promise<LogEntry[]> {\n    try {\n      const storedLogs = await AsyncStorage.getItem(this.storageKey);\n      return storedLogs ? JSON.parse(storedLogs) : [];\n    } catch (error) {\n      return [];\n    }\n  }\n\n  private async checkAndRotateLogs(logs: LogEntry[]): Promise<LogEntry[]> {\n    if (logs.length <= this.config.maxStorageEntries) {\n      return logs;\n    }\n    \n    const rotateCount = Math.floor(logs.length * (this.config.rotationThreshold / 100));\n    const rotatedLogs = logs.slice(rotateCount);\n    \n    this.debug('Log rotation performed', {\n      originalCount: logs.length,\n      rotatedCount: rotatedLogs.length,\n      removedCount: rotateCount,\n    });\n    \n    return rotatedLogs;\n  }\n\n  private async checkStorageRotation(): Promise<void> {\n    try {\n      const logs = await this.getStoredLogs();\n      const logsSize = JSON.stringify(logs).length;\n      \n      if (logsSize > this.config.maxStorageSize) {\n        const rotatedLogs = await this.checkAndRotateLogs(logs);\n        await AsyncStorage.setItem(this.storageKey, JSON.stringify(rotatedLogs));\n      }\n    } catch (error) {\n      console.warn('[Logger] Storage rotation check failed:', error);\n    }\n  }\n\n  private getMemoryUsage(): number {\n    try {\n      if (global.performance?.memory) {\n        return global.performance.memory.usedJSHeapSize;\n      }\n    } catch (error) {\n      // Memory API not available\n    }\n    return 0;\n  }\n\n  // Performance logging methods\n  public startPerformanceTimer(operation: string): void {\n    if (!this.config.enablePerformanceLogging) return;\n    \n    this.performanceMarks.set(operation, Date.now());\n  }\n\n  public endPerformanceTimer(\n    operation: string,\n    context?: Record<string, any>\n  ): void {\n    if (!this.config.enablePerformanceLogging) return;\n    \n    const startTime = this.performanceMarks.get(operation);\n    if (!startTime) {\n      this.warn('Performance timer not found', { operation });\n      return;\n    }\n    \n    const duration = Date.now() - startTime;\n    this.performanceMarks.delete(operation);\n    \n    const metric: PerformanceMetric = {\n      operation,\n      duration,\n      timestamp: new Date().toISOString(),\n      context: context ? this.sanitizeData(context) : undefined,\n    };\n    \n    this.logPerformanceMetric(metric);\n    \n    this.debug('Performance metric recorded', {\n      operation,\n      duration,\n      context,\n    });\n    \n    // Log slow operations as warning\n    if (duration > 1000) { // > 1 second\n      this.warn('Slow operation detected', {\n        operation,\n        duration: `${duration}ms`,\n        context,\n      });\n    }\n  }\n\n  private async logPerformanceMetric(metric: PerformanceMetric): Promise<void> {\n    try {\n      const existingMetrics = await this.getStoredPerformanceMetrics();\n      const updatedMetrics = [...existingMetrics, metric];\n      \n      // Keep only last 100 performance metrics\n      const trimmedMetrics = updatedMetrics.slice(-100);\n      \n      await AsyncStorage.setItem(\n        this.performanceKey,\n        JSON.stringify(trimmedMetrics)\n      );\n    } catch (error) {\n      if (__DEV__) {\n        console.error('[Logger] Performance metric storage error:', error);\n      }\n    }\n  }\n\n  private async getStoredPerformanceMetrics(): Promise<PerformanceMetric[]> {\n    try {\n      const storedMetrics = await AsyncStorage.getItem(this.performanceKey);\n      return storedMetrics ? JSON.parse(storedMetrics) : [];\n    } catch (error) {\n      return [];\n    }\n  }\n\n  // Log retrieval methods for debugging\n  public async getLogs(\n    level?: LogLevel,\n    limit?: number\n  ): Promise<LogEntry[]> {\n    try {\n      const logs = await this.getStoredLogs();\n      \n      let filteredLogs = logs;\n      \n      if (level) {\n        filteredLogs = logs.filter(log => log.level === level);\n      }\n      \n      if (limit) {\n        filteredLogs = filteredLogs.slice(-limit);\n      }\n      \n      return filteredLogs;\n    } catch (error) {\n      this.error('Failed to retrieve logs', { error });\n      return [];\n    }\n  }\n\n  public async getPerformanceMetrics(limit?: number): Promise<PerformanceMetric[]> {\n    try {\n      const metrics = await this.getStoredPerformanceMetrics();\n      return limit ? metrics.slice(-limit) : metrics;\n    } catch (error) {\n      this.error('Failed to retrieve performance metrics', { error });\n      return [];\n    }\n  }\n\n  public async clearLogs(): Promise<boolean> {\n    try {\n      await AsyncStorage.removeItem(this.storageKey);\n      await AsyncStorage.removeItem(this.performanceKey);\n      return true;\n    } catch (error) {\n      this.error('Failed to clear logs', { error });\n      return false;\n    }\n  }\n\n  public async exportLogs(): Promise<string | null> {\n    try {\n      const logs = await this.getStoredLogs();\n      const metrics = await this.getStoredPerformanceMetrics();\n      \n      const exportData = {\n        logs,\n        performanceMetrics: metrics,\n        exportTimestamp: new Date().toISOString(),\n        config: {\n          level: this.config.level,\n          platform: this.context.platform,\n          version: this.context.version,\n        },\n      };\n      \n      return JSON.stringify(exportData, null, 2);\n    } catch (error) {\n      this.error('Failed to export logs', { error });\n      return null;\n    }\n  }\n}\n\nexport const logger = Logger.getInstance();\nexport default logger;","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/utils/performanceTestHelper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[182,185],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[182,185],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[789,792],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[789,792],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1713,1716],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1713,1716],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2240,2243],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2240,2243],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":211,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":211,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6049,6052],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6049,6052],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { logger } from './logger';\n\ninterface PerformanceMetrics {\n  operationName: string;\n  duration: number;\n  memoryUsed?: number;\n  timestamp: Date;\n  metadata?: Record<string, any>;\n}\n\ninterface PerformanceThresholds {\n  maxDuration: number;\n  maxMemoryUsage?: number;\n}\n\nclass PerformanceTestHelper {\n  private metrics: PerformanceMetrics[] = [];\n  private activeTimers: Map<string, number> = new Map();\n\n  /**\n   * Start timing an operation\n   */\n  startOperation(operationName: string): void {\n    const startTime = performance.now();\n    this.activeTimers.set(operationName, startTime);\n    logger.info(`Performance test started: ${operationName}`);\n  }\n\n  /**\n   * End timing an operation and record metrics\n   */\n  endOperation(operationName: string, metadata?: Record<string, any>): PerformanceMetrics {\n    const startTime = this.activeTimers.get(operationName);\n    if (!startTime) {\n      throw new Error(`No active timer found for operation: ${operationName}`);\n    }\n\n    const duration = performance.now() - startTime;\n    const memoryUsed = this.getCurrentMemoryUsage();\n\n    const metrics: PerformanceMetrics = {\n      operationName,\n      duration,\n      memoryUsed,\n      timestamp: new Date(),\n      metadata,\n    };\n\n    this.metrics.push(metrics);\n    this.activeTimers.delete(operationName);\n\n    logger.info(`Performance test completed: ${operationName}`, {\n      duration: `${duration.toFixed(2)}ms`,\n      memory: memoryUsed ? `${(memoryUsed / 1024 / 1024).toFixed(2)}MB` : 'N/A',\n    });\n\n    return metrics;\n  }\n\n  /**\n   * Measure async operation performance\n   */\n  async measureAsync<T>(\n    operationName: string,\n    operation: () => Promise<T>,\n    metadata?: Record<string, any>\n  ): Promise<{ result: T; metrics: PerformanceMetrics }> {\n    this.startOperation(operationName);\n    try {\n      const result = await operation();\n      const metrics = this.endOperation(operationName, metadata);\n      return { result, metrics };\n    } catch (error) {\n      this.endOperation(operationName, { ...metadata, error: true });\n      throw error;\n    }\n  }\n\n  /**\n   * Measure sync operation performance\n   */\n  measureSync<T>(\n    operationName: string,\n    operation: () => T,\n    metadata?: Record<string, any>\n  ): { result: T; metrics: PerformanceMetrics } {\n    this.startOperation(operationName);\n    try {\n      const result = operation();\n      const metrics = this.endOperation(operationName, metadata);\n      return { result, metrics };\n    } catch (error) {\n      this.endOperation(operationName, { ...metadata, error: true });\n      throw error;\n    }\n  }\n\n  /**\n   * Validate performance against thresholds\n   */\n  validatePerformance(\n    operationName: string,\n    thresholds: PerformanceThresholds\n  ): { passed: boolean; metrics?: PerformanceMetrics; violations: string[] } {\n    const metrics = this.metrics.find(m => m.operationName === operationName);\n    if (!metrics) {\n      return { passed: false, violations: ['No metrics found for operation'] };\n    }\n\n    const violations: string[] = [];\n\n    if (metrics.duration > thresholds.maxDuration) {\n      violations.push(\n        `Duration ${metrics.duration.toFixed(2)}ms exceeds threshold ${thresholds.maxDuration}ms`\n      );\n    }\n\n    if (thresholds.maxMemoryUsage && metrics.memoryUsed) {\n      if (metrics.memoryUsed > thresholds.maxMemoryUsage) {\n        violations.push(\n          `Memory usage ${(metrics.memoryUsed / 1024 / 1024).toFixed(2)}MB exceeds threshold ${(\n            thresholds.maxMemoryUsage /\n            1024 /\n            1024\n          ).toFixed(2)}MB`\n        );\n      }\n    }\n\n    return {\n      passed: violations.length === 0,\n      metrics,\n      violations,\n    };\n  }\n\n  /**\n   * Get average performance metrics for an operation\n   */\n  getAverageMetrics(operationName: string): {\n    averageDuration: number;\n    averageMemory?: number;\n    sampleSize: number;\n  } {\n    const operationMetrics = this.metrics.filter(m => m.operationName === operationName);\n    if (operationMetrics.length === 0) {\n      return { averageDuration: 0, sampleSize: 0 };\n    }\n\n    const totalDuration = operationMetrics.reduce((sum, m) => sum + m.duration, 0);\n    const averageDuration = totalDuration / operationMetrics.length;\n\n    const metricsWithMemory = operationMetrics.filter(m => m.memoryUsed !== undefined);\n    const averageMemory =\n      metricsWithMemory.length > 0\n        ? metricsWithMemory.reduce((sum, m) => sum + (m.memoryUsed || 0), 0) /\n          metricsWithMemory.length\n        : undefined;\n\n    return {\n      averageDuration,\n      averageMemory,\n      sampleSize: operationMetrics.length,\n    };\n  }\n\n  /**\n   * Generate performance report\n   */\n  generateReport(): string {\n    const report: string[] = ['=== Performance Test Report ===\\n'];\n\n    const operationNames = [...new Set(this.metrics.map(m => m.operationName))];\n\n    operationNames.forEach(operationName => {\n      const avgMetrics = this.getAverageMetrics(operationName);\n      const operationMetrics = this.metrics.filter(m => m.operationName === operationName);\n\n      report.push(`\\nOperation: ${operationName}`);\n      report.push(`Samples: ${avgMetrics.sampleSize}`);\n      report.push(`Average Duration: ${avgMetrics.averageDuration.toFixed(2)}ms`);\n\n      if (avgMetrics.averageMemory) {\n        report.push(\n          `Average Memory: ${(avgMetrics.averageMemory / 1024 / 1024).toFixed(2)}MB`\n        );\n      }\n\n      // Find min/max durations\n      const durations = operationMetrics.map(m => m.duration);\n      report.push(`Min Duration: ${Math.min(...durations).toFixed(2)}ms`);\n      report.push(`Max Duration: ${Math.max(...durations).toFixed(2)}ms`);\n    });\n\n    return report.join('\\n');\n  }\n\n  /**\n   * Clear all metrics\n   */\n  clearMetrics(): void {\n    this.metrics = [];\n    this.activeTimers.clear();\n  }\n\n  /**\n   * Get current memory usage if available\n   */\n  private getCurrentMemoryUsage(): number | undefined {\n    if (global.performance && 'memory' in global.performance) {\n      return (global.performance as any).memory.usedJSHeapSize;\n    }\n    return undefined;\n  }\n}\n\nexport const performanceTestHelper = new PerformanceTestHelper();\n\n// Performance thresholds for common operations\nexport const PERFORMANCE_THRESHOLDS = {\n  ARTICLE_LIST_RENDER: { maxDuration: 1000 }, // 1 second\n  ARTICLE_SEARCH: { maxDuration: 500 }, // 500ms\n  SYNC_OPERATION: { maxDuration: 30000 }, // 30 seconds\n  NAVIGATION: { maxDuration: 300 }, // 300ms\n  API_CALL: { maxDuration: 5000 }, // 5 seconds\n  DATABASE_QUERY: { maxDuration: 100 }, // 100ms\n  IMAGE_LOAD: { maxDuration: 2000 }, // 2 seconds\n};","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/utils/retryManager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[194,197],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[194,197],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[231,234],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[231,234],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[321,324],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[321,324],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":95,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2858,2861],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2858,2861],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":95,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2876,2879],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2876,2879],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":119,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3571,3574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3571,3574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":133,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3916,3919],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3916,3919],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":139,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4085,4088],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4085,4088],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { logger } from './logger';\n\nexport interface RetryOptions {\n  maxRetries?: number;\n  initialDelay?: number;\n  maxDelay?: number;\n  backoffMultiplier?: number;\n  retryCondition?: (error: any) => boolean;\n  onRetry?: (error: any, attempt: number) => void;\n}\n\ninterface RetryState {\n  attempts: number;\n  lastError: any;\n  nextDelay: number;\n}\n\nexport class RetryManager {\n  private static defaultOptions: Required<RetryOptions> = {\n    maxRetries: 3,\n    initialDelay: 1000, // 1 second\n    maxDelay: 30000, // 30 seconds\n    backoffMultiplier: 2,\n    retryCondition: (error) => {\n      // Retry on network errors and 5xx errors\n      return error.code === 'CONNECTION_ERROR' ||\n             error.code === 'ECONNREFUSED' ||\n             error.code === 'TIMEOUT_ERROR' ||\n             (error.response?.status >= 500 && error.response?.status < 600);\n    },\n    onRetry: () => {},\n  };\n  \n  /**\n   * Execute a function with exponential backoff retry logic\n   */\n  static async withRetry<T>(\n    fn: () => Promise<T>,\n    options: RetryOptions = {}\n  ): Promise<T> {\n    const opts = { ...this.defaultOptions, ...options };\n    const state: RetryState = {\n      attempts: 0,\n      lastError: null,\n      nextDelay: opts.initialDelay,\n    };\n    \n    while (state.attempts <= opts.maxRetries) {\n      try {\n        // If not the first attempt, wait before retrying\n        if (state.attempts > 0) {\n          logger.debug(`[RetryManager] Waiting ${state.nextDelay}ms before retry attempt ${state.attempts}`);\n          await this.delay(state.nextDelay);\n        }\n        \n        // Try to execute the function\n        const result = await fn();\n        \n        // Success! Reset any retry state if needed\n        if (state.attempts > 0) {\n          logger.info(`[RetryManager] Succeeded after ${state.attempts} retries`);\n        }\n        \n        return result;\n      } catch (error) {\n        state.lastError = error;\n        state.attempts++;\n        \n        // Check if we should retry\n        if (state.attempts > opts.maxRetries || !opts.retryCondition(error)) {\n          logger.warn(`[RetryManager] Failed after ${state.attempts} attempts: ${error.message || error}`);\n          throw error;\n        }\n        \n        // Call onRetry callback\n        opts.onRetry(error, state.attempts);\n        \n        // Calculate next delay with exponential backoff\n        state.nextDelay = Math.min(\n          state.nextDelay * opts.backoffMultiplier,\n          opts.maxDelay\n        );\n        \n        logger.debug(`[RetryManager] Attempt ${state.attempts} failed, will retry in ${state.nextDelay}ms: ${error.message || error}`);\n      }\n    }\n    \n    // This should never be reached, but just in case\n    throw state.lastError;\n  }\n  \n  /**\n   * Create a retry wrapper for a specific function\n   */\n  static createRetryWrapper<T extends (...args: any[]) => Promise<any>>(\n    fn: T,\n    options: RetryOptions = {}\n  ): T {\n    return (async (...args: Parameters<T>) => {\n      return this.withRetry(() => fn(...args), options);\n    }) as T;\n  }\n  \n  /**\n   * Calculate delay for a specific attempt number\n   */\n  static calculateDelay(\n    attempt: number,\n    options: Pick<RetryOptions, 'initialDelay' | 'maxDelay' | 'backoffMultiplier'> = {}\n  ): number {\n    const opts = { ...this.defaultOptions, ...options };\n    const delay = opts.initialDelay * Math.pow(opts.backoffMultiplier, attempt - 1);\n    return Math.min(delay, opts.maxDelay);\n  }\n  \n  /**\n   * Check if an error is retryable based on default conditions\n   */\n  static isRetryableError(error: any): boolean {\n    return this.defaultOptions.retryCondition(error);\n  }\n  \n  private static delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n/**\n * Decorator for adding retry logic to async methods\n */\nexport function WithRetry(options: RetryOptions = {}) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    const originalMethod = descriptor.value;\n    \n    descriptor.value = async function (...args: any[]) {\n      return RetryManager.withRetry(\n        () => originalMethod.apply(this, args),\n        options\n      );\n    };\n    \n    return descriptor;\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/utils/security.ts","messages":[],"suppressedMessages":[{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00.","line":255,"column":33,"nodeType":"Literal","messageId":"unexpected","endLine":255,"endColumn":42,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/utils/storage.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":10,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":10,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[306,359],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":19,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":19,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[568,622],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import AsyncStorage from '@react-native-async-storage/async-storage';\n\nconst STORAGE_KEY = '@user_preferences';\n\nexport const saveUserPreferences = async preferences => {\n  try {\n    const jsonValue = JSON.stringify(preferences);\n    await AsyncStorage.setItem(STORAGE_KEY, jsonValue);\n  } catch (e) {\n    console.error('Failed to save user preferences:', e);\n  }\n};\n\nexport const getUserPreferences = async () => {\n  try {\n    const jsonValue = await AsyncStorage.getItem(STORAGE_KEY);\n    return jsonValue != null ? JSON.parse(jsonValue) : null;\n  } catch (e) {\n    console.error('Failed to fetch user preferences:', e);\n    return null;\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/t34wrj/Projects/mobdeck/src/utils/urlValidation.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":140,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":140,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[3774,3872],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * URL Validation Utilities\n * Comprehensive URL validation, normalization, and security checks\n */\n\nexport interface UrlValidationResult {\n  isValid: boolean;\n  normalizedUrl?: string;\n  errors: string[];\n  warnings: string[];\n}\n\nexport interface UrlValidationOptions {\n  allowedProtocols?: string[];\n  blockedDomains?: string[];\n  allowedDomains?: string[];\n  requireHttps?: boolean;\n  maxUrlLength?: number;\n  validateDomain?: boolean;\n}\n\nconst DEFAULT_VALIDATION_OPTIONS: Required<UrlValidationOptions> = {\n  allowedProtocols: ['http', 'https'],\n  blockedDomains: [],\n  allowedDomains: [],\n  requireHttps: false,\n  maxUrlLength: 2048,\n  validateDomain: true,\n};\n\n/**\n * Validates and normalizes a URL with comprehensive security checks\n */\nexport function validateUrl(\n  url: string,\n  options: UrlValidationOptions = {}\n): UrlValidationResult {\n  const opts = { ...DEFAULT_VALIDATION_OPTIONS, ...options };\n  const result: UrlValidationResult = {\n    isValid: false,\n    errors: [],\n    warnings: [],\n  };\n\n  try {\n    // Basic input validation\n    if (url === null || url === undefined || typeof url !== 'string') {\n      result.errors.push('URL is required and must be a string');\n      return result;\n    }\n\n    const trimmedUrl = url.trim();\n    if (!trimmedUrl) {\n      result.errors.push('URL cannot be empty');\n      return result;\n    }\n\n    // Check URL length\n    if (trimmedUrl.length > opts.maxUrlLength) {\n      result.errors.push(\n        `URL exceeds maximum length of ${opts.maxUrlLength} characters`\n      );\n      return result;\n    }\n\n    // Normalize URL (add protocol if missing)\n    const normalizedUrl = normalizeUrl(trimmedUrl);\n\n    let parsedUrl: URL;\n    try {\n      parsedUrl = new URL(normalizedUrl);\n    } catch (parseError) {\n      result.errors.push('Invalid URL format');\n      return result;\n    }\n\n    // Protocol validation\n    if (!opts.allowedProtocols.includes(parsedUrl.protocol.slice(0, -1))) {\n      result.errors.push(\n        `Protocol '${parsedUrl.protocol.slice(0, -1)}' is not allowed. Allowed protocols: ${opts.allowedProtocols.join(', ')}`\n      );\n      return result;\n    }\n\n    // HTTPS requirement check\n    if (opts.requireHttps && parsedUrl.protocol !== 'https:') {\n      result.errors.push('HTTPS protocol is required');\n      return result;\n    }\n\n    // Domain validation\n    if (opts.validateDomain) {\n      const domainValidation = validateDomain(parsedUrl.hostname);\n      if (!domainValidation.isValid) {\n        result.errors.push(...domainValidation.errors);\n        return result;\n      }\n      result.warnings.push(...domainValidation.warnings);\n    }\n\n    // Blocked domains check\n    if (\n      opts.blockedDomains.length > 0 &&\n      isBlockedDomain(parsedUrl.hostname, opts.blockedDomains)\n    ) {\n      result.errors.push(`Domain '${parsedUrl.hostname}' is blocked`);\n      return result;\n    }\n\n    // Allowed domains check (if specified)\n    if (\n      opts.allowedDomains.length > 0 &&\n      !isAllowedDomain(parsedUrl.hostname, opts.allowedDomains)\n    ) {\n      result.errors.push(\n        `Domain '${parsedUrl.hostname}' is not in the allowed domains list`\n      );\n      return result;\n    }\n\n    // Security checks\n    const securityCheck = performSecurityChecks(parsedUrl);\n    result.warnings.push(...securityCheck.warnings);\n    if (securityCheck.errors.length > 0) {\n      result.errors.push(...securityCheck.errors);\n      return result;\n    }\n\n    // If we get here, URL is valid\n    result.isValid = true;\n    result.normalizedUrl = parsedUrl.toString();\n\n    // Add informational warnings\n    if (parsedUrl.protocol === 'http:' && !opts.requireHttps) {\n      result.warnings.push('Using HTTP instead of HTTPS may be insecure');\n    }\n\n    return result;\n  } catch (error) {\n    console.error(\n      '[UrlValidation] Unexpected error during URL validation:',\n      error\n    );\n    result.errors.push('Unexpected error during URL validation');\n    return result;\n  }\n}\n\n/**\n * Normalizes a URL by adding protocol if missing and cleaning up formatting\n */\nexport function normalizeUrl(url: string): string {\n  let normalized = url.trim();\n\n  // Add protocol if missing (only if no protocol is present at all)\n  if (!normalized.match(/^[a-zA-Z][a-zA-Z0-9+.-]*:\\/\\//)) {\n    // Default to https for better security\n    normalized = `https://${normalized}`;\n  }\n\n  // Remove trailing slash for consistency (except for root domains)\n  try {\n    const urlObj = new URL(normalized);\n    if (urlObj.pathname !== '/' && normalized.endsWith('/')) {\n      // Remove trailing slash for paths but not root domains\n      normalized = normalized.slice(0, -1);\n    }\n  } catch {\n    // If URL parsing fails, use simple logic\n    if (normalized.endsWith('/') && normalized.split('/').length > 3) {\n      normalized = normalized.slice(0, -1);\n    }\n  }\n\n  return normalized;\n}\n\n/**\n * Validates domain format and checks for common issues\n */\nfunction validateDomain(hostname: string): {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n} {\n  const result = {\n    isValid: true,\n    errors: [] as string[],\n    warnings: [] as string[],\n  };\n\n  if (!hostname) {\n    result.isValid = false;\n    result.errors.push('Hostname is required');\n    return result;\n  }\n\n  // Check for localhost/private IPs\n  if (isLocalOrPrivateAddress(hostname)) {\n    result.warnings.push('URL points to a local or private address');\n  }\n\n  // Basic hostname format validation\n  const hostnameRegex =\n    /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n  if (!hostnameRegex.test(hostname)) {\n    result.isValid = false;\n    result.errors.push('Invalid hostname format');\n    return result;\n  }\n\n  // Check for minimum domain structure (at least one dot for TLD)\n  if (!hostname.includes('.') && !isLocalOrPrivateAddress(hostname)) {\n    result.isValid = false;\n    result.errors.push('Domain must have a valid TLD');\n    return result;\n  }\n\n  // Check for suspicious patterns\n  if (\n    hostname.includes('..') ||\n    hostname.startsWith('.') ||\n    hostname.endsWith('.')\n  ) {\n    result.isValid = false;\n    result.errors.push('Domain contains invalid characters or formatting');\n    return result;\n  }\n\n  return result;\n}\n\n/**\n * Checks if domain is in blocked domains list\n */\nfunction isBlockedDomain(hostname: string, blockedDomains: string[]): boolean {\n  return blockedDomains.some(\n    blocked => hostname === blocked || hostname.endsWith(`.${blocked}`)\n  );\n}\n\n/**\n * Checks if domain is in allowed domains list\n */\nfunction isAllowedDomain(hostname: string, allowedDomains: string[]): boolean {\n  return allowedDomains.some(\n    allowed => hostname === allowed || hostname.endsWith(`.${allowed}`)\n  );\n}\n\n/**\n * Checks if address is localhost or private IP range\n */\nfunction isLocalOrPrivateAddress(hostname: string): boolean {\n  // Localhost patterns\n  if (\n    hostname === 'localhost' ||\n    hostname === '127.0.0.1' ||\n    hostname === '::1'\n  ) {\n    return true;\n  }\n\n  // Private IP ranges\n  const privateIpRegexes = [\n    /^10\\./,\n    /^172\\.(1[6-9]|2[0-9]|3[0-1])\\./,\n    /^192\\.168\\./,\n    /^127\\./,\n    /^169\\.254\\./, // Link-local\n    /^fc00:/, // IPv6 unique local\n    /^fe80:/, // IPv6 link-local\n  ];\n\n  return privateIpRegexes.some(regex => regex.test(hostname));\n}\n\n/**\n * Performs additional security checks on the URL\n */\nfunction performSecurityChecks(url: URL): {\n  errors: string[];\n  warnings: string[];\n} {\n  const result = { errors: [] as string[], warnings: [] as string[] };\n\n  // Check for suspicious URL patterns\n  const suspiciousPatterns = [\n    /javascript:/i,\n    /data:/i,\n    /vbscript:/i,\n    /file:/i,\n    /ftp:/i,\n  ];\n\n  if (suspiciousPatterns.some(pattern => pattern.test(url.href))) {\n    result.errors.push('URL contains potentially unsafe protocol or scheme');\n  }\n\n  // Check for URL shorteners (informational warning)\n  const urlShorteners = [\n    'bit.ly',\n    'tinyurl.com',\n    't.co',\n    'goo.gl',\n    'ow.ly',\n    'short.link',\n    'tiny.cc',\n  ];\n\n  if (urlShorteners.some(shortener => url.hostname.includes(shortener))) {\n    result.warnings.push(\n      'URL appears to be shortened - consider expanding for security'\n    );\n  }\n\n  // Check for suspicious query parameters\n  const suspiciousParams = ['javascript', 'script', 'eval', 'onclick'];\n  const searchParams = new URLSearchParams(url.search);\n\n  for (const [key, value] of searchParams) {\n    if (\n      suspiciousParams.some(\n        param =>\n          key.toLowerCase().includes(param) ||\n          value.toLowerCase().includes(param)\n      )\n    ) {\n      result.warnings.push(\n        'URL contains potentially suspicious query parameters'\n      );\n      break;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Extracts and cleans URL from shared text that might contain other content\n */\nexport function extractUrlFromText(text: string): string | null {\n  if (!text || typeof text !== 'string') {\n    return null;\n  }\n\n  // URL regex pattern - matches http(s) URLs\n  const urlRegex =\n    /https?:\\/\\/(?:[-\\w.])+(?::[0-9]+)?(?:\\/(?:[\\w/_.])*(?:\\?(?:[\\w&=%.])*)?(?:#(?:[\\w.])*)?)?/gi;\n  const matches = text.match(urlRegex);\n\n  if (!matches || matches.length === 0) {\n    return null;\n  }\n\n  // Return the first URL found\n  return matches[0];\n}\n\n/**\n * Validates multiple URLs in batch\n */\nexport function validateUrls(\n  urls: string[],\n  options: UrlValidationOptions = {}\n): Array<UrlValidationResult & { originalUrl: string }> {\n  return urls.map(url => ({\n    originalUrl: url,\n    ...validateUrl(url, options),\n  }));\n}\n\n/**\n * Checks if a URL is likely an article/content URL vs other types\n */\nexport function isLikelyArticleUrl(url: string): boolean {\n  try {\n    const parsedUrl = new URL(url);\n    const pathname = parsedUrl.pathname.toLowerCase();\n\n    // Common article URL patterns\n    const articlePatterns = [\n      /\\/article/,\n      /\\/post/,\n      /\\/blog/,\n      /\\/news/,\n      /\\/story/,\n      /\\/[0-9]{4}\\/[0-9]{2}\\//, // Date patterns like /2024/01/\n    ];\n\n    // Common non-article patterns to avoid\n    const nonArticlePatterns = [\n      /\\.(jpg|jpeg|png|gif|pdf|mp4|mp3|zip|exe)$/i,\n      /\\/api\\//,\n      /\\/admin/,\n      /\\/login/,\n      /\\/register/,\n      /\\/search/,\n      /\\/category/,\n      /\\/tag/,\n    ];\n\n    // Check for non-article patterns first\n    if (nonArticlePatterns.some(pattern => pattern.test(pathname))) {\n      return false;\n    }\n\n    // Check for article patterns\n    if (articlePatterns.some(pattern => pattern.test(pathname))) {\n      return true;\n    }\n\n    // If pathname has multiple segments and ends with words (not file extensions), likely an article\n    const segments = pathname.split('/').filter(segment => segment.length > 0);\n    if (segments.length >= 2 && !pathname.includes('.')) {\n      return true;\n    }\n\n    return false;\n  } catch {\n    return false;\n  }\n}\n","usedDeprecatedRules":[]}]
